{"version":3,"file":"valibot.modern.mjs","sources":["../src/valibot.ts"],"sourcesContent":["import { toNestErrors } from '@hookform/resolvers';\nimport { FieldError, appendErrors, FieldValues } from 'react-hook-form';\nimport { getDotPath, safeParseAsync } from 'valibot';\nimport type { Resolver } from './types';\n\nexport const valibotResolver: Resolver =\n  (schema, schemaOptions, resolverOptions = {}) =>\n  async (values, _, options) => {\n    // Check if we should validate all field criteria\n    const validateAllFieldCriteria =\n      !options.shouldUseNativeValidation && options.criteriaMode === 'all';\n\n    // Parse values with Valibot schema\n    const result = await safeParseAsync(schema, values, {\n      ...schemaOptions,\n      abortPipeEarly: !validateAllFieldCriteria,\n    });\n\n    // If there are issues, return them as errors\n    if (result.issues) {\n      // Create errors object\n      const errors: Record<string, FieldError> = {};\n\n      // Iterate over issues to add them to errors object\n      for (const issue of result.issues) {\n        // Create dot path from issue\n        const path = getDotPath(issue);\n\n        if (path) {\n          // Add first error of path to errors object\n          if (!errors[path]) {\n            errors[path] = { message: issue.message, type: issue.type };\n          }\n\n          // If configured, add all errors of path to errors object\n          if (validateAllFieldCriteria) {\n            const types = errors[path].types;\n            const messages = types && types[issue.type];\n            errors[path] = appendErrors(\n              path,\n              validateAllFieldCriteria,\n              errors,\n              issue.type,\n              messages\n                ? ([] as string[]).concat(\n                    messages as string | string[],\n                    issue.message,\n                  )\n                : issue.message,\n            ) as FieldError;\n          }\n        }\n      }\n\n      // Return resolver result with errors\n      return {\n        values: {},\n        errors: toNestErrors(errors, options),\n      } as const;\n    }\n\n    // Otherwise, return resolver result with values\n    return {\n      values: resolverOptions.raw ? values : (result.output as FieldValues),\n      errors: {},\n    };\n  };\n"],"names":["valibotResolver","schema","schemaOptions","resolverOptions","async","values","_","options","validateAllFieldCriteria","shouldUseNativeValidation","criteriaMode","result","safeParseAsync","_extends","abortPipeEarly","issues","errors","issue","path","getDotPath","message","type","types","messages","appendErrors","concat","toNestErrors","raw","output"],"mappings":"+XAKa,MAAAA,EACXA,CAACC,EAAQC,EAAeC,EAAkB,CAAE,IAC5CC,MAAOC,EAAQC,EAAGC,KAEhB,MAAMC,GACHD,EAAQE,2BAAsD,QAAzBF,EAAQG,aAG1CC,QAAeC,EAAeX,EAAQI,EAAMQ,EAAA,GAC7CX,EAAa,CAChBY,gBAAiBN,KAInB,GAAIG,EAAOI,OAAQ,CAEjB,MAAMC,EAAqC,CAAA,EAG3C,IAAK,MAAMC,KAASN,EAAOI,OAAQ,CAEjC,MAAMG,EAAOC,EAAWF,GAExB,GAAIC,IAEGF,EAAOE,KACVF,EAAOE,GAAQ,CAAEE,QAASH,EAAMG,QAASC,KAAMJ,EAAMI,OAInDb,GAA0B,CAC5B,MAAMc,EAAQN,EAAOE,GAAMI,MACrBC,EAAWD,GAASA,EAAML,EAAMI,MACtCL,EAAOE,GAAQM,EACbN,EACAV,EACAQ,EACAC,EAAMI,KACNE,EACK,GAAgBE,OACfF,EACAN,EAAMG,SAERH,EAAMG,QAEb,CAEJ,CAGD,MAAO,CACLf,OAAQ,CAAA,EACRW,OAAQU,EAAaV,EAAQT,GAEhC,CAGD,MAAO,CACLF,OAAQF,EAAgBwB,IAAMtB,EAAUM,EAAOiB,OAC/CZ,OAAQ,CAAA"}