import{toNestErrors as r}from"@hookform/resolvers";import{appendErrors as e}from"react-hook-form";import{safeParseAsync as t,getDotPath as o}from"valibot";function n(){return n=Object.assign?Object.assign.bind():function(r){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(r[o]=t[o])}return r},n.apply(this,arguments)}function a(r,e){(null==e||e>r.length)&&(e=r.length);for(var t=0,o=new Array(e);t<e;t++)o[t]=r[t];return o}var i=function(i,s,u){return void 0===u&&(u={}),function(l,c,f){try{var m=!f.shouldUseNativeValidation&&"all"===f.criteriaMode;return Promise.resolve(t(i,l,n({},s,{abortPipeEarly:!m}))).then(function(t){if(t.issues){for(var n,i={},s=function(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(t)return(t=t.call(r)).next.bind(t);if(Array.isArray(r)||(t=function(r,e){if(r){if("string"==typeof r)return a(r,e);var t=Object.prototype.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?a(r,e):void 0}}(r))){t&&(r=t);var o=0;return function(){return o>=r.length?{done:!0}:{done:!1,value:r[o++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}(t.issues);!(n=s()).done;){var c=n.value,p=o(c);if(p&&(i[p]||(i[p]={message:c.message,type:c.type}),m)){var v=i[p].types,y=v&&v[c.type];i[p]=e(p,m,i,c.type,y?[].concat(y,c.message):c.message)}}return{values:{},errors:r(i,f)}}return{values:u.raw?l:t.output,errors:{}}})}catch(r){return Promise.reject(r)}}};export{i as valibotResolver};
//# sourceMappingURL=valibot.module.js.map
