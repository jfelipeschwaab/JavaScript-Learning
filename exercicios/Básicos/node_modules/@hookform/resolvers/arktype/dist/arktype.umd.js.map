{"version":3,"file":"arktype.umd.js","sources":["../../node_modules/.pnpm/@arktype+util@0.0.44/node_modules/@arktype/util/out/arrays.js","../../node_modules/.pnpm/@arktype+util@0.0.44/node_modules/@arktype/util/out/errors.js","../../node_modules/.pnpm/@arktype+util@0.0.44/node_modules/@arktype/util/out/flatMorph.js","../../node_modules/.pnpm/@arktype+util@0.0.44/node_modules/@arktype/util/out/records.js","../../node_modules/.pnpm/@arktype+util@0.0.44/node_modules/@arktype/util/out/functions.js","../../node_modules/.pnpm/@arktype+util@0.0.44/node_modules/@arktype/util/out/domain.js","../../node_modules/.pnpm/@arktype+util@0.0.44/node_modules/@arktype/util/out/objectKinds.js","../../node_modules/.pnpm/@arktype+util@0.0.44/node_modules/@arktype/util/out/primitive.js","../../node_modules/.pnpm/@arktype+util@0.0.44/node_modules/@arktype/util/out/registry.js","../../node_modules/.pnpm/@arktype+util@0.0.44/node_modules/@arktype/util/out/compilation.js","../../node_modules/.pnpm/@arktype+util@0.0.44/node_modules/@arktype/util/out/hkt.js","../../node_modules/.pnpm/@arktype+util@0.0.44/node_modules/@arktype/util/out/numericLiterals.js","../../node_modules/.pnpm/@arktype+util@0.0.44/node_modules/@arktype/util/out/serialize.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/shared/utils.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/shared/implement.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/config.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/shared/errors.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/shared/traversal.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/node.js","../../node_modules/.pnpm/@arktype+util@0.0.44/node_modules/@arktype/util/out/clone.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/shared/disjoint.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/shared/intersections.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/constraint.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/predicate.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/refinements/divisor.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/refinements/range.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/refinements/after.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/refinements/before.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/refinements/exactLength.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/refinements/max.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/refinements/maxLength.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/refinements/kinds.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/refinements/min.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/refinements/minLength.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/refinements/regex.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/roots/root.js","../../node_modules/.pnpm/@arktype+util@0.0.44/node_modules/@arktype/util/out/strings.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/roots/utils.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/roots/alias.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/roots/basis.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/roots/domain.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/shared/declare.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/roots/intersection.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/roots/morph.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/roots/proto.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/roots/union.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/roots/unit.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/structure/index.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/structure/prop.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/structure/optional.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/structure/required.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/structure/sequence.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/structure/shared.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/structure/structure.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/kinds.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/module.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/parse.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/shared/compile.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/scope.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/generic.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/keywords/tsKeywords.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/keywords/internal.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/keywords/jsObjects.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/keywords/utils/regex.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/keywords/parsing.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/keywords/utils/date.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/keywords/utils/ip.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/keywords/validation.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/keywords/utils/creditCard.js","../../node_modules/.pnpm/@arktype+schema@0.1.6/node_modules/@arktype/schema/out/keywords/keywords.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/generic.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/parser/string/shift/scanner.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/parser/objectLiteral.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/parser/string/reduce/shared.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/parser/string/shift/operand/genericArgs.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/parser/string/shift/operand/unenclosed.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/parser/tuple.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/parser/definition.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/parser/string/shift/operand/date.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/parser/string/shift/operator/bounds.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/parser/string/shift/operator/divisor.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/parser/string/shift/operator/operator.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/parser/generic.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/parser/string/shift/operand/enclosed.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/parser/string/shift/operand/operand.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/parser/semantic/validate.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/parser/string/string.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/parser/string/reduce/dynamic.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/type.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/scope.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/match.js","../../node_modules/.pnpm/arktype@2.0.0-dev.14/node_modules/arktype/out/ark.js","../src/arktype.ts"],"sourcesContent":["export const getPath = (root, path) => {\n    let result = root;\n    for (const segment of path) {\n        if (typeof result !== \"object\" || result === null)\n            return undefined;\n        result = result[segment];\n    }\n    return result;\n};\nexport const intersectUniqueLists = (l, r) => {\n    const intersection = [...l];\n    for (const item of r)\n        if (!l.includes(item))\n            intersection.push(item);\n    return intersection;\n};\nexport const arrayFrom = (data) => (Array.isArray(data) ? data : [data]);\nexport const spliterate = (list, by) => {\n    const result = [[], []];\n    for (const item of list) {\n        if (by(item))\n            result[0].push(item);\n        else\n            result[1].push(item);\n    }\n    return result;\n};\nexport const ReadonlyArray = Array;\nexport const includes = (array, element) => array.includes(element);\nexport const range = (length, offset = 0) => [...new Array(length)].map((_, i) => i + offset);\n/**\n * Adds a value or array to an array, returning the concatenated result\n *\n * @param to The array to which `value` is to be added. If `to` is `undefined`, a new array\n * is created as `[value]` if value was not undefined, otherwise `[]`.\n * @param value The value to add to the array. If `value` is `undefined`, does nothing.\n * @param opts\n * \t\tprepend: If true, adds the element to the beginning of the array instead of the end\n */\nexport const append = (to, value, opts) => {\n    if (value === undefined)\n        return to ?? [];\n    if (to === undefined) {\n        return (value === undefined ? []\n            : Array.isArray(value) ? value\n                : [value]);\n    }\n    if (opts?.prepend)\n        Array.isArray(value) ? to.unshift(...value) : to.unshift(value);\n    else\n        Array.isArray(value) ? to.push(...value) : to.push(value);\n    return to;\n};\n/**\n * Concatenates an element or list with a readonly list\n *\n * @param {to} to - The base list.\n * @param {elementOrList} elementOrList - The element or list to concatenate.\n */\nexport const conflatenate = (to, elementOrList) => {\n    if (elementOrList === undefined || elementOrList === null)\n        return to ?? [];\n    if (to === undefined || to === null)\n        return arrayFrom(elementOrList);\n    return to.concat(elementOrList);\n};\n/**\n * Concatenates a variadic list of elements or lists with a readonly list\n *\n * @param {to} to - The base list.\n * @param {elementsOrLists} elementsOrLists - The elements or lists to concatenate.\n */\nexport const conflatenateAll = (...elementsOrLists) => elementsOrLists.reduce(conflatenate, []);\n/**\n * Appends a value to an array if it is not already included, returning the array\n *\n * @param to The array to which `value` is to be appended. If `to` is `undefined`, a new array\n * is created including only `value`.\n * @param value The value to append to the array. If `to` includes `value`, nothing is appended.\n */\nexport const appendUnique = (to, value) => {\n    if (to === undefined)\n        return [value];\n    if (!to.includes(value))\n        to.push(value);\n    return to;\n};\nexport const groupBy = (array, discriminant) => array.reduce((result, item) => {\n    const key = item[discriminant];\n    result[key] ??= [];\n    result[key].push(item);\n    return result;\n}, {});\n","export class InternalArktypeError extends Error {\n}\nexport const throwInternalError = message => throwError(message, InternalArktypeError);\nexport const throwError = (message, ctor = Error) => {\n    throw new ctor(message);\n};\nexport class ParseError extends Error {\n    name = \"ParseError\";\n}\nexport const throwParseError = message => throwError(message, ParseError);\n","// eslint-disable-next-line prefer-arrow-functions/prefer-arrow-functions\nexport function flatMorph(o, flatMapEntry) {\n    const inputIsArray = Array.isArray(o);\n    const entries = Object.entries(o).flatMap((entry, i) => {\n        const result = inputIsArray ? flatMapEntry(i, entry[1]) : flatMapEntry(...entry, i);\n        const entrySet = Array.isArray(result[0]) || result.length === 0 ?\n            // if we have an empty array (for filtering) or an array with\n            // another array as its first element, treat it as a list of\n            result\n            // otherwise, it should be a single entry, so nest it in a tuple\n            // so it doesn't get spread when the result is flattened\n            : [result];\n        return entrySet;\n    });\n    const objectResult = Object.fromEntries(entries);\n    return typeof entries[0]?.[0] === \"number\" ?\n        Object.values(objectResult)\n        : objectResult;\n}\n","import { flatMorph } from \"./flatMorph.js\";\nexport const entriesOf = (o) => Object.entries(o);\nexport const fromEntries = (entries) => Object.fromEntries(entries);\nexport const keysOf = (o) => Object.keys(o);\nexport const isKeyOf = (k, o) => k in o;\nexport const hasKey = (o, k) => k in o;\n// must be defined this way to avoid https://github.com/microsoft/TypeScript/issues/55049\nexport const hasDefinedKey = (o, k) => o[k] !== undefined;\nexport const InnerDynamicBase = class {\n    constructor(properties) {\n        Object.assign(this, properties);\n    }\n};\n/** @ts-expect-error (needed to extend `t`, but safe given ShallowClone's implementation) **/\nexport class DynamicBase extends InnerDynamicBase {\n}\nexport const NoopBase = class {\n};\n/** @ts-expect-error (see DynamicBase) **/\nexport class CastableBase extends NoopBase {\n}\nexport const splitByKeys = (o, leftKeys) => {\n    const l = {};\n    const r = {};\n    let k;\n    for (k in o) {\n        if (k in leftKeys)\n            l[k] = o[k];\n        else\n            r[k] = o[k];\n    }\n    return [l, r];\n};\nexport const pick = (o, keys) => splitByKeys(o, keys)[0];\nexport const omit = (o, keys) => splitByKeys(o, keys)[1];\nexport const isEmptyObject = (o) => Object.keys(o).length === 0;\nexport const stringAndSymbolicEntriesOf = (o) => [\n    ...Object.entries(o),\n    ...Object.getOwnPropertySymbols(o).map(k => [k, o[k]])\n];\n/** Like Object.assign, but it will preserve getters instead of evaluating them. */\nexport const defineProperties = (base, merged) => \n// declared like this to avoid https://github.com/microsoft/TypeScript/issues/55049\nObject.defineProperties(base, Object.getOwnPropertyDescriptors(merged));\nexport const invert = (t) => flatMorph(t, (k, v) => [v, k]);\nexport const unset = Symbol(\"represents an uninitialized value\");\n","import { throwInternalError } from \"./errors.js\";\nimport { NoopBase, unset } from \"./records.js\";\nexport const bound = (target, ctx) => {\n    ctx.addInitializer(function () {\n        this[ctx.name] = this[ctx.name].bind(this);\n    });\n};\nexport const cached = (target, context) => function () {\n    const value = target.call(this);\n    Object.defineProperty(this, context.name, context.kind === \"getter\" ?\n        { value }\n        : {\n            value: () => value,\n            enumerable: false\n        });\n    return value;\n};\nexport const cachedThunk = (thunk) => {\n    let result = unset;\n    return () => (result === unset ? (result = thunk()) : result);\n};\nexport const isThunk = (value) => typeof value === \"function\" && value.length === 0;\nexport const tryCatch = (fn, onError) => {\n    try {\n        return fn();\n    }\n    catch (e) {\n        return onError?.(e);\n    }\n};\nexport const DynamicFunction = class extends Function {\n    constructor(...args) {\n        const params = args.slice(0, -1);\n        const body = args.at(-1);\n        try {\n            super(...params, body);\n        }\n        catch (e) {\n            return throwInternalError(`Encountered an unexpected error while compiling your definition:\n                Message: ${e} \n                Source: (${args.slice(0, -1)}) => {\n                    ${args.at(-1)}\n                }`);\n        }\n    }\n};\n/** @ts-expect-error required to cast function type */\nexport class Callable extends NoopBase {\n    constructor(f, opts) {\n        super();\n        return Object.assign(Object.setPrototypeOf(f.bind(opts?.bind ?? this), this.constructor.prototype), opts?.attach);\n    }\n}\n/**\n * Checks if the environment has Content Security Policy (CSP) enabled,\n * preventing JIT-optimized code from being compiled via new Function().\n *\n * @returns `true` if a function created using new Function() can be\n * successfully invoked in the environment, `false` otherwise.\n *\n * The result is cached for subsequent invocations.\n */\nexport const envHasCsp = cachedThunk(() => {\n    try {\n        return new Function(\"return false\")();\n    }\n    catch (e) {\n        return true;\n    }\n});\n","export const hasDomain = (data, kind) => domainOf(data) === kind;\nexport const domainOf = (data) => {\n    const builtinType = typeof data;\n    return (builtinType === \"object\" ?\n        data === null ?\n            \"null\"\n            : \"object\"\n        : builtinType === \"function\" ? \"object\"\n            : builtinType);\n};\nconst enumerableDomainDescriptions = {\n    boolean: \"boolean\",\n    null: \"null\",\n    undefined: \"undefined\"\n};\nconst nonEnumerableDomainDescriptions = {\n    bigint: \"a bigint\",\n    number: \"a number\",\n    object: \"an object\",\n    string: \"a string\",\n    symbol: \"a symbol\"\n};\n/** Each domain's completion for the phrase \"must be _____\" */\nexport const domainDescriptions = {\n    ...nonEnumerableDomainDescriptions,\n    ...enumerableDomainDescriptions\n};\n","import { domainOf } from \"./domain.js\";\nimport { isKeyOf } from \"./records.js\";\n// Built-in object constructors based on a subset of:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\nexport const builtinConstructors = {\n    Array,\n    Date,\n    Error,\n    Function,\n    Map,\n    RegExp,\n    Set,\n    String,\n    Number,\n    Boolean,\n    WeakMap,\n    WeakSet,\n    Promise\n};\nexport const objectKindOf = (data) => {\n    let prototype = Object.getPrototypeOf(data);\n    while (prototype?.constructor &&\n        (!isKeyOf(prototype.constructor.name, builtinConstructors) ||\n            !(data instanceof builtinConstructors[prototype.constructor.name])))\n        prototype = Object.getPrototypeOf(prototype);\n    const name = prototype?.constructor?.name;\n    if (name === undefined || name === \"Object\")\n        return undefined;\n    return name;\n};\nexport const objectKindOrDomainOf = (data) => (typeof data === \"object\" && data !== null ?\n    objectKindOf(data) ?? \"object\"\n    : domainOf(data));\nexport const hasObjectKind = (data, kind) => objectKindOf(data) === kind;\nexport const isArray = (data) => Array.isArray(data);\n/** Each defaultObjectKind's completion for the phrase \"must be _____\" */\nexport const objectKindDescriptions = {\n    Array: \"an array\",\n    Function: \"a function\",\n    Date: \"a Date\",\n    RegExp: \"a RegExp\",\n    Error: \"an Error\",\n    Map: \"a Map\",\n    Set: \"a Set\",\n    String: \"a String object\",\n    Number: \"a Number object\",\n    Boolean: \"a Boolean object\",\n    Promise: \"a Promise\",\n    WeakMap: \"a WeakMap\",\n    WeakSet: \"a WeakSet\"\n};\n// this will only return an object kind if it's the root constructor\n// example TypeError would return undefined not 'Error'\nexport const getExactBuiltinConstructorName = (ctor) => {\n    const constructorName = Object(ctor).name ?? null;\n    return (constructorName &&\n        isKeyOf(constructorName, builtinConstructors) &&\n        builtinConstructors[constructorName] === ctor) ?\n        constructorName\n        : null;\n};\n/**\n * Returns an array of constructors for all ancestors (i.e., prototypes) of a given object.\n *\n * @param {object} o - The object to find the ancestors of.\n * @returns {Function[]} An array of constructors for all ancestors of the object.\n */\nexport const ancestorsOf = (o) => {\n    let proto = Object.getPrototypeOf(o);\n    const result = [];\n    while (proto !== null) {\n        result.push(proto.constructor);\n        proto = Object.getPrototypeOf(proto);\n    }\n    return result;\n};\n/** Mimics output of TS's keyof operator at runtime */\nexport const prototypeKeysOf = (value) => {\n    const result = [];\n    let curr = value;\n    while (curr !== Object.prototype && curr !== null && curr !== undefined) {\n        for (const k of Object.getOwnPropertyNames(curr))\n            if (k !== \"constructor\" && !result.includes(k))\n                result.push(k);\n        for (const symbol of Object.getOwnPropertySymbols(curr))\n            if (!result.includes(symbol))\n                result.push(symbol);\n        curr = Object.getPrototypeOf(curr);\n    }\n    return result;\n};\nconst baseKeysByDomain = {\n    bigint: prototypeKeysOf(0n),\n    boolean: prototypeKeysOf(false),\n    null: [],\n    number: prototypeKeysOf(0),\n    // TS doesn't include the Object prototype in keyof, so keyof object is never\n    object: [],\n    string: prototypeKeysOf(\"\"),\n    symbol: prototypeKeysOf(Symbol()),\n    undefined: []\n};\nexport const getBaseDomainKeys = (domain) => [...baseKeysByDomain[domain]];\nexport const constructorExtends = (ctor, base) => {\n    let current = ctor.prototype;\n    while (current !== null) {\n        if (current === base.prototype)\n            return true;\n        current = Object.getPrototypeOf(current);\n    }\n    return false;\n};\n","export const serializePrimitive = (value) => (typeof value === \"string\" ? JSON.stringify(value)\n    : typeof value === \"bigint\" ? `${value}n`\n        : `${value}`);\n","import { domainOf, hasDomain } from \"./domain.js\";\nimport { throwInternalError } from \"./errors.js\";\nimport { objectKindOf } from \"./objectKinds.js\";\nimport { serializePrimitive } from \"./primitive.js\";\nexport const registry = {};\nglobalThis.$ark = registry;\nconst namesByResolution = new WeakMap();\nconst nameCounts = {};\nexport const register = (value) => {\n    const existingName = namesByResolution.get(value);\n    if (existingName)\n        return existingName;\n    let name = baseNameFor(value);\n    if (nameCounts[name])\n        name = `${name}${nameCounts[name]++}`;\n    else\n        nameCounts[name] = 1;\n    registry[name] = value;\n    namesByResolution.set(value, name);\n    return name;\n};\nexport const reference = (name) => `$ark.${name}`;\nexport const registeredReference = (value) => reference(register(value));\nexport const isDotAccessible = (keyName) => /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(keyName);\nexport const compileSerializedValue = (value) => hasDomain(value, \"object\") || typeof value === \"symbol\" ?\n    registeredReference(value)\n    : serializePrimitive(value);\nconst baseNameFor = (value) => {\n    switch (typeof value) {\n        case \"object\": {\n            if (value === null)\n                break;\n            const prefix = objectKindOf(value) ?? \"object\";\n            // convert to camelCase\n            return prefix[0].toLowerCase() + prefix.slice(1);\n        }\n        case \"function\":\n            return isDotAccessible(value.name) ? value.name : \"fn\";\n        case \"symbol\":\n            return value.description && isDotAccessible(value.description) ?\n                value.description\n                : \"symbol\";\n    }\n    return throwInternalError(`Unexpected attempt to register serializable value of type ${domainOf(value)}`);\n};\n","import { DynamicFunction } from \"./functions.js\";\nimport { CastableBase } from \"./records.js\";\nimport { isDotAccessible, registeredReference } from \"./registry.js\";\nexport class CompiledFunction extends CastableBase {\n    argNames;\n    body = \"\";\n    constructor(...args) {\n        super();\n        this.argNames = args;\n        for (const arg of args) {\n            if (arg in this) {\n                throw new Error(`Arg name '${arg}' would overwrite an existing property on FunctionBody`);\n            }\n            ;\n            this[arg] = arg;\n        }\n    }\n    indentation = 0;\n    indent() {\n        this.indentation += 4;\n        return this;\n    }\n    dedent() {\n        this.indentation -= 4;\n        return this;\n    }\n    prop(key, optional = false) {\n        return compileLiteralPropAccess(key, optional);\n    }\n    index(key, optional = false) {\n        return indexPropAccess(`${key}`, optional);\n    }\n    line(statement) {\n        ;\n        this.body += `${\" \".repeat(this.indentation)}${statement}\\n`;\n        return this;\n    }\n    const(identifier, expression) {\n        this.line(`const ${identifier} = ${expression}`);\n        return this;\n    }\n    let(identifier, expression) {\n        return this.line(`let ${identifier} = ${expression}`);\n    }\n    set(identifier, expression) {\n        return this.line(`${identifier} = ${expression}`);\n    }\n    if(condition, then) {\n        return this.block(`if (${condition})`, then);\n    }\n    elseIf(condition, then) {\n        return this.block(`else if (${condition})`, then);\n    }\n    else(then) {\n        return this.block(\"else\", then);\n    }\n    /** Current index is \"i\" */\n    for(until, body, initialValue = 0) {\n        return this.block(`for (let i = ${initialValue}; ${until}; i++)`, body);\n    }\n    /** Current key is \"k\" */\n    forIn(object, body) {\n        return this.block(`for (const k in ${object})`, body);\n    }\n    block(prefix, contents, suffix = \"\") {\n        this.line(`${prefix} {`);\n        this.indent();\n        contents(this);\n        this.dedent();\n        return this.line(`}${suffix}`);\n    }\n    return(expression = \"\") {\n        return this.line(`return ${expression}`);\n    }\n    compile() {\n        return new DynamicFunction(...this.argNames, this.body);\n    }\n}\nexport const compileLiteralPropAccess = (key, optional = false) => {\n    if (typeof key === \"string\" && isDotAccessible(key))\n        return `${optional ? \"?\" : \"\"}.${key}`;\n    return indexPropAccess(serializeLiteralKey(key), optional);\n};\nexport const serializeLiteralKey = (key) => typeof key === \"symbol\" ? registeredReference(key) : JSON.stringify(key);\nexport const indexPropAccess = (key, optional = false) => `${optional ? \"?.\" : \"\"}[${key}]`;\n","/** A small set of HKT utility types based on https://github.com/poteat/hkt-toolbelt */\nexport var Hkt;\n(function (Hkt) {\n    class Kind {\n    }\n    Hkt.Kind = Kind;\n    class Instantiable {\n    }\n    Hkt.Instantiable = Instantiable;\n    Hkt.reify = (def) => def.hkt;\n    class UnaryKind {\n    }\n    Hkt.UnaryKind = UnaryKind;\n    Hkt.pipe = (...kinds) => In => kinds.reduce((out, kind) => kind.hkt(out), In);\n})(Hkt || (Hkt = {}));\n","import { throwParseError } from \"./errors.js\";\n/**\n * The goal of the number literal and bigint literal regular expressions is to:\n *\n *   1. Ensure definitions form a bijection with the values they represent.\n *   2. Attempt to mirror TypeScript's own format for stringification of numeric\n *      values such that the regex should match a given definition if any only if\n *      a precise literal type will be inferred (in TS4.8+).\n */\n/**\n *  Matches a well-formatted numeric expression according to the following rules:\n *    1. Must include an integer portion (i.e. '.321' must be written as '0.321')\n *    2. The first digit of the value must not be 0, unless the entire integer portion is 0\n *    3. If the value includes a decimal, its last digit may not be 0\n *    4. The value may not be \"-0\"\n */\nexport const wellFormedNumberMatcher = /^(?!^-0$)-?(?:0|[1-9]\\d*)(?:\\.\\d*[1-9])?$/;\nexport const isWellFormedNumber = wellFormedNumberMatcher.test.bind(wellFormedNumberMatcher);\nconst numberLikeMatcher = /^-?\\d*\\.?\\d*$/;\nconst isNumberLike = (s) => s.length !== 0 && numberLikeMatcher.test(s);\n/**\n *  Matches a well-formatted integer according to the following rules:\n *    1. must begin with an integer, the first digit of which cannot be 0 unless the entire value is 0\n *    2. The value may not be \"-0\"\n */\nexport const wellFormedIntegerMatcher = /^(?:0|(?:-?[1-9]\\d*))$/;\nexport const isWellFormedInteger = wellFormedIntegerMatcher.test.bind(wellFormedIntegerMatcher);\nconst integerLikeMatcher = /^-?\\d+$/;\nconst isIntegerLike = integerLikeMatcher.test.bind(integerLikeMatcher);\nconst numericLiteralDescriptions = {\n    number: \"a number\",\n    bigint: \"a bigint\",\n    integer: \"an integer\"\n};\nexport const writeMalformedNumericLiteralMessage = (def, kind) => `'${def}' was parsed as ${numericLiteralDescriptions[kind]} but could not be narrowed to a literal value. Avoid unnecessary leading or trailing zeros and other abnormal notation`;\nconst isWellFormed = (def, kind) => kind === \"number\" ? isWellFormedNumber(def) : isWellFormedInteger(def);\nconst parseKind = (def, kind) => kind === \"number\" ? Number(def) : Number.parseInt(def);\nconst isKindLike = (def, kind) => kind === \"number\" ? isNumberLike(def) : isIntegerLike(def);\nexport const tryParseNumber = (token, options) => parseNumeric(token, \"number\", options);\nexport const tryParseInteger = (token, options) => parseNumeric(token, \"integer\", options);\nconst parseNumeric = (token, kind, options) => {\n    const value = parseKind(token, kind);\n    if (!Number.isNaN(value)) {\n        if (isKindLike(token, kind)) {\n            if (options?.strict) {\n                return isWellFormed(token, kind) ? value : (throwParseError(writeMalformedNumericLiteralMessage(token, kind)));\n            }\n            return value;\n        }\n    }\n    return (options?.errorOnFail ?\n        throwParseError(options?.errorOnFail === true ?\n            `Failed to parse ${numericLiteralDescriptions[kind]} from '${token}'`\n            : options?.errorOnFail)\n        : undefined);\n};\nexport const tryParseWellFormedBigint = (def) => {\n    if (def[def.length - 1] !== \"n\")\n        return;\n    const maybeIntegerLiteral = def.slice(0, -1);\n    let value;\n    try {\n        value = BigInt(maybeIntegerLiteral);\n    }\n    catch {\n        return;\n    }\n    if (wellFormedIntegerMatcher.test(maybeIntegerLiteral))\n        return value;\n    if (integerLikeMatcher.test(maybeIntegerLiteral)) {\n        // If the definition looks like a bigint but is\n        // not well-formed, throw.\n        return throwParseError(writeMalformedNumericLiteralMessage(def, \"bigint\"));\n    }\n};\n","import { domainOf } from \"./domain.js\";\nimport { serializePrimitive } from \"./primitive.js\";\nimport { register } from \"./registry.js\";\nexport const snapshot = (data, opts = { onUndefined: \"(undefined)\" }) => _serialize(data, opts, []);\nexport const print = (data, indent) => console.log(printable(data, indent));\nexport const printable = (data, indent) => {\n    switch (domainOf(data)) {\n        case \"object\":\n            return data instanceof Date ?\n                data.toDateString()\n                : JSON.stringify(_serialize(data, printableOpts, []), null, indent);\n        case \"symbol\":\n            return printableOpts.onSymbol(data);\n        default:\n            return serializePrimitive(data);\n    }\n};\nconst printableOpts = {\n    onCycle: () => \"(cycle)\",\n    onSymbol: v => `Symbol(${register(v)})`,\n    onFunction: v => `Function(${register(v)})`\n};\nconst _serialize = (data, opts, seen) => {\n    switch (domainOf(data)) {\n        case \"object\": {\n            if (typeof data === \"function\")\n                return printableOpts.onFunction(data);\n            if (seen.includes(data))\n                return \"(cycle)\";\n            const nextSeen = [...seen, data];\n            if (Array.isArray(data))\n                return data.map(item => _serialize(item, opts, nextSeen));\n            if (data instanceof Date)\n                return data.toDateString();\n            const result = {};\n            for (const k in data)\n                result[k] = _serialize(data[k], opts, nextSeen);\n            return result;\n        }\n        case \"symbol\":\n            return printableOpts.onSymbol(data);\n        case \"bigint\":\n            return `${data}n`;\n        case \"undefined\":\n            return opts.onUndefined ?? \"undefined\";\n        default:\n            return data;\n    }\n};\n","import { flatMorph, isArray, isDotAccessible, printable } from \"@arktype/util\";\nexport const makeRootAndArrayPropertiesMutable = (o) => \n// TODO: this cast should not be required, but it seems TS is referencing\n// the wrong parameters here?\nflatMorph(o, (k, v) => [k, isArray(v) ? [...v] : v]);\nexport const pathToPropString = (path) => {\n    const propAccessChain = path.reduce((s, k) => typeof k === \"string\" && isDotAccessible(k) ?\n        `${s}.${k}`\n        : `${s}[${printable(k)}]`, \"\");\n    return propAccessChain[0] === \".\" ? propAccessChain.slice(1) : propAccessChain;\n};\nexport const arkKind = Symbol(\"ArkTypeInternalKind\");\nexport const hasArkKind = (value, kind) => value?.[arkKind] === kind;\nexport const isNode = (value) => hasArkKind(value, \"root\") || hasArkKind(value, \"constraint\");\n// ideally this could be just declared since it is not used at runtime,\n// but it doesn't play well with typescript-eslint: https://github.com/typescript-eslint/typescript-eslint/issues/4608\n// easiest solution seems to be just having it declared as a value so it doesn't break when we import at runtime\nexport const inferred = Symbol(\"inferred\");\n","import { compileSerializedValue, flatMorph, printable, throwParseError } from \"@arktype/util\";\nimport { isNode } from \"./utils.js\";\nexport const basisKinds = [\"unit\", \"proto\", \"domain\"];\nexport const structuralKinds = [\n    \"required\",\n    \"optional\",\n    \"index\",\n    \"sequence\"\n];\nexport const refinementKinds = [\n    \"regex\",\n    \"divisor\",\n    \"exactLength\",\n    \"max\",\n    \"min\",\n    \"maxLength\",\n    \"minLength\",\n    \"before\",\n    \"after\"\n];\nexport const constraintKinds = [\n    ...refinementKinds,\n    ...structuralKinds,\n    \"structure\",\n    \"predicate\"\n];\nexport const rootKinds = [\n    \"alias\",\n    \"union\",\n    \"morph\",\n    \"unit\",\n    \"intersection\",\n    \"proto\",\n    \"domain\"\n];\nexport const nodeKinds = [...rootKinds, ...constraintKinds];\nexport const constraintKeys = flatMorph(constraintKinds, (i, kind) => [kind, 1]);\nexport const structureKeys = flatMorph([...structuralKinds, \"undeclared\"], (i, k) => [k, 1]);\nexport const precedenceByKind = flatMorph(nodeKinds, (i, kind) => [kind, i]);\nexport const isNodeKind = (value) => typeof value === \"string\" && value in precedenceByKind;\nexport function assertNodeKind(value, kind) {\n    const valueIsNode = isNode(value);\n    if (!valueIsNode || value.kind !== kind) {\n        throwParseError(`Expected node of kind ${kind} (was ${valueIsNode ? `${value.kind} node` : printable(value)})`);\n    }\n}\nexport const precedenceOfKind = (kind) => precedenceByKind[kind];\nexport const schemaKindsRightOf = (kind) => rootKinds.slice(precedenceOfKind(kind) + 1);\nexport const defaultValueSerializer = (v) => {\n    if (typeof v === \"string\" ||\n        typeof v === \"boolean\" ||\n        typeof v === \"number\" ||\n        v === null)\n        return v;\n    return compileSerializedValue(v);\n};\nexport const compileErrorContext = (ctx) => {\n    let result = \"{ \";\n    for (const [k, v] of Object.entries(ctx))\n        result += `${k}: ${compileSerializedValue(v)}, `;\n    return result + \" }\";\n};\nexport const implementNode = (_) => {\n    const implementation = _;\n    if (implementation.hasAssociatedError) {\n        implementation.defaults.expected ??= ctx => \"description\" in ctx ?\n            ctx.description\n            : implementation.defaults.description(ctx);\n        implementation.defaults.actual ??= data => printable(data);\n        implementation.defaults.problem ??= ctx => `must be ${ctx.expected}${ctx.actual ? ` (was ${ctx.actual})` : \"\"}`;\n        implementation.defaults.message ??= ctx => {\n            if (ctx.path.length === 0)\n                return ctx.problem;\n            const problemWithLocation = `${ctx.propString} ${ctx.problem}`;\n            if (problemWithLocation[0] === \"[\") {\n                // clarify paths like [1], [0][1], and [\"key!\"] that could be confusing\n                return `value at ${problemWithLocation}`;\n            }\n            return problemWithLocation;\n        };\n    }\n    return implementation;\n};\n","import { isNodeKind } from \"./shared/implement.js\";\nexport const globalConfig = {};\nexport const mergeConfigs = (base, extensions) => {\n    const result = { ...base };\n    let k;\n    for (k in extensions) {\n        result[k] =\n            isNodeKind(k) ?\n                {\n                    ...base[k],\n                    ...extensions[k]\n                }\n                : extensions[k];\n    }\n    return result;\n};\nexport const configure = (config) => Object.assign(globalConfig, mergeConfigs(globalConfig, config));\n","import { CastableBase, ReadonlyArray, defineProperties } from \"@arktype/util\";\nimport { arkKind, pathToPropString } from \"./utils.js\";\nexport class ArkError extends CastableBase {\n    input;\n    [arkKind] = \"error\";\n    path;\n    data;\n    nodeConfig;\n    constructor(input, ctx) {\n        super();\n        this.input = input;\n        defineProperties(this, input);\n        const data = ctx.data;\n        if (input.code === \"union\") {\n            // flatten union errors to avoid repeating context like \"foo must be foo must be\"...\n            input.errors = input.errors.flatMap(e => e.hasCode(\"union\") ? e.errors : e);\n        }\n        this.nodeConfig = ctx.config[this.code];\n        this.path = input.path ?? [...ctx.path];\n        if (input.relativePath)\n            this.path.push(...input.relativePath);\n        this.data = \"data\" in input ? input.data : data;\n    }\n    hasCode(code) {\n        return this.code === code;\n    }\n    get propString() {\n        return pathToPropString(this.path);\n    }\n    get expected() {\n        return (this.input.expected ?? this.nodeConfig.expected?.(this.input));\n    }\n    get actual() {\n        // null is a valid value of actual meaning it should be omitted, so\n        // check for undefined explicitly\n        return this.input.actual !== undefined ?\n            this.input.actual\n            : this.nodeConfig.actual?.(this.data);\n    }\n    get problem() {\n        return this.input.problem ?? this.nodeConfig.problem(this);\n    }\n    get message() {\n        return this.input.message ?? this.nodeConfig.message(this);\n    }\n    toString() {\n        return this.message;\n    }\n    throw() {\n        throw this;\n    }\n}\nexport class ArkErrors extends ReadonlyArray {\n    ctx;\n    constructor(ctx) {\n        super();\n        this.ctx = ctx;\n    }\n    byPath = {};\n    count = 0;\n    mutable = this;\n    add(error) {\n        const existing = this.byPath[error.propString];\n        if (existing) {\n            const errorIntersection = new ArkError({\n                code: \"intersection\",\n                errors: existing.hasCode(\"intersection\") ?\n                    [...existing.errors, error]\n                    : [existing, error]\n            }, this.ctx);\n            const existingIndex = this.indexOf(existing);\n            // If existing is found (which it always should be unless this was externally mutated),\n            // replace it with the new problem intersection. In case it isn't for whatever reason,\n            // just append the intersection.\n            this.mutable[existingIndex === -1 ? this.length : existingIndex] =\n                errorIntersection;\n            this.byPath[error.propString] = errorIntersection;\n        }\n        else {\n            this.byPath[error.propString] = error;\n            this.mutable.push(error);\n        }\n        this.count++;\n    }\n    get summary() {\n        return this.toString();\n    }\n    get message() {\n        return this.toString();\n    }\n    toString() {\n        return this.join(\"\\n\");\n    }\n    throw() {\n        throw this;\n    }\n}\n","import { ArkError, ArkErrors } from \"./errors.js\";\nexport class TraversalContext {\n    root;\n    config;\n    path = [];\n    queuedMorphs = [];\n    errors = new ArkErrors(this);\n    branches = [];\n    seen = {};\n    constructor(root, config) {\n        this.root = root;\n        this.config = config;\n    }\n    get currentBranch() {\n        return this.branches.at(-1);\n    }\n    queueMorphs(morphs) {\n        const input = {\n            path: [...this.path],\n            morphs\n        };\n        this.currentBranch?.queuedMorphs.push(input) ??\n            this.queuedMorphs.push(input);\n    }\n    finalize() {\n        if (this.hasError())\n            return this.errors;\n        let out = this.root;\n        if (this.queuedMorphs.length) {\n            for (let i = 0; i < this.queuedMorphs.length; i++) {\n                const { path, morphs } = this.queuedMorphs[i];\n                const key = path.at(-1);\n                let parent;\n                if (key !== undefined) {\n                    // find the object on which the key to be morphed exists\n                    parent = out;\n                    for (let pathIndex = 0; pathIndex < path.length - 1; pathIndex++)\n                        parent = parent[path[pathIndex]];\n                }\n                this.path = path;\n                for (const morph of morphs) {\n                    const result = morph(parent === undefined ? out : parent[key], this);\n                    if (result instanceof ArkErrors)\n                        return result;\n                    if (this.hasError())\n                        return this.errors;\n                    if (result instanceof ArkError) {\n                        // if an ArkError was returned but wasn't added to these\n                        // errors, add it then return\n                        this.error(result);\n                        return this.errors;\n                    }\n                    // apply the morph function and assign the result to the\n                    // corresponding property, or to root if path is empty\n                    if (parent === undefined)\n                        out = result;\n                    else\n                        parent[key] = result;\n                }\n            }\n        }\n        return out;\n    }\n    get currentErrorCount() {\n        return (this.currentBranch ?\n            this.currentBranch.error ?\n                1\n                : 0\n            : this.errors.count);\n    }\n    hasError() {\n        return this.currentErrorCount !== 0;\n    }\n    get failFast() {\n        return this.branches.length !== 0;\n    }\n    error(input) {\n        const errCtx = typeof input === \"object\" ?\n            input.code ?\n                input\n                : { ...input, code: \"predicate\" }\n            : { code: \"predicate\", expected: input };\n        const error = new ArkError(errCtx, this);\n        if (this.currentBranch)\n            this.currentBranch.error = error;\n        else\n            this.errors.add(error);\n        return error;\n    }\n    get data() {\n        let result = this.root;\n        for (const segment of this.path)\n            result = result?.[segment];\n        return result;\n    }\n    invalid(input) {\n        this.error(input);\n        return false;\n    }\n    pushBranch() {\n        this.branches.push({\n            error: undefined,\n            queuedMorphs: []\n        });\n    }\n    popBranch() {\n        return this.branches.pop();\n    }\n}\n","import { Callable, flatMorph, includes, isArray, isEmptyObject, shallowClone, throwError } from \"@arktype/util\";\nimport { basisKinds, constraintKinds, precedenceOfKind, refinementKinds, rootKinds } from \"./shared/implement.js\";\nimport { TraversalContext } from \"./shared/traversal.js\";\nexport class BaseNode extends Callable {\n    attachments;\n    constructor(attachments) {\n        super(\n        // pipedFromCtx allows us internally to reuse TraversalContext\n        // through pipes and keep track of piped paths. It is not exposed\n        (data, pipedFromCtx) => {\n            if (!this.includesMorph &&\n                !this.allowsRequiresContext &&\n                this.allows(data))\n                return data;\n            if (pipedFromCtx)\n                return this.traverseApply(data, pipedFromCtx);\n            const ctx = new TraversalContext(data, this.$.resolvedConfig);\n            this.traverseApply(data, ctx);\n            return ctx.finalize();\n        }, { attach: attachments });\n        this.attachments = attachments;\n    }\n    qualifiedId = `${this.$.id}${this.id}`;\n    includesMorph = this.kind === \"morph\" ||\n        (this.hasKind(\"optional\") && this.hasDefault()) ||\n        (this.hasKind(\"structure\") && this.undeclared === \"delete\") ||\n        this.children.some(child => child.includesMorph);\n    allowsRequiresContext = \n    // if a predicate accepts exactly one arg, we can safely skip passing context\n    (this.hasKind(\"predicate\") && this.inner.predicate.length !== 1) ||\n        this.kind === \"alias\" ||\n        this.children.some(child => child.allowsRequiresContext);\n    referencesById = this.children.reduce((result, child) => Object.assign(result, child.referencesById), { [this.id]: this });\n    get references() {\n        return Object.values(this.referencesById);\n    }\n    precedence = precedenceOfKind(this.kind);\n    jit = false;\n    allows = (data) => {\n        if (this.allowsRequiresContext) {\n            return this.traverseAllows(data, new TraversalContext(data, this.$.resolvedConfig));\n        }\n        return this.traverseAllows(data);\n    };\n    traverse(data) {\n        return this(data);\n    }\n    // unfortunately we can't use the @cached\n    // decorator from @arktype/util on these for now\n    // as they cause a deopt in V8\n    _in;\n    get in() {\n        this._in ??= this.getIo(\"in\");\n        return this._in;\n    }\n    _out;\n    get out() {\n        this._out ??= this.getIo(\"out\");\n        return this._out;\n    }\n    _description;\n    get description() {\n        this._description ??=\n            this.inner.description ??\n                this.$.resolvedConfig[this.kind].description?.(this);\n        return this._description;\n    }\n    getIo(kind) {\n        if (!this.includesMorph)\n            return this;\n        const ioInner = {};\n        for (const [k, v] of this.entries) {\n            const keySchemaImplementation = this.impl.keys[k];\n            if (keySchemaImplementation.meta)\n                continue;\n            if (keySchemaImplementation.child) {\n                const childValue = v;\n                ioInner[k] =\n                    isArray(childValue) ?\n                        childValue.map(child => child[kind])\n                        : childValue[kind];\n            }\n            else\n                ioInner[k] = v;\n        }\n        return this.$.node(this.kind, ioInner);\n    }\n    toJSON() {\n        return this.json;\n    }\n    toString() {\n        return this.expression;\n    }\n    equals(other) {\n        return this.typeHash === other.typeHash;\n    }\n    hasKind(kind) {\n        return this.kind === kind;\n    }\n    isBasis() {\n        return includes(basisKinds, this.kind);\n    }\n    isConstraint() {\n        return includes(constraintKinds, this.kind);\n    }\n    isRefinement() {\n        return includes(refinementKinds, this.kind);\n    }\n    isRoot() {\n        return includes(rootKinds, this.kind);\n    }\n    hasUnit(value) {\n        return this.hasKind(\"unit\") && this.allows(value);\n    }\n    hasOpenIntersection() {\n        return this.impl.intersectionIsOpen;\n    }\n    get nestableExpression() {\n        return this.expression;\n    }\n    bindScope($) {\n        if (this.$ === $)\n            return this;\n        return new this.constructor(Object.assign(shallowClone(this.attachments), { $ }));\n    }\n    firstReference(filter) {\n        return this.references.find(n => n !== this && filter(n));\n    }\n    firstReferenceOrThrow(filter) {\n        return (this.firstReference(filter) ??\n            throwError(`${this.id} had no references matching predicate ${filter}`));\n    }\n    firstReferenceOfKind(kind) {\n        return this.firstReference((node) => node.kind === kind);\n    }\n    firstReferenceOfKindOrThrow(kind) {\n        return (this.firstReference(node => node.kind === kind) ??\n            throwError(`${this.id} had no ${kind} references`));\n    }\n    transform(mapper, opts) {\n        return this._transform(mapper, {\n            seen: {},\n            path: [],\n            shouldTransform: opts?.shouldTransform ?? (() => true)\n        });\n    }\n    _transform(mapper, ctx) {\n        if (ctx.seen[this.id])\n            // TODO: remove cast by making lazilyResolve more flexible\n            // TODO: if each transform has a unique base id, could ensure\n            // these don't create duplicates\n            return this.$.lazilyResolve(ctx.seen[this.id]);\n        if (!ctx.shouldTransform(this, ctx))\n            return this;\n        let transformedNode;\n        ctx.seen[this.id] = () => transformedNode;\n        const innerWithTransformedChildren = flatMorph(this.inner, (k, v) => {\n            if (!this.impl.keys[k].child)\n                return [k, v];\n            const children = v;\n            if (!isArray(children)) {\n                const transformed = children._transform(mapper, ctx);\n                return transformed ? [k, transformed] : [];\n            }\n            const transformed = children.flatMap(n => {\n                const transformedChild = n._transform(mapper, ctx);\n                return transformedChild ?? [];\n            });\n            return transformed.length ? [k, transformed] : [];\n        });\n        delete ctx.seen[this.id];\n        const transformedInner = mapper(this.kind, innerWithTransformedChildren, ctx);\n        if (transformedInner === null)\n            return null;\n        // TODO: more robust checks for pruned inner\n        if (isEmptyObject(transformedInner))\n            return null;\n        if ((this.kind === \"required\" ||\n            this.kind === \"optional\" ||\n            this.kind === \"index\") &&\n            !(\"value\" in transformedInner))\n            return null;\n        if (this.kind === \"morph\") {\n            ;\n            transformedInner.in ??= this.$.keywords\n                .unknown;\n        }\n        return (transformedNode = this.$.node(this.kind, transformedInner));\n    }\n    configureShallowDescendants(configOrDescription) {\n        const config = typeof configOrDescription === \"string\" ?\n            { description: configOrDescription }\n            : configOrDescription;\n        return this.transform((kind, inner) => ({ ...inner, ...config }), {\n            shouldTransform: node => node.kind !== \"structure\"\n        });\n    }\n}\n","export const shallowClone = (input) => Object.create(Object.getPrototypeOf(input), Object.getOwnPropertyDescriptors(input));\nexport const deepClone = (input) => _deepClone(input, new Map());\nconst _deepClone = (input, seen) => {\n    if (typeof input !== \"object\" || input === null)\n        return input;\n    if (seen.has(input))\n        return seen.get(input);\n    const cloned = Array.isArray(input) ?\n        // ensure arrays are copied with their original class attached so they\n        // work with Array.isArray\n        input.slice()\n        : Object.create(Object.getPrototypeOf(input));\n    seen.set(input, cloned);\n    const propertyDescriptors = Object.getOwnPropertyDescriptors(input);\n    for (const key of Object.keys(propertyDescriptors)) {\n        propertyDescriptors[key].value = _deepClone(propertyDescriptors[key].value, seen);\n    }\n    Object.defineProperties(cloned, propertyDescriptors);\n    return cloned;\n};\n","import { entriesOf, flatMorph, fromEntries, isArray, printable, register, throwInternalError, throwParseError } from \"@arktype/util\";\nimport { hasArkKind } from \"./utils.js\";\nexport class Disjoint {\n    sources;\n    constructor(sources) {\n        this.sources = sources;\n    }\n    clone() {\n        return new Disjoint(this.sources);\n    }\n    static from(kind, l, r) {\n        return new Disjoint({\n            \"[]\": {\n                [kind]: {\n                    l,\n                    r\n                }\n            }\n        });\n    }\n    static fromEntries(entries) {\n        if (!entries.length) {\n            return throwInternalError(\"Unexpected attempt to create a disjoint from no entries\");\n        }\n        return new Disjoint({ \"[]\": fromEntries(entries) });\n    }\n    get flat() {\n        return entriesOf(this.sources).flatMap(([path, disjointKinds]) => entriesOf(disjointKinds).map(([kind, disjoint]) => ({\n            path,\n            kind,\n            disjoint\n        })));\n    }\n    describeReasons() {\n        const reasons = this.flat;\n        if (reasons.length === 1) {\n            const { path, disjoint } = reasons[0];\n            const pathString = JSON.parse(path).join(\".\");\n            return `Intersection${pathString && ` at ${pathString}`} of ${describeReasons(disjoint)} results in an unsatisfiable type`;\n        }\n        return `The following intersections result in unsatisfiable types:\\n• ${reasons\n            .map(({ path, disjoint }) => `${path}: ${describeReasons(disjoint)}`)\n            .join(\"\\n• \")}`;\n    }\n    isEmpty() {\n        return this.flat.length === 0;\n    }\n    throw() {\n        return throwParseError(this.describeReasons());\n    }\n    invert() {\n        const invertedEntries = entriesOf(this.sources).map(([path, disjoints]) => [\n            path,\n            flatMorph(disjoints, (kind, disjoint) => [\n                kind,\n                { l: disjoint.r, r: disjoint.l }\n            ])\n        ]);\n        return new Disjoint(fromEntries(invertedEntries));\n    }\n    add(input) {\n        entriesOf(input.sources).forEach(([path, disjoints]) => Object.assign(this.sources[path] ?? {}, disjoints));\n    }\n    withPrefixKey(key) {\n        const entriesWithPrefix = entriesOf(this.sources).map(([path, disjoints]) => {\n            const segments = JSON.parse(path);\n            segments.unshift(typeof key === \"symbol\" ? register(key) : key);\n            const pathWithPrefix = JSON.stringify(segments);\n            return [pathWithPrefix, disjoints];\n        });\n        return new Disjoint(fromEntries(entriesWithPrefix));\n    }\n    toString() {\n        return printable(this.sources);\n    }\n}\nconst describeReasons = (source) => `${describeReason(source.l)} and ${describeReason(source.r)}`;\nconst describeReason = (value) => hasArkKind(value, \"root\") ? value.expression\n    : isArray(value) ? value.map(describeReason).join(\" | \")\n        : String(value);\n","import { Hkt } from \"@arktype/util\";\nimport { Disjoint } from \"./disjoint.js\";\nimport { isNode } from \"./utils.js\";\nconst intersectionCache = {};\nexport const intersectNodesRoot = (l, r, $) => intersectNodes(l, r, { $, invert: false, pipe: false });\nexport const pipeNodesRoot = (l, r, $) => intersectNodes(l, r, { $, invert: false, pipe: true });\nexport const intersectNodes = (l, r, ctx) => {\n    const operator = ctx.pipe ? \"|>\" : \"&\";\n    const lrCacheKey = `${l.typeHash}${operator}${r.typeHash}`;\n    if (intersectionCache[lrCacheKey] !== undefined)\n        return intersectionCache[lrCacheKey];\n    if (!ctx.pipe) {\n        // we can only use this for the commutative & operator\n        const rlCacheKey = `${r.typeHash}${operator}${l.typeHash}`;\n        if (intersectionCache[rlCacheKey] !== undefined) {\n            // if the cached result was a Disjoint and the operands originally\n            // appeared in the opposite order, we need to invert it to match\n            const rlResult = intersectionCache[rlCacheKey];\n            const lrResult = rlResult instanceof Disjoint ? rlResult.invert() : rlResult;\n            // add the lr result to the cache directly to bypass this check in the future\n            intersectionCache[lrCacheKey] = lrResult;\n            return lrResult;\n        }\n    }\n    if (l.equals(r))\n        return l;\n    let result;\n    if (ctx.pipe && l.hasKind(\"morph\")) {\n        result =\n            ctx.invert ?\n                pipeToMorph(r, l, ctx)\n                : pipeFromMorph(l, r, ctx);\n    }\n    else if (ctx.pipe && r.hasKind(\"morph\")) {\n        result =\n            ctx.invert ?\n                pipeFromMorph(r, l, ctx)\n                : pipeToMorph(l, r, ctx);\n    }\n    else {\n        const leftmostKind = l.precedence < r.precedence ? l.kind : r.kind;\n        const implementation = l.impl.intersections[r.kind] ?? r.impl.intersections[l.kind];\n        result =\n            implementation === undefined ?\n                // should be two ConstraintNodes that have no relation\n                // this could also happen if a user directly intersects a Type and a ConstraintNode,\n                // but that is not allowed by the external function signature\n                null\n                : leftmostKind === l.kind ? implementation(l, r, ctx)\n                    : implementation(r, l, { ...ctx, invert: !ctx.invert });\n    }\n    if (isNode(result)) {\n        // if the result equals one of the operands, preserve its metadata by\n        // returning the original reference\n        if (l.equals(result))\n            result = l;\n        else if (r.equals(result))\n            result = r;\n    }\n    intersectionCache[lrCacheKey] = result;\n    return result;\n};\n// TODO: double check pipes through chained morphs\nexport const pipeFromMorph = (from, to, ctx) => {\n    const morphs = [...from.morphs];\n    if (from.validatedOut) {\n        // still piped from context, so allows appending additional morphs\n        const outIntersection = intersectNodes(from.validatedOut, to, ctx);\n        if (outIntersection instanceof Disjoint)\n            return outIntersection;\n        morphs[morphs.length - 1] = outIntersection;\n    }\n    else\n        morphs.push(to);\n    return ctx.$.node(\"morph\", {\n        morphs,\n        in: from.in\n    });\n};\nexport const pipeToMorph = (from, to, ctx) => {\n    const result = intersectNodes(from, to.in, ctx);\n    if (result instanceof Disjoint)\n        return result;\n    return ctx.$.node(\"morph\", {\n        morphs: to.morphs,\n        in: result\n    });\n};\n","import { append, appendUnique, capitalize, isArray, throwInternalError, throwParseError } from \"@arktype/util\";\nimport { BaseNode } from \"./node.js\";\nimport { Disjoint } from \"./shared/disjoint.js\";\nimport { compileErrorContext, constraintKeys } from \"./shared/implement.js\";\nimport { intersectNodes, intersectNodesRoot } from \"./shared/intersections.js\";\nimport { arkKind } from \"./shared/utils.js\";\nexport class BaseConstraint extends BaseNode {\n    [arkKind] = \"constraint\";\n    impliedSiblings;\n    intersect(r) {\n        return intersectNodesRoot(this, r, this.$);\n    }\n}\nexport class RawPrimitiveConstraint extends BaseConstraint {\n    traverseApply = (data, ctx) => {\n        if (!this.traverseAllows(data, ctx))\n            ctx.error(this.errorContext);\n    };\n    compile(js) {\n        if (js.traversalKind === \"Allows\")\n            js.return(this.compiledCondition);\n        else {\n            js.if(this.compiledNegation, () => js.line(`${js.ctx}.error(${this.compiledErrorContext})`));\n        }\n    }\n    get errorContext() {\n        return { code: this.kind, description: this.description, ...this.inner };\n    }\n    get compiledErrorContext() {\n        return compileErrorContext(this.errorContext);\n    }\n}\nexport const constraintKeyParser = (kind) => (schema, ctx) => {\n    if (isArray(schema)) {\n        if (schema.length === 0) {\n            // Omit empty lists as input\n            return;\n        }\n        return schema\n            .map(schema => ctx.$.node(kind, schema))\n            .sort((l, r) => (l.innerHash < r.innerHash ? -1 : 1));\n    }\n    const child = ctx.$.node(kind, schema);\n    return child.hasOpenIntersection() ? [child] : child;\n};\nexport const intersectConstraints = (s) => {\n    const head = s.r.shift();\n    if (!head) {\n        let result = s.l.length === 0 && s.kind === \"structure\" ?\n            s.ctx.$.keywords.unknown.raw\n            : s.ctx.$.node(s.kind, Object.assign(s.baseInner, unflattenConstraints(s.l)), { prereduced: true });\n        for (const root of s.roots) {\n            if (result instanceof Disjoint)\n                return result;\n            result = intersectNodes(root, result, s.ctx);\n        }\n        return result;\n    }\n    let matched = false;\n    for (let i = 0; i < s.l.length; i++) {\n        const result = intersectNodes(s.l[i], head, s.ctx);\n        if (result === null)\n            continue;\n        if (result instanceof Disjoint)\n            return result;\n        if (!matched) {\n            if (result.isRoot()) {\n                s.roots.push(result);\n                s.l.splice(i);\n                return intersectConstraints(s);\n            }\n            s.l[i] = result;\n            matched = true;\n        }\n        else if (!s.l.includes(result)) {\n            return throwInternalError(`Unexpectedly encountered multiple distinct intersection results for refinement ${result}`);\n        }\n    }\n    if (!matched)\n        s.l.push(head);\n    if (s.kind === \"intersection\")\n        head.impliedSiblings?.forEach(node => appendUnique(s.r, node));\n    return intersectConstraints(s);\n};\nexport const flattenConstraints = (inner) => {\n    const result = Object.entries(inner)\n        .flatMap(([k, v]) => k in constraintKeys ? v : [])\n        .sort((l, r) => l.precedence < r.precedence ? -1\n        : l.precedence > r.precedence ? 1\n            : l.innerHash < r.innerHash ? -1\n                : 1);\n    return result;\n};\n// TODO: Fix type\nexport const unflattenConstraints = (constraints) => {\n    const inner = {};\n    for (const constraint of constraints) {\n        if (constraint.hasOpenIntersection()) {\n            inner[constraint.kind] = append(inner[constraint.kind], constraint);\n        }\n        else {\n            if (inner[constraint.kind]) {\n                return throwInternalError(`Unexpected intersection of closed refinements of kind ${constraint.kind}`);\n            }\n            inner[constraint.kind] = constraint;\n        }\n    }\n    return inner;\n};\nexport const throwInvalidOperandError = (...args) => throwParseError(writeInvalidOperandMessage(...args));\nexport const writeInvalidOperandMessage = (kind, expected, actual) => `${capitalize(kind)} operand must be ${expected.description} (was ${actual.exclude(expected).description})`;\n","import { registeredReference } from \"@arktype/util\";\nimport { BaseConstraint } from \"./constraint.js\";\nimport { implementNode } from \"./shared/implement.js\";\nexport const predicateImplementation = implementNode({\n    kind: \"predicate\",\n    hasAssociatedError: true,\n    collapsibleKey: \"predicate\",\n    keys: {\n        predicate: {}\n    },\n    normalize: schema => typeof schema === \"function\" ? { predicate: schema } : schema,\n    defaults: {\n        description: node => `valid according to ${node.predicate.name || \"an anonymous predicate\"}`\n    },\n    intersectionIsOpen: true,\n    intersections: {\n        // TODO: allow changed order to be the same type\n        // as long as the narrows in l and r are individually safe to check\n        // in the order they're specified, checking them in the order\n        // resulting from this intersection should also be safe.\n        predicate: () => null\n    }\n});\nexport class PredicateNode extends BaseConstraint {\n    serializedPredicate = registeredReference(this.predicate);\n    compiledCondition = `${this.serializedPredicate}(data, ctx)`;\n    compiledNegation = `!${this.compiledCondition}`;\n    impliedBasis = null;\n    expression = this.serializedPredicate;\n    traverseAllows = this.predicate;\n    errorContext = {\n        code: \"predicate\",\n        description: this.description\n    };\n    compiledErrorContext = `{ code: \"predicate\", description: \"${this.description}\" }`;\n    traverseApply = (data, ctx) => {\n        if (!this.predicate(data, ctx) && !ctx.hasError())\n            ctx.error(this.errorContext);\n    };\n    compile(js) {\n        if (js.traversalKind === \"Allows\") {\n            js.return(this.compiledCondition);\n            return;\n        }\n        js.if(`${this.compiledNegation} && !ctx.hasError()`, () => js.line(`ctx.error(${this.compiledErrorContext})`));\n    }\n}\n","import { RawPrimitiveConstraint, writeInvalidOperandMessage } from \"../constraint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nexport const divisorImplementation = implementNode({\n    kind: \"divisor\",\n    collapsibleKey: \"rule\",\n    keys: {\n        rule: {}\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    hasAssociatedError: true,\n    defaults: {\n        description: node => node.rule === 1 ? \"an integer\" : `a multiple of ${node.rule}`\n    },\n    intersections: {\n        divisor: (l, r, ctx) => ctx.$.node(\"divisor\", {\n            rule: Math.abs((l.rule * r.rule) / greatestCommonDivisor(l.rule, r.rule))\n        })\n    }\n});\nexport class DivisorNode extends RawPrimitiveConstraint {\n    traverseAllows = data => data % this.rule === 0;\n    compiledCondition = `data % ${this.rule} === 0`;\n    compiledNegation = `data % ${this.rule} !== 0`;\n    impliedBasis = this.$.keywords.number.raw;\n    expression = `% ${this.rule}`;\n}\nexport const writeIndivisibleMessage = (t) => writeInvalidOperandMessage(\"divisor\", t.$.raw.keywords.number, t);\n// https://en.wikipedia.org/wiki/Euclidean_algorithm\nconst greatestCommonDivisor = (l, r) => {\n    let previous;\n    let greatestCommonDivisor = l;\n    let current = r;\n    while (current !== 0) {\n        previous = current;\n        current = greatestCommonDivisor % current;\n        greatestCommonDivisor = previous;\n    }\n    return greatestCommonDivisor;\n};\n","import { isKeyOf } from \"@arktype/util\";\nimport { RawPrimitiveConstraint } from \"../constraint.js\";\nexport class BaseRange extends RawPrimitiveConstraint {\n    boundOperandKind = operandKindsByBoundKind[this.kind];\n    compiledActual = this.boundOperandKind === \"value\" ? `data`\n        : this.boundOperandKind === \"length\" ? `data.length`\n            : `data.valueOf()`;\n    comparator = compileComparator(this.kind, this.exclusive);\n    numericLimit = this.rule.valueOf();\n    expression = `${this.comparator}${this.rule}`;\n    compiledCondition = `${this.compiledActual} ${this.comparator} ${this.numericLimit}`;\n    compiledNegation = `${this.compiledActual} ${negatedComparators[this.comparator]} ${this.numericLimit}`;\n    // we need to compute stringLimit before errorContext, which references it\n    // transitively through description for date bounds\n    stringLimit = this.boundOperandKind === \"date\" ?\n        dateLimitToString(this.numericLimit)\n        : `${this.numericLimit}`;\n    limitKind = this.comparator[\"0\"] === \"<\" ? \"upper\" : \"lower\";\n    isStricterThan(r) {\n        const thisLimitIsStricter = this.limitKind === \"upper\" ?\n            this.numericLimit < r.numericLimit\n            : this.numericLimit > r.numericLimit;\n        return (thisLimitIsStricter ||\n            (this.numericLimit === r.numericLimit &&\n                this.exclusive === true &&\n                !r.exclusive));\n    }\n    overlapsRange(r) {\n        if (this.isStricterThan(r))\n            return false;\n        if (this.numericLimit === r.numericLimit && (this.exclusive || r.exclusive))\n            return false;\n        return true;\n    }\n    overlapIsUnit(r) {\n        return (this.numericLimit === r.numericLimit && !this.exclusive && !r.exclusive);\n    }\n}\nconst negatedComparators = {\n    \"<\": \">=\",\n    \"<=\": \">\",\n    \">\": \"<=\",\n    \">=\": \"<\"\n};\nexport const boundKindPairsByLower = {\n    min: \"max\",\n    minLength: \"maxLength\",\n    after: \"before\"\n};\nexport const parseExclusiveKey = {\n    // omit key with value false since it is the default\n    parse: (flag) => flag || undefined\n};\nexport const parseDateLimit = (limit) => typeof limit === \"string\" || typeof limit === \"number\" ?\n    new Date(limit)\n    : limit;\nconst operandKindsByBoundKind = {\n    min: \"value\",\n    max: \"value\",\n    minLength: \"length\",\n    maxLength: \"length\",\n    after: \"date\",\n    before: \"date\"\n};\nexport const compileComparator = (kind, exclusive) => `${isKeyOf(kind, boundKindPairsByLower) ? \">\" : \"<\"}${exclusive ? \"\" : \"=\"}`;\nexport const dateLimitToString = (limit) => typeof limit === \"string\" ? limit : new Date(limit).toLocaleString();\nexport const writeUnboundableMessage = (root) => `Bounded expression ${root} must be a number, string, Array, or Date`;\n","import { implementNode } from \"../shared/implement.js\";\nimport { BaseRange, parseDateLimit, parseExclusiveKey } from \"./range.js\";\nexport const afterImplementation = implementNode({\n    kind: \"after\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {\n            parse: parseDateLimit,\n            serialize: schema => schema.toISOString()\n        },\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => (typeof schema === \"number\" ||\n        typeof schema === \"string\" ||\n        schema instanceof Date) ?\n        { rule: schema }\n        : schema,\n    defaults: {\n        description: node => node.exclusive ?\n            `after ${node.stringLimit}`\n            : `${node.stringLimit} or later`,\n        actual: data => data.toLocaleString()\n    },\n    intersections: {\n        after: (l, r) => (l.isStricterThan(r) ? l : r)\n    }\n});\nexport class AfterNode extends BaseRange {\n    impliedBasis = this.$.keywords.Date.raw;\n    traverseAllows = this.exclusive ? data => data > this.rule : data => data >= this.rule;\n}\n","import { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { BaseRange, parseDateLimit, parseExclusiveKey } from \"./range.js\";\nexport const beforeImplementation = implementNode({\n    kind: \"before\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {\n            parse: parseDateLimit,\n            serialize: schema => schema.toISOString()\n        },\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => (typeof schema === \"number\" ||\n        typeof schema === \"string\" ||\n        schema instanceof Date) ?\n        { rule: schema }\n        : schema,\n    defaults: {\n        description: node => node.exclusive ?\n            `before ${node.stringLimit}`\n            : `${node.stringLimit} or earlier`,\n        actual: data => data.toLocaleString()\n    },\n    intersections: {\n        before: (l, r) => (l.isStricterThan(r) ? l : r),\n        after: (before, after, ctx) => before.overlapsRange(after) ?\n            before.overlapIsUnit(after) ?\n                ctx.$.node(\"unit\", { unit: before.rule })\n                : null\n            : Disjoint.from(\"range\", before, after)\n    }\n});\nexport class BeforeNode extends BaseRange {\n    traverseAllows = this.exclusive ? data => data < this.rule : data => data <= this.rule;\n    impliedBasis = this.$.keywords.Date.raw;\n}\n","import { RawPrimitiveConstraint } from \"../constraint.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nexport const exactLengthImplementation = implementNode({\n    kind: \"exactLength\",\n    collapsibleKey: \"rule\",\n    keys: {\n        rule: {}\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    hasAssociatedError: true,\n    defaults: {\n        description: node => `exactly length ${node.rule}`\n    },\n    intersections: {\n        exactLength: (l, r, ctx) => new Disjoint({\n            '[\"length\"]': {\n                unit: {\n                    l: ctx.$.node(\"unit\", { unit: l.rule }),\n                    r: ctx.$.node(\"unit\", { unit: r.rule })\n                }\n            }\n        }),\n        minLength: (exactLength, minLength) => (minLength.exclusive ?\n            exactLength.rule > minLength.rule\n            : exactLength.rule >= minLength.rule) ?\n            exactLength\n            : Disjoint.from(\"range\", exactLength, minLength),\n        maxLength: (exactLength, maxLength) => (maxLength.exclusive ?\n            exactLength.rule < maxLength.rule\n            : exactLength.rule <= maxLength.rule) ?\n            exactLength\n            : Disjoint.from(\"range\", exactLength, maxLength)\n    }\n});\nexport class ExactLengthNode extends RawPrimitiveConstraint {\n    traverseAllows = data => data.length === this.rule;\n    compiledCondition = `data.length === ${this.rule}`;\n    compiledNegation = `data.length !== ${this.rule}`;\n    impliedBasis = this.$.keywords.lengthBoundable.raw;\n    expression = `{ length: ${this.rule} }`;\n}\n","import { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { BaseRange, parseExclusiveKey } from \"./range.js\";\nexport const maxImplementation = implementNode({\n    kind: \"max\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {},\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    defaults: {\n        description: node => `${node.exclusive ? \"less than\" : \"at most\"} ${node.rule}`\n    },\n    intersections: {\n        max: (l, r) => (l.isStricterThan(r) ? l : r),\n        min: (max, min, ctx) => max.overlapsRange(min) ?\n            max.overlapIsUnit(min) ?\n                ctx.$.node(\"unit\", { unit: max.rule })\n                : null\n            : Disjoint.from(\"range\", max, min)\n    }\n});\nexport class MaxNode extends BaseRange {\n    impliedBasis = this.$.keywords.number.raw;\n    traverseAllows = this.exclusive ? data => data < this.rule : data => data <= this.rule;\n}\n","import { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { BaseRange, parseExclusiveKey } from \"./range.js\";\nexport const maxLengthImplementation = implementNode({\n    kind: \"maxLength\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {},\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    defaults: {\n        description: node => node.exclusive ?\n            `less than length ${node.rule}`\n            : `at most length ${node.rule}`,\n        actual: data => `${data.length}`\n    },\n    intersections: {\n        maxLength: (l, r) => (l.isStricterThan(r) ? l : r),\n        minLength: (max, min, ctx) => max.overlapsRange(min) ?\n            max.overlapIsUnit(min) ?\n                ctx.$.node(\"exactLength\", { rule: max.rule })\n                : null\n            : Disjoint.from(\"range\", max, min)\n    }\n});\nexport class MaxLengthNode extends BaseRange {\n    impliedBasis = this.$.keywords.lengthBoundable.raw;\n    traverseAllows = this.exclusive ?\n        data => data.length < this.rule\n        : data => data.length <= this.rule;\n}\n","import { AfterNode, afterImplementation } from \"./after.js\";\nimport { BeforeNode, beforeImplementation } from \"./before.js\";\nimport { ExactLengthNode, exactLengthImplementation } from \"./exactLength.js\";\nimport { MaxNode, maxImplementation } from \"./max.js\";\nimport { MaxLengthNode, maxLengthImplementation } from \"./maxLength.js\";\nimport { MinNode, minImplementation } from \"./min.js\";\nimport { MinLengthNode, minLengthImplementation } from \"./minLength.js\";\nexport const boundImplementationsByKind = {\n    min: minImplementation,\n    max: maxImplementation,\n    minLength: minLengthImplementation,\n    maxLength: maxLengthImplementation,\n    exactLength: exactLengthImplementation,\n    after: afterImplementation,\n    before: beforeImplementation\n};\nexport const boundClassesByKind = {\n    min: MinNode,\n    max: MaxNode,\n    minLength: MinLengthNode,\n    maxLength: MaxLengthNode,\n    exactLength: ExactLengthNode,\n    after: AfterNode,\n    before: BeforeNode\n};\n","import { implementNode } from \"../shared/implement.js\";\nimport { BaseRange, parseExclusiveKey } from \"./range.js\";\nexport const minImplementation = implementNode({\n    kind: \"min\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {},\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    defaults: {\n        description: node => `${node.exclusive ? \"more than\" : \"at least\"} ${node.rule}`\n    },\n    intersections: {\n        min: (l, r) => (l.isStricterThan(r) ? l : r)\n    }\n});\nexport class MinNode extends BaseRange {\n    impliedBasis = this.$.keywords.number.raw;\n    traverseAllows = this.exclusive ? data => data > this.rule : data => data >= this.rule;\n}\n","import { implementNode } from \"../shared/implement.js\";\nimport { BaseRange, parseExclusiveKey } from \"./range.js\";\nexport const minLengthImplementation = implementNode({\n    kind: \"minLength\",\n    collapsibleKey: \"rule\",\n    hasAssociatedError: true,\n    keys: {\n        rule: {},\n        exclusive: parseExclusiveKey\n    },\n    normalize: schema => typeof schema === \"number\" ? { rule: schema } : schema,\n    defaults: {\n        description: node => node.exclusive ?\n            node.rule === 0 ?\n                \"non-empty\"\n                : `more than length ${node.rule}`\n            : node.rule === 1 ? \"non-empty\"\n                : `at least length ${node.rule}`,\n        actual: data => `${data.length}`\n    },\n    intersections: {\n        minLength: (l, r) => (l.isStricterThan(r) ? l : r)\n    }\n});\nexport class MinLengthNode extends BaseRange {\n    impliedBasis = this.$.keywords.lengthBoundable.raw;\n    traverseAllows = this.exclusive ?\n        data => data.length > this.rule\n        : data => data.length >= this.rule;\n}\n","import { RawPrimitiveConstraint } from \"../constraint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nexport const regexImplementation = implementNode({\n    kind: \"regex\",\n    collapsibleKey: \"rule\",\n    keys: {\n        rule: {},\n        flags: {}\n    },\n    normalize: schema => typeof schema === \"string\" ? { rule: schema }\n        : schema instanceof RegExp ?\n            schema.flags ?\n                { rule: schema.source, flags: schema.flags }\n                : { rule: schema.source }\n            : schema,\n    hasAssociatedError: true,\n    intersectionIsOpen: true,\n    defaults: {\n        description: node => `matched by ${node.rule}`\n    },\n    intersections: {\n        // for now, non-equal regex are naively intersected:\n        // https://github.com/arktypeio/arktype/issues/853\n        regex: () => null\n    }\n});\nexport class RegexNode extends RawPrimitiveConstraint {\n    instance = new RegExp(this.rule, this.flags);\n    expression = `${this.instance}`;\n    traverseAllows = this.instance.test.bind(this.instance);\n    compiledCondition = `${this.expression}.test(data)`;\n    compiledNegation = `!${this.compiledCondition}`;\n    impliedBasis = this.$.keywords.string.raw;\n}\n","import { includes, omit, throwParseError } from \"@arktype/util\";\nimport { throwInvalidOperandError } from \"../constraint.js\";\nimport { BaseNode } from \"../node.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { ArkErrors } from \"../shared/errors.js\";\nimport { structuralKinds } from \"../shared/implement.js\";\nimport { intersectNodesRoot, pipeNodesRoot } from \"../shared/intersections.js\";\nimport { arkKind, hasArkKind } from \"../shared/utils.js\";\nexport class BaseRoot extends BaseNode {\n    branches = this.hasKind(\"union\") ? this.inner.branches : [this];\n    [arkKind] = \"root\";\n    get raw() {\n        return this;\n    }\n    _keyof;\n    keyof() {\n        if (!this._keyof) {\n            this._keyof = this.rawKeyOf();\n            if (this._keyof.branches.length === 0) {\n                throwParseError(`keyof ${this.expression} results in an unsatisfiable type`);\n            }\n        }\n        return this._keyof;\n    }\n    intersect(r) {\n        const rNode = this.$.parseRoot(r);\n        return intersectNodesRoot(this, rNode, this.$);\n    }\n    and(r) {\n        const result = this.intersect(r);\n        return result instanceof Disjoint ? result.throw() : result;\n    }\n    or(r) {\n        const rNode = this.$.parseRoot(r);\n        const branches = [...this.branches, ...rNode.branches];\n        return this.$.schema(branches);\n    }\n    assert(data) {\n        const result = this.traverse(data);\n        return result instanceof ArkErrors ? result.throw() : result;\n    }\n    // get<key extends PropertyKey>(\n    // \t...path: readonly (key | Root<key>)[]\n    // ): this {\n    // \treturn this\n    // }\n    extract(r) {\n        const rNode = this.$.parseRoot(r);\n        return this.$.schema(this.branches.filter(branch => branch.extends(rNode)));\n    }\n    exclude(r) {\n        const rNode = this.$.parseRoot(r);\n        return this.$.schema(this.branches.filter(branch => !branch.extends(rNode)));\n    }\n    array() {\n        return this.$.schema({\n            proto: Array,\n            sequence: this\n        }, { prereduced: true });\n    }\n    extends(r) {\n        const intersection = this.intersect(r);\n        return (!(intersection instanceof Disjoint) && this.equals(intersection));\n    }\n    subsumes(r) {\n        return r.extends(this);\n    }\n    configure(configOrDescription) {\n        return this.configureShallowDescendants(configOrDescription);\n    }\n    describe(description) {\n        return this.configure(description);\n    }\n    create(input) {\n        // ideally we wouldn't validate here but for now we need to do determine\n        // which morphs to apply\n        return this.assert(input);\n    }\n    pipe(...morphs) {\n        return morphs.reduce((acc, morph) => acc.pipeOnce(morph), this);\n    }\n    pipeOnce(morph) {\n        if (hasArkKind(morph, \"root\"))\n            return pipeNodesRoot(this, morph, this.$);\n        if (this.hasKind(\"union\")) {\n            const branches = this.branches.map(node => node.pipe(morph));\n            return this.$.node(\"union\", { ...this.inner, branches });\n        }\n        if (this.hasKind(\"morph\")) {\n            return this.$.node(\"morph\", {\n                ...this.inner,\n                morphs: [...this.morphs, morph]\n            });\n        }\n        return this.$.node(\"morph\", {\n            in: this,\n            morphs: [morph]\n        });\n    }\n    narrow(predicate) {\n        return this.constrain(\"predicate\", predicate);\n    }\n    constrain(kind, schema) {\n        const constraint = this.$.node(kind, schema);\n        if (constraint.impliedBasis && !this.extends(constraint.impliedBasis)) {\n            return throwInvalidOperandError(kind, constraint.impliedBasis, this);\n        }\n        return this.and(\n        // TODO: not an intersection\n        this.$.node(\"intersection\", {\n            [kind]: constraint\n        }));\n    }\n    onUndeclaredKey(undeclared) {\n        return this.transform((kind, inner) => kind === \"structure\" ?\n            undeclared === \"ignore\" ?\n                omit(inner, { undeclared: 1 })\n                : { ...inner, undeclared }\n            : inner, { shouldTransform: node => !includes(structuralKinds, node.kind) });\n    }\n}\n","export const capitalize = (s) => (s[0].toUpperCase() + s.slice(1));\n","import { flatMorph } from \"@arktype/util\";\nimport { schemaKindsRightOf } from \"../shared/implement.js\";\nexport const defineRightwardIntersections = (kind, implementation) => flatMorph(schemaKindsRightOf(kind), (i, kind) => [\n    kind,\n    implementation\n]);\n","var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for (var i = 0; i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n};\nvar __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        }\n        else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n};\nimport { append, cached } from \"@arktype/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectNodes } from \"../shared/intersections.js\";\nimport { BaseRoot } from \"./root.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nlet AliasNode = (() => {\n    let _classSuper = BaseRoot;\n    let _instanceExtraInitializers = [];\n    let _get_resolution_decorators;\n    return class AliasNode extends _classSuper {\n        static {\n            const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n            _get_resolution_decorators = [cached];\n            __esDecorate(this, null, _get_resolution_decorators, { kind: \"getter\", name: \"resolution\", static: false, private: false, access: { has: obj => \"resolution\" in obj, get: obj => obj.resolution }, metadata: _metadata }, null, _instanceExtraInitializers);\n            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });\n        }\n        expression = (__runInitializers(this, _instanceExtraInitializers), this.alias);\n        get resolution() {\n            return this.resolve?.() ?? this.$.resolveRoot(this.alias);\n        }\n        rawKeyOf() {\n            return this.resolution.keyof();\n        }\n        traverseAllows = (data, ctx) => {\n            const seen = ctx.seen[this.id];\n            if (seen?.includes(data))\n                return true;\n            ctx.seen[this.id] = append(seen, data);\n            return this.resolution.traverseAllows(data, ctx);\n        };\n        traverseApply = (data, ctx) => {\n            const seen = ctx.seen[this.id];\n            if (seen?.includes(data))\n                return;\n            ctx.seen[this.id] = append(seen, data);\n            this.resolution.traverseApply(data, ctx);\n        };\n        compile(js) {\n            js.if(`ctx.seen.${this.id}?.includes(data)`, () => js.return(true));\n            js.line(`ctx.seen.${this.id} ??= []`).line(`ctx.seen.${this.id}.push(data)`);\n            js.return(js.invoke(this.resolution));\n        }\n    };\n})();\nexport { AliasNode };\nexport const normalizeAliasSchema = (schema) => typeof schema === \"string\" ? { alias: schema.slice(1) } : schema;\nexport const aliasImplementation = implementNode({\n    kind: \"alias\",\n    hasAssociatedError: false,\n    collapsibleKey: \"alias\",\n    keys: {\n        alias: {\n            serialize: schema => `$${schema}`\n        },\n        resolve: {}\n    },\n    normalize: normalizeAliasSchema,\n    defaults: {\n        description: node => node.alias\n    },\n    intersections: {\n        alias: (l, r, ctx) => ctx.$.lazilyResolve(() => neverIfDisjoint(intersectNodes(l.resolution, r.resolution, ctx), ctx.$), `${l.alias}${ctx.pipe ? \"|>\" : \"&\"}${r.alias}`),\n        ...defineRightwardIntersections(\"alias\", (l, r, ctx) => ctx.$.lazilyResolve(() => neverIfDisjoint(intersectNodes(l.resolution, r, ctx), ctx.$), `${l.alias}${ctx.pipe ? \"|>\" : \"&\"}${r.alias}`))\n    }\n});\nconst neverIfDisjoint = (result, $) => (result instanceof Disjoint ? $.keywords.never.raw : result);\n","import { compileErrorContext } from \"../shared/implement.js\";\nimport { BaseRoot } from \"./root.js\";\nexport class RawBasis extends BaseRoot {\n    rawKeyOf() {\n        return this.$.units(this.literalKeys);\n    }\n    traverseApply = (data, ctx) => {\n        if (!this.traverseAllows(data, ctx))\n            ctx.error(this.errorContext);\n    };\n    get errorContext() {\n        return { code: this.kind, description: this.description, ...this.inner };\n    }\n    get compiledErrorContext() {\n        return compileErrorContext(this.errorContext);\n    }\n    compile(js) {\n        if (js.traversalKind === \"Allows\")\n            js.return(this.compiledCondition);\n        else {\n            js.if(this.compiledNegation, () => js.line(`${js.ctx}.error(${this.compiledErrorContext})`));\n        }\n    }\n}\n","import { domainDescriptions, domainOf, getBaseDomainKeys } from \"@arktype/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { RawBasis } from \"./basis.js\";\nexport class DomainNode extends RawBasis {\n    traverseAllows = data => domainOf(data) === this.domain;\n    compiledCondition = this.domain === \"object\" ?\n        `((typeof data === \"object\" && data !== null) || typeof data === \"function\")`\n        : `typeof data === \"${this.domain}\"`;\n    compiledNegation = this.domain === \"object\" ?\n        `((typeof data !== \"object\" || data === null) && typeof data !== \"function\")`\n        : `typeof data !== \"${this.domain}\"`;\n    expression = this.domain;\n    literalKeys = getBaseDomainKeys(this.domain);\n}\nexport const domainImplementation = implementNode({\n    kind: \"domain\",\n    hasAssociatedError: true,\n    collapsibleKey: \"domain\",\n    keys: {\n        domain: {}\n    },\n    normalize: schema => typeof schema === \"string\" ? { domain: schema } : schema,\n    defaults: {\n        description: node => domainDescriptions[node.domain],\n        actual: data => (typeof data === \"boolean\" ? `${data}` : domainOf(data))\n    },\n    intersections: {\n        domain: (l, r) => Disjoint.from(\"domain\", l, r)\n    }\n});\n","export const metaKeys = { description: 1 };\n","import { flatMorph, hasDomain, isEmptyObject, isKeyOf, omit, pick, throwParseError } from \"@arktype/util\";\nimport { constraintKeyParser, flattenConstraints, intersectConstraints } from \"../constraint.js\";\nimport { metaKeys } from \"../shared/declare.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode, structureKeys } from \"../shared/implement.js\";\nimport { intersectNodes } from \"../shared/intersections.js\";\nimport { hasArkKind, isNode } from \"../shared/utils.js\";\nimport { BaseRoot } from \"./root.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nexport class IntersectionNode extends BaseRoot {\n    basis = this.domain ?? this.proto ?? null;\n    refinements = this.children.filter((node) => node.isRefinement());\n    expression = this.structure?.expression ||\n        this.children.map(node => node.nestableExpression).join(\" & \") ||\n        \"unknown\";\n    traverseAllows = (data, ctx) => this.children.every(child => child.traverseAllows(data, ctx));\n    traverseApply = (data, ctx) => {\n        const errorCount = ctx.currentErrorCount;\n        if (this.basis) {\n            this.basis.traverseApply(data, ctx);\n            if (ctx.currentErrorCount > errorCount)\n                return;\n        }\n        if (this.refinements.length) {\n            for (let i = 0; i < this.refinements.length - 1; i++) {\n                this.refinements[i].traverseApply(data, ctx);\n                if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                    return;\n            }\n            this.refinements.at(-1).traverseApply(data, ctx);\n            if (ctx.currentErrorCount > errorCount)\n                return;\n        }\n        if (this.structure) {\n            this.structure.traverseApply(data, ctx);\n            if (ctx.currentErrorCount > errorCount)\n                return;\n        }\n        if (this.predicate) {\n            for (let i = 0; i < this.predicate.length - 1; i++) {\n                this.predicate[i].traverseApply(data, ctx);\n                if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                    return;\n            }\n            this.predicate.at(-1).traverseApply(data, ctx);\n        }\n    };\n    compile(js) {\n        if (js.traversalKind === \"Allows\") {\n            this.children.forEach(child => js.check(child));\n            js.return(true);\n            return;\n        }\n        js.initializeErrorCount();\n        if (this.basis) {\n            js.check(this.basis);\n            // we only have to return conditionally if this is not the last check\n            if (this.children.length > 1)\n                js.returnIfFail();\n        }\n        if (this.refinements.length) {\n            for (let i = 0; i < this.refinements.length - 1; i++) {\n                js.check(this.refinements[i]);\n                js.returnIfFailFast();\n            }\n            js.check(this.refinements.at(-1));\n            if (this.structure || this.predicate)\n                js.returnIfFail();\n        }\n        if (this.structure) {\n            js.check(this.structure);\n            if (this.predicate)\n                js.returnIfFail();\n        }\n        if (this.predicate) {\n            for (let i = 0; i < this.predicate.length - 1; i++) {\n                js.check(this.predicate[i]);\n                // since predicates can be chained, we have to fail immediately\n                // if one fails\n                js.returnIfFail();\n            }\n            js.check(this.predicate.at(-1));\n        }\n    }\n    rawKeyOf() {\n        return (this.basis ?\n            this.structure ?\n                this.basis.rawKeyOf().or(this.structure.keyof())\n                : this.basis.rawKeyOf()\n            : this.structure?.keyof() ?? this.$.keywords.never.raw);\n    }\n}\nconst intersectIntersections = (l, r, ctx) => {\n    // avoid treating adding instance keys as keys of lRoot, rRoot\n    if (hasArkKind(l, \"root\") && l.hasKind(\"intersection\"))\n        return intersectIntersections(l.inner, r, ctx);\n    if (hasArkKind(r, \"root\") && r.hasKind(\"intersection\"))\n        return intersectIntersections(l, r.inner, ctx);\n    const baseInner = isEmptyObject(l) ? pick(r, metaKeys) : {};\n    const lBasis = l.proto ?? l.domain;\n    const rBasis = r.proto ?? r.domain;\n    const basisResult = lBasis ?\n        rBasis ?\n            intersectNodes(lBasis, rBasis, ctx)\n            : lBasis\n        : rBasis;\n    if (basisResult instanceof Disjoint)\n        return basisResult;\n    if (basisResult)\n        baseInner[basisResult.kind] = basisResult;\n    return intersectConstraints({\n        kind: \"intersection\",\n        baseInner,\n        l: flattenConstraints(l),\n        r: flattenConstraints(r),\n        roots: [],\n        ctx\n    });\n};\nexport const intersectionImplementation = implementNode({\n    kind: \"intersection\",\n    hasAssociatedError: true,\n    normalize: rawSchema => {\n        if (isNode(rawSchema))\n            return rawSchema;\n        const { structure, ...schema } = rawSchema;\n        const hasRootStructureKey = !!structure;\n        const normalizedStructure = structure ?? {};\n        const normalized = flatMorph(schema, (k, v) => {\n            if (isKeyOf(k, structureKeys)) {\n                if (hasRootStructureKey) {\n                    throwParseError(`Flattened structure key ${k} cannot be specified alongside a root 'structure' key.`);\n                }\n                normalizedStructure[k] = v;\n                return [];\n            }\n            return [k, v];\n        });\n        if (!isEmptyObject(normalizedStructure))\n            normalized.structure = normalizedStructure;\n        return normalized;\n    },\n    finalizeJson: ({ structure, ...rest }) => hasDomain(structure, \"object\") ? { ...structure, ...rest } : rest,\n    keys: {\n        domain: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.node(\"domain\", schema)\n        },\n        proto: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.node(\"proto\", schema)\n        },\n        structure: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.node(\"structure\", schema),\n            serialize: node => {\n                if (!node.sequence?.minLength)\n                    return node.collapsibleJson;\n                const { sequence, ...structureJson } = node.collapsibleJson;\n                const { minVariadicLength, ...sequenceJson } = sequence;\n                const collapsibleSequenceJson = sequenceJson.variadic && Object.keys(sequenceJson).length === 1 ?\n                    sequenceJson.variadic\n                    : sequenceJson;\n                return { ...structureJson, sequence: collapsibleSequenceJson };\n            }\n        },\n        divisor: {\n            child: true,\n            parse: constraintKeyParser(\"divisor\")\n        },\n        max: {\n            child: true,\n            parse: constraintKeyParser(\"max\")\n        },\n        min: {\n            child: true,\n            parse: constraintKeyParser(\"min\")\n        },\n        maxLength: {\n            child: true,\n            parse: constraintKeyParser(\"maxLength\")\n        },\n        minLength: {\n            child: true,\n            parse: constraintKeyParser(\"minLength\")\n        },\n        exactLength: {\n            child: true,\n            parse: constraintKeyParser(\"exactLength\")\n        },\n        before: {\n            child: true,\n            parse: constraintKeyParser(\"before\")\n        },\n        after: {\n            child: true,\n            parse: constraintKeyParser(\"after\")\n        },\n        regex: {\n            child: true,\n            parse: constraintKeyParser(\"regex\")\n        },\n        predicate: {\n            child: true,\n            parse: constraintKeyParser(\"predicate\")\n        }\n    },\n    // leverage reduction logic from intersection and identity to ensure initial\n    // parse result is reduced\n    reduce: (inner, $) => \n    // we cast union out of the result here since that only occurs when intersecting two sequences\n    // that cannot occur when reducing a single intersection schema using unknown\n    intersectIntersections({}, inner, {\n        $,\n        invert: false,\n        pipe: false\n    }),\n    defaults: {\n        description: node => node.children.length === 0 ?\n            \"unknown\"\n            : node.structure?.description ??\n                node.children.map(child => child.description).join(\" and \"),\n        expected: source => `  • ${source.errors.map(e => e.expected).join(\"\\n  • \")}`,\n        problem: ctx => `must be...\\n${ctx.expected}`\n    },\n    intersections: {\n        intersection: (l, r, ctx) => intersectIntersections(l, r, ctx),\n        ...defineRightwardIntersections(\"intersection\", (l, r, ctx) => {\n            // if l is unknown, return r\n            if (l.children.length === 0)\n                return r;\n            const basis = l.basis ? intersectNodes(l.basis, r, ctx) : r;\n            return (basis instanceof Disjoint ? basis\n                : l?.basis?.equals(basis) ?\n                    // if the basis doesn't change, return the original intesection\n                    l\n                    // given we've already precluded l being unknown, the result must\n                    // be an intersection with the new basis result integrated\n                    : l.$.node(\"intersection\", Object.assign(omit(l.inner, metaKeys), {\n                        [basis.kind]: basis\n                    }), { prereduced: true }));\n        })\n    }\n});\n","import { arrayFrom, registeredReference, throwParseError } from \"@arktype/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectNodes } from \"../shared/intersections.js\";\nimport { hasArkKind } from \"../shared/utils.js\";\nimport { BaseRoot } from \"./root.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nconst morphInputKinds = [\n    \"intersection\",\n    \"unit\",\n    \"domain\",\n    \"proto\"\n];\nexport const morphImplementation = implementNode({\n    kind: \"morph\",\n    hasAssociatedError: false,\n    keys: {\n        in: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.node(morphInputKinds, schema)\n        },\n        morphs: {\n            parse: arrayFrom,\n            serialize: morphs => morphs.map(m => hasArkKind(m, \"root\") ? m.json : registeredReference(m))\n        }\n    },\n    normalize: schema => schema,\n    defaults: {\n        description: node => `a morph from ${node.in.description} to ${node.out?.description ?? \"unknown\"}`\n    },\n    intersections: {\n        morph: (l, r, ctx) => {\n            if (l.morphs.some((morph, i) => morph !== r.morphs[i]))\n                // TODO: check in for union reduction\n                return throwParseError(\"Invalid intersection of morphs\");\n            const inTersection = intersectNodes(l.in, r.in, ctx);\n            if (inTersection instanceof Disjoint)\n                return inTersection;\n            // in case from is a union, we need to distribute the branches\n            // to can be a union as any schema is allowed\n            return ctx.$.schema(inTersection.branches.map(inBranch => ctx.$.node(\"morph\", {\n                morphs: l.morphs,\n                in: inBranch\n            })));\n        },\n        ...defineRightwardIntersections(\"morph\", (l, r, ctx) => {\n            const inTersection = intersectNodes(l.in, r, ctx);\n            return (inTersection instanceof Disjoint ? inTersection\n                : inTersection.kind === \"union\" ?\n                    ctx.$.node(\"union\", inTersection.branches.map(branch => ({\n                        ...l.inner,\n                        in: branch\n                    })))\n                    : ctx.$.node(\"morph\", {\n                        ...l.inner,\n                        in: inTersection\n                    }));\n        })\n    }\n});\nexport class MorphNode extends BaseRoot {\n    serializedMorphs = this.morphs.map(registeredReference);\n    compiledMorphs = `[${this.serializedMorphs}]`;\n    traverseAllows = (data, ctx) => this.in.traverseAllows(data, ctx);\n    traverseApply = (data, ctx) => {\n        ctx.queueMorphs(this.morphs);\n        this.in.traverseApply(data, ctx);\n    };\n    expression = `(In: ${this.in.expression}) => Out<${this.out?.expression ?? \"unknown\"}>`;\n    compile(js) {\n        if (js.traversalKind === \"Allows\") {\n            js.return(js.invoke(this.in));\n            return;\n        }\n        js.line(`ctx.queueMorphs(${this.compiledMorphs})`);\n        js.line(js.invoke(this.in));\n    }\n    get in() {\n        return this.inner.in;\n    }\n    get validatedOut() {\n        const lastMorph = this.inner.morphs.at(-1);\n        return hasArkKind(lastMorph, \"root\") ?\n            lastMorph?.out\n            : undefined;\n    }\n    get out() {\n        return this.validatedOut ?? this.$.keywords.unknown.raw;\n    }\n    rawKeyOf() {\n        return this.in.rawKeyOf();\n    }\n}\n","import { builtinConstructors, constructorExtends, getExactBuiltinConstructorName, objectKindDescriptions, objectKindOrDomainOf, prototypeKeysOf } from \"@arktype/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { defaultValueSerializer, implementNode } from \"../shared/implement.js\";\nimport { RawBasis } from \"./basis.js\";\nexport const protoImplementation = implementNode({\n    kind: \"proto\",\n    hasAssociatedError: true,\n    collapsibleKey: \"proto\",\n    keys: {\n        proto: {\n            serialize: ctor => getExactBuiltinConstructorName(ctor) ?? defaultValueSerializer(ctor)\n        }\n    },\n    normalize: schema => typeof schema === \"string\" ? { proto: builtinConstructors[schema] }\n        : typeof schema === \"function\" ? { proto: schema }\n            : typeof schema.proto === \"string\" ?\n                { ...schema, proto: builtinConstructors[schema.proto] }\n                : schema,\n    defaults: {\n        description: node => node.builtinName ?\n            objectKindDescriptions[node.builtinName]\n            : `an instance of ${node.proto.name}`,\n        actual: data => objectKindOrDomainOf(data)\n    },\n    intersections: {\n        proto: (l, r) => constructorExtends(l.proto, r.proto) ? l\n            : constructorExtends(r.proto, l.proto) ? r\n                : Disjoint.from(\"proto\", l, r),\n        domain: (proto, domain, ctx) => domain.domain === \"object\" ?\n            proto\n            : Disjoint.from(\"domain\", ctx.$.keywords.object.raw, domain)\n    }\n});\nexport class ProtoNode extends RawBasis {\n    builtinName = getExactBuiltinConstructorName(this.proto);\n    serializedConstructor = this.json.proto;\n    compiledCondition = `data instanceof ${this.serializedConstructor}`;\n    compiledNegation = `!(${this.compiledCondition})`;\n    literalKeys = prototypeKeysOf(this.proto.prototype);\n    traverseAllows = data => data instanceof this.proto;\n    expression = this.proto.name;\n    domain = \"object\";\n}\n","var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for (var i = 0; i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n};\nvar __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        }\n        else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n};\nimport { appendUnique, cached, compileLiteralPropAccess, domainDescriptions, entriesOf, flatMorph, groupBy, isArray, isKeyOf, printable, throwInternalError } from \"@arktype/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode, schemaKindsRightOf } from \"../shared/implement.js\";\nimport { intersectNodes, intersectNodesRoot } from \"../shared/intersections.js\";\nimport { BaseRoot } from \"./root.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nconst unionChildKinds = [\n    ...schemaKindsRightOf(\"union\"),\n    \"alias\"\n];\nexport const unionImplementation = implementNode({\n    kind: \"union\",\n    hasAssociatedError: true,\n    collapsibleKey: \"branches\",\n    keys: {\n        ordered: {},\n        branches: {\n            child: true,\n            parse: (schema, ctx) => {\n                const branches = schema.map(branch => ctx.$.node(unionChildKinds, branch));\n                if (!ctx.schema.ordered)\n                    branches.sort((l, r) => (l.innerHash < r.innerHash ? -1 : 1));\n                return branches;\n            }\n        }\n    },\n    normalize: schema => (isArray(schema) ? { branches: schema } : schema),\n    reduce: (inner, $) => {\n        const reducedBranches = reduceBranches(inner);\n        if (reducedBranches.length === 1)\n            return reducedBranches[0];\n        if (reducedBranches.length === inner.branches.length)\n            return;\n        return $.node(\"union\", {\n            ...inner,\n            branches: reducedBranches\n        }, { prereduced: true });\n    },\n    defaults: {\n        description: node => describeBranches(node.branches.map(branch => branch.description)),\n        expected: ctx => {\n            const byPath = groupBy(ctx.errors, \"propString\");\n            const pathDescriptions = Object.entries(byPath).map(([path, errors]) => {\n                const branchesAtPath = [];\n                errors.forEach(errorAtPath => \n                // avoid duplicate messages when multiple branches\n                // are invalid due to the same error\n                appendUnique(branchesAtPath, errorAtPath.expected));\n                const expected = describeBranches(branchesAtPath);\n                // if there are multiple actual descriptions that differ,\n                // just fall back to printable, which is the most specific\n                const actual = errors.every(e => e.actual === errors[0].actual) ?\n                    errors[0].actual\n                    : printable(errors[0].data);\n                return `${path && `${path} `}must be ${expected}${actual && ` (was ${actual})`}`;\n            });\n            return describeBranches(pathDescriptions);\n        },\n        problem: ctx => ctx.expected,\n        message: ctx => ctx.problem\n    },\n    intersections: {\n        union: (l, r, ctx) => {\n            if (l.isNever !== r.isNever) {\n                // if exactly one operand is never, we can use it to discriminate based on presence\n                return Disjoint.from(\"presence\", l, r);\n            }\n            let resultBranches;\n            if (l.ordered) {\n                if (r.ordered)\n                    return Disjoint.from(\"indiscriminableMorphs\", l, r);\n                resultBranches = intersectBranches(r.branches, l.branches, ctx);\n                if (resultBranches instanceof Disjoint)\n                    resultBranches.invert();\n            }\n            else\n                resultBranches = intersectBranches(l.branches, r.branches, ctx);\n            if (resultBranches instanceof Disjoint)\n                return resultBranches;\n            return ctx.$.schema(l.ordered || r.ordered ?\n                {\n                    branches: resultBranches,\n                    ordered: true\n                }\n                : { branches: resultBranches });\n        },\n        ...defineRightwardIntersections(\"union\", (l, r, ctx) => {\n            const branches = intersectBranches(l.branches, [r], ctx);\n            if (branches instanceof Disjoint)\n                return branches;\n            if (branches.length === 1)\n                return branches[0];\n            return ctx.$.schema(l.ordered ? { branches, ordered: true } : { branches });\n        })\n    }\n});\nlet UnionNode = (() => {\n    let _classSuper = BaseRoot;\n    let _instanceExtraInitializers = [];\n    let _discriminate_decorators;\n    return class UnionNode extends _classSuper {\n        static {\n            const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n            _discriminate_decorators = [cached];\n            __esDecorate(this, null, _discriminate_decorators, { kind: \"method\", name: \"discriminate\", static: false, private: false, access: { has: obj => \"discriminate\" in obj, get: obj => obj.discriminate }, metadata: _metadata }, null, _instanceExtraInitializers);\n            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });\n        }\n        isNever = (__runInitializers(this, _instanceExtraInitializers), this.branches.length === 0);\n        isBoolean = this.branches.length === 2 &&\n            this.branches[0].hasUnit(false) &&\n            this.branches[1].hasUnit(true);\n        unitBranches = this.branches.filter((n) => n.hasKind(\"unit\"));\n        discriminant = this.discriminate();\n        discriminantJson = this.discriminant ? discriminantToJson(this.discriminant) : null;\n        expression = this.isNever ? \"never\"\n            : this.isBoolean ? \"boolean\"\n                : this.branches.map(branch => branch.nestableExpression).join(\" | \");\n        traverseAllows = (data, ctx) => this.branches.some(b => b.traverseAllows(data, ctx));\n        traverseApply = (data, ctx) => {\n            const errors = [];\n            for (let i = 0; i < this.branches.length; i++) {\n                ctx.pushBranch();\n                this.branches[i].traverseApply(data, ctx);\n                if (!ctx.hasError())\n                    return ctx.queuedMorphs.push(...ctx.popBranch().queuedMorphs);\n                errors.push(ctx.popBranch().error);\n            }\n            ctx.error({ code: \"union\", errors });\n        };\n        compile(js) {\n            if (!this.discriminant ||\n                // if we have a union of two units like `boolean`, the\n                // undiscriminated compilation will be just as fast\n                (this.unitBranches.length === this.branches.length &&\n                    this.branches.length === 2))\n                return this.compileIndiscriminable(js);\n            // we need to access the path as optional so we don't throw if it isn't present\n            const condition = this.discriminant.path.reduce((acc, segment) => acc + compileLiteralPropAccess(segment, true), this.discriminant.kind === \"domain\" ? \"typeof data\" : \"data\");\n            const cases = this.discriminant.cases;\n            const caseKeys = Object.keys(cases);\n            js.block(`switch(${condition})`, () => {\n                for (const k in cases) {\n                    const v = cases[k];\n                    const caseCondition = k === \"default\" ? \"default\" : `case ${k}`;\n                    js.line(`${caseCondition}: return ${v === true ? v : js.invoke(v)}`);\n                }\n                return js;\n            });\n            if (js.traversalKind === \"Allows\") {\n                js.return(false);\n                return;\n            }\n            const expected = describeBranches(this.discriminant.kind === \"domain\" ?\n                caseKeys.map(k => domainDescriptions[k.slice(1, -1)])\n                : caseKeys);\n            js.line(`ctx.error({\n\texpected: ${JSON.stringify(expected)},\n\tactual: ${condition},\n\trelativePath: ${JSON.stringify(this.discriminant.path)}\n})`);\n        }\n        compileIndiscriminable(js) {\n            if (js.traversalKind === \"Apply\") {\n                js.const(\"errors\", \"[]\");\n                this.branches.forEach(branch => js\n                    .line(\"ctx.pushBranch()\")\n                    .line(js.invoke(branch))\n                    .if(\"!ctx.hasError()\", () => js.return(\"ctx.queuedMorphs.push(...ctx.popBranch().queuedMorphs)\"))\n                    .line(\"errors.push(ctx.popBranch().error)\"));\n                js.line(`ctx.error({ code: \"union\", errors })`);\n            }\n            else {\n                this.branches.forEach(branch => js.if(`${js.invoke(branch)}`, () => js.return(true)));\n                js.return(false);\n            }\n        }\n        rawKeyOf() {\n            return this.branches.reduce((result, branch) => result.and(branch.rawKeyOf()), this.$.keywords.unknown.raw);\n        }\n        get nestableExpression() {\n            // avoid adding unnecessary parentheses around boolean since it's\n            // already collapsed to a single keyword\n            return this.isBoolean ? \"boolean\" : super.nestableExpression;\n        }\n        discriminate() {\n            if (this.branches.length < 2)\n                return null;\n            if (this.unitBranches.length === this.branches.length) {\n                const cases = flatMorph(this.unitBranches, (i, unit) => [\n                    `${unit.serializedValue}`,\n                    true\n                ]);\n                return {\n                    path: [],\n                    kind: \"unit\",\n                    cases\n                };\n            }\n            const casesBySpecifier = {};\n            for (let lIndex = 0; lIndex < this.branches.length - 1; lIndex++) {\n                const l = this.branches[lIndex];\n                for (let rIndex = lIndex + 1; rIndex < this.branches.length; rIndex++) {\n                    const r = this.branches[rIndex];\n                    const result = intersectNodesRoot(l, r, l.$);\n                    if (!(result instanceof Disjoint))\n                        continue;\n                    for (const { path, kind, disjoint } of result.flat) {\n                        if (!isKeyOf(kind, discriminantKinds))\n                            continue;\n                        const qualifiedDiscriminant = `${path}${kind}`;\n                        let lSerialized;\n                        let rSerialized;\n                        if (kind === \"domain\") {\n                            lSerialized = `\"${disjoint.l.domain}\"`;\n                            rSerialized = `\"${disjoint.r.domain}\"`;\n                        }\n                        else if (kind === \"unit\") {\n                            lSerialized = disjoint.l.serializedValue;\n                            rSerialized = disjoint.r.serializedValue;\n                        }\n                        else {\n                            return throwInternalError(`Unexpected attempt to discriminate disjoint kind '${kind}'`);\n                        }\n                        if (!casesBySpecifier[qualifiedDiscriminant]) {\n                            casesBySpecifier[qualifiedDiscriminant] = {\n                                [lSerialized]: [l],\n                                [rSerialized]: [r]\n                            };\n                            continue;\n                        }\n                        const cases = casesBySpecifier[qualifiedDiscriminant];\n                        if (!isKeyOf(lSerialized, cases))\n                            cases[lSerialized] = [l];\n                        else if (!cases[lSerialized].includes(l))\n                            cases[lSerialized].push(l);\n                        if (!isKeyOf(rSerialized, cases))\n                            cases[rSerialized] = [r];\n                        else if (!cases[rSerialized].includes(r))\n                            cases[rSerialized].push(r);\n                    }\n                }\n            }\n            const bestDiscriminantEntry = entriesOf(casesBySpecifier)\n                .sort((a, b) => Object.keys(a[1]).length - Object.keys(b[1]).length)\n                .at(-1);\n            if (!bestDiscriminantEntry)\n                return null;\n            const [specifier, bestCases] = bestDiscriminantEntry;\n            const [path, kind] = parseDiscriminantKey(specifier);\n            let defaultBranches = [...this.branches];\n            const cases = flatMorph(bestCases, (k, caseBranches) => {\n                const prunedBranches = [];\n                defaultBranches = defaultBranches.filter(n => !caseBranches.includes(n));\n                for (const branch of caseBranches) {\n                    const pruned = pruneDiscriminant(kind, path, branch);\n                    // if any branch of the union has no constraints (i.e. is unknown)\n                    // return it right away\n                    if (pruned === null)\n                        return [k, true];\n                    prunedBranches.push(pruned);\n                }\n                const caseNode = prunedBranches.length === 1 ?\n                    prunedBranches[0]\n                    : this.$.node(\"union\", prunedBranches);\n                Object.assign(this.referencesById, caseNode.referencesById);\n                return [k, caseNode];\n            });\n            if (defaultBranches.length) {\n                cases.default = this.$.node(\"union\", defaultBranches, {\n                    prereduced: true\n                });\n                Object.assign(this.referencesById, cases.default.referencesById);\n            }\n            return {\n                kind,\n                path,\n                cases\n            };\n        }\n    };\n})();\nexport { UnionNode };\nconst discriminantToJson = (discriminant) => ({\n    kind: discriminant.kind,\n    path: discriminant.path,\n    cases: flatMorph(discriminant.cases, (k, node) => [\n        k,\n        node === true ? node\n            : node.hasKind(\"union\") && node.discriminantJson ? node.discriminantJson\n                : node.json\n    ])\n});\nconst describeBranches = (descriptions) => {\n    if (descriptions.length === 0)\n        return \"never\";\n    if (descriptions.length === 1)\n        return descriptions[0];\n    if ((descriptions.length === 2 &&\n        descriptions[0] === \"false\" &&\n        descriptions[1] === \"true\") ||\n        (descriptions[0] === \"true\" && descriptions[1] === \"false\"))\n        return \"boolean\";\n    let description = \"\";\n    for (let i = 0; i < descriptions.length - 1; i++) {\n        description += descriptions[i];\n        if (i < descriptions.length - 2)\n            description += \", \";\n    }\n    description += ` or ${descriptions[descriptions.length - 1]}`;\n    return description;\n};\nexport const intersectBranches = (l, r, ctx) => {\n    // If the corresponding r branch is identified as a subtype of an l branch, the\n    // value at rIndex is set to null so we can avoid including previous/future\n    // inersections in the reduced result.\n    const batchesByR = r.map(() => []);\n    for (let lIndex = 0; lIndex < l.length; lIndex++) {\n        let candidatesByR = {};\n        for (let rIndex = 0; rIndex < r.length; rIndex++) {\n            if (batchesByR[rIndex] === null) {\n                // rBranch is a subtype of an lBranch and\n                // will not yield any distinct intersection\n                continue;\n            }\n            if (l[lIndex].equals(r[rIndex])) {\n                // Combination of subtype and supertype cases\n                batchesByR[rIndex] = null;\n                candidatesByR = {};\n                break;\n            }\n            const branchIntersection = intersectNodes(l[lIndex], r[rIndex], ctx);\n            if (branchIntersection instanceof Disjoint) {\n                // Doesn't tell us anything useful about their relationships\n                // with other branches\n                continue;\n            }\n            if (branchIntersection.equals(l[lIndex])) {\n                // If the current l branch is a subtype of r, intersections\n                // with previous and remaining branches of r won't lead to\n                // distinct intersections.\n                batchesByR[rIndex].push(l[lIndex]);\n                candidatesByR = {};\n                break;\n            }\n            if (branchIntersection.equals(r[rIndex])) {\n                // If the current r branch is a subtype of l, set its batch to\n                // null, removing any previous intersections and preventing any\n                // of its remaining intersections from being computed.\n                batchesByR[rIndex] = null;\n            }\n            else {\n                // If neither l nor r is a subtype of the other, add their\n                // intersection as a candidate (could still be removed if it is\n                // determined l or r is a subtype of a remaining branch).\n                candidatesByR[rIndex] = branchIntersection;\n            }\n        }\n        for (const rIndex in candidatesByR) {\n            // batchesByR at rIndex should never be null if it is in candidatesByR\n            batchesByR[rIndex][lIndex] = candidatesByR[rIndex];\n        }\n    }\n    // Compile the reduced intersection result, including:\n    // \t\t1. Remaining candidates resulting from distinct intersections or strict subtypes of r\n    // \t\t2. Original r branches corresponding to indices with a null batch (subtypes of l)\n    const resultBranches = batchesByR.flatMap(\n    // ensure unions returned from branchable intersections like sequence are flattened\n    (batch, i) => batch?.flatMap(branch => branch.branches) ?? r[i]);\n    return resultBranches.length === 0 ?\n        Disjoint.from(\"union\", l, r)\n        : resultBranches;\n};\nexport const reduceBranches = ({ branches, ordered }) => {\n    if (branches.length < 2)\n        return branches;\n    const uniquenessByIndex = branches.map(() => true);\n    for (let i = 0; i < branches.length; i++) {\n        for (let j = i + 1; j < branches.length && uniquenessByIndex[i] && uniquenessByIndex[j]; j++) {\n            if (branches[i].equals(branches[j])) {\n                // if the two branches are equal, only \"j\" is marked as\n                // redundant so at least one copy could still be included in\n                // the final set of branches.\n                uniquenessByIndex[j] = false;\n                continue;\n            }\n            const intersection = intersectNodesRoot(branches[i], branches[j], branches[0].$);\n            if (intersection instanceof Disjoint)\n                continue;\n            if (intersection.equals(branches[i])) {\n                if (!ordered) {\n                    // preserve ordered branches that are a subtype of a subsequent branch\n                    uniquenessByIndex[i] = false;\n                }\n            }\n            else if (intersection.equals(branches[j]))\n                uniquenessByIndex[j] = false;\n        }\n    }\n    return branches.filter((_, i) => uniquenessByIndex[i]);\n};\nconst discriminantKinds = {\n    domain: 1,\n    unit: 1\n};\nconst parseDiscriminantKey = (key) => {\n    const lastPathIndex = key.lastIndexOf(\"]\");\n    const parsedPath = JSON.parse(key.slice(0, lastPathIndex + 1));\n    const parsedKind = key.slice(lastPathIndex + 1);\n    return [parsedPath, parsedKind];\n};\nexport const pruneDiscriminant = (discriminantKind, path, branch) => branch.transform((nodeKind, inner, ctx) => {\n    // if we've already checked a path at least as long as the current one,\n    // we don't need to revalidate that we're in an object\n    if (nodeKind === \"domain\" &&\n        inner.domain === \"object\" &&\n        path.length > ctx.path.length)\n        return null;\n    // if the discriminant has already checked the domain at the current path\n    // (or an exact value, implying a domain), we don't need to recheck it\n    if ((discriminantKind === nodeKind ||\n        (nodeKind === \"domain\" && ctx.path.length === path.length)) &&\n        ctx.path.length === path.length &&\n        ctx.path.every((segment, i) => segment === path[i]))\n        return null;\n    return inner;\n}, {\n    shouldTransform: node => node.children.length !== 0 ||\n        node.kind === \"domain\" ||\n        node.kind === \"unit\"\n});\n// // TODO: if deeply includes morphs?\n// const writeUndiscriminableMorphUnionMessage = <path extends string>(\n// \tpath: path\n// ) =>\n// \t`${\n// \t\tpath === \"/\" ? \"A\" : `At ${path}, a`\n// \t} union including one or more morphs must be discriminable` as const\n","import { domainOf, printable, prototypeKeysOf } from \"@arktype/util\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { defaultValueSerializer, implementNode } from \"../shared/implement.js\";\nimport { RawBasis } from \"./basis.js\";\nimport { defineRightwardIntersections } from \"./utils.js\";\nexport const unitImplementation = implementNode({\n    kind: \"unit\",\n    hasAssociatedError: true,\n    keys: {\n        unit: {\n            preserveUndefined: true,\n            serialize: schema => schema instanceof Date ?\n                schema.toISOString()\n                : defaultValueSerializer(schema)\n        }\n    },\n    normalize: schema => schema,\n    defaults: {\n        description: node => printable(node.unit),\n        problem: ({ expected, actual }) => `${expected === actual ? `must be reference equal to ${expected} (serialized to the same value)` : `must be ${expected} (was ${actual})`}`\n    },\n    intersections: {\n        unit: (l, r) => Disjoint.from(\"unit\", l, r),\n        ...defineRightwardIntersections(\"unit\", (l, r) => r.allows(l.unit) ? l : (Disjoint.from(\"assignability\", l, r.hasKind(\"intersection\") ?\n            r.children.find(rConstraint => !rConstraint.allows(l.unit))\n            : r)))\n    }\n});\nexport class UnitNode extends RawBasis {\n    compiledValue = this.json.unit;\n    serializedValue = typeof this.unit === \"string\" || this.unit instanceof Date ?\n        JSON.stringify(this.compiledValue)\n        : this.compiledValue;\n    literalKeys = prototypeKeysOf(this.unit);\n    compiledCondition = compileEqualityCheck(this.unit, this.serializedValue);\n    compiledNegation = compileEqualityCheck(this.unit, this.serializedValue, \"negated\");\n    expression = printable(this.unit);\n    domain = domainOf(this.unit);\n    traverseAllows = this.unit instanceof Date ?\n        data => data instanceof Date && data.toISOString() === this.compiledValue\n        : data => data === this.unit;\n}\nconst compileEqualityCheck = (unit, serializedValue, negated) => {\n    if (unit instanceof Date) {\n        const condition = `data instanceof Date && data.toISOString() === ${serializedValue}`;\n        return negated ? `!(${condition})` : condition;\n    }\n    return `data ${negated ? \"!\" : \"=\"}== ${serializedValue}`;\n};\n","import { printable, stringAndSymbolicEntriesOf, throwParseError } from \"@arktype/util\";\nimport { BaseConstraint } from \"../constraint.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectNodes } from \"../shared/intersections.js\";\nexport const indexImplementation = implementNode({\n    kind: \"index\",\n    hasAssociatedError: false,\n    intersectionIsOpen: true,\n    keys: {\n        signature: {\n            child: true,\n            parse: (schema, ctx) => {\n                const key = ctx.$.schema(schema);\n                if (!key.extends(ctx.$.keywords.propertyKey)) {\n                    return throwParseError(writeInvalidPropertyKeyMessage(key.expression));\n                }\n                const enumerableBranches = key.branches.filter((b) => b.hasKind(\"unit\"));\n                if (enumerableBranches.length) {\n                    return throwParseError(writeEnumerableIndexBranches(enumerableBranches.map(b => printable(b.unit))));\n                }\n                return key;\n            }\n        },\n        value: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.schema(schema)\n        }\n    },\n    normalize: schema => schema,\n    defaults: {\n        description: node => `[${node.signature.expression}]: ${node.value.description}`\n    },\n    intersections: {\n        index: (l, r, ctx) => {\n            if (l.signature.equals(r.signature)) {\n                const valueIntersection = intersectNodes(l.value, r.value, ctx);\n                const value = valueIntersection instanceof Disjoint ?\n                    ctx.$.keywords.never.raw\n                    : valueIntersection;\n                return ctx.$.node(\"index\", { signature: l.signature, value });\n            }\n            // if r constrains all of l's keys to a subtype of l's value, r is a subtype of l\n            if (l.signature.extends(r.signature) && l.value.subsumes(r.value))\n                return r;\n            // if l constrains all of r's keys to a subtype of r's value, l is a subtype of r\n            if (r.signature.extends(l.signature) && r.value.subsumes(l.value))\n                return l;\n            // other relationships between index signatures can't be generally reduced\n            return null;\n        }\n    }\n});\nexport class IndexNode extends BaseConstraint {\n    impliedBasis = this.$.keywords.object.raw;\n    expression = `[${this.signature.expression}]: ${this.value.expression}`;\n    traverseAllows = (data, ctx) => stringAndSymbolicEntriesOf(data).every(entry => {\n        if (this.signature.traverseAllows(entry[0], ctx)) {\n            // ctx will be undefined if this node isn't context-dependent\n            ctx?.path.push(entry[0]);\n            const allowed = this.value.traverseAllows(entry[1], ctx);\n            ctx?.path.pop();\n            return allowed;\n        }\n        return true;\n    });\n    traverseApply = (data, ctx) => stringAndSymbolicEntriesOf(data).forEach(entry => {\n        if (this.signature.traverseAllows(entry[0], ctx)) {\n            ctx.path.push(entry[0]);\n            this.value.traverseApply(entry[1], ctx);\n            ctx.path.pop();\n        }\n    });\n    _transform(mapper, ctx) {\n        ctx.path.push(this.signature);\n        const result = super._transform(mapper, ctx);\n        ctx.path.pop();\n        return result;\n    }\n    compile() {\n        // this is currently handled by StructureNode\n    }\n}\nexport const writeEnumerableIndexBranches = (keys) => `Index keys ${keys.join(\", \")} should be specified as named props.`;\nexport const writeInvalidPropertyKeyMessage = (indexSchema) => `Indexed key definition '${indexSchema}' must be a string, number or symbol`;\n","import { compileSerializedValue, printable, registeredReference, throwParseError, unset } from \"@arktype/util\";\nimport { BaseConstraint } from \"../constraint.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { intersectNodes } from \"../shared/intersections.js\";\nexport const intersectProps = (l, r, ctx) => {\n    if (l.key !== r.key)\n        return null;\n    const key = l.key;\n    let value = intersectNodes(l.value, r.value, ctx);\n    const kind = l.required || r.required ? \"required\" : \"optional\";\n    if (value instanceof Disjoint) {\n        if (kind === \"optional\")\n            value = ctx.$.keywords.never.raw;\n        else\n            return value.withPrefixKey(l.compiledKey);\n    }\n    if (kind === \"required\") {\n        return ctx.$.node(\"required\", {\n            key,\n            value\n        });\n    }\n    const defaultIntersection = l.hasDefault() ?\n        r.hasDefault() ?\n            l.default === r.default ?\n                l.default\n                : throwParseError(`Invalid intersection of default values ${printable(l.default)} & ${printable(r.default)}`)\n            : l.default\n        : r.hasDefault() ? r.default\n            : unset;\n    return ctx.$.node(\"optional\", {\n        key,\n        value,\n        // unset is stripped during parsing\n        default: defaultIntersection\n    });\n};\nexport class BaseProp extends BaseConstraint {\n    required = this.kind === \"required\";\n    impliedBasis = this.$.keywords.object.raw;\n    serializedKey = compileSerializedValue(this.key);\n    compiledKey = typeof this.key === \"string\" ? this.key : this.serializedKey;\n    _transform(mapper, ctx) {\n        ctx.path.push(this.key);\n        const result = super._transform(mapper, ctx);\n        ctx.path.pop();\n        return result;\n    }\n    defaultValueMorphs = [\n        data => {\n            data[this.key] = this.default;\n            return data;\n        }\n    ];\n    defaultValueMorphsReference = registeredReference(this.defaultValueMorphs);\n    hasDefault() {\n        return \"default\" in this;\n    }\n    traverseAllows = (data, ctx) => {\n        if (this.key in data) {\n            // ctx will be undefined if this node isn't context-dependent\n            ctx?.path.push(this.key);\n            const allowed = this.value.traverseAllows(data[this.key], ctx);\n            ctx?.path.pop();\n            return allowed;\n        }\n        return !this.required;\n    };\n    traverseApply = (data, ctx) => {\n        if (this.key in data) {\n            ctx.path.push(this.key);\n            this.value.traverseApply(data[this.key], ctx);\n            ctx.path.pop();\n        }\n        else if (this.hasKind(\"required\"))\n            ctx.error(this.errorContext);\n        else if (this.hasKind(\"optional\") && this.hasDefault())\n            ctx.queueMorphs(this.defaultValueMorphs);\n    };\n    compile(js) {\n        js.if(`${this.serializedKey} in data`, () => js.traverseKey(this.serializedKey, `data${js.prop(this.key)}`, this.value));\n        if (this.hasKind(\"required\")) {\n            js.else(() => {\n                if (js.traversalKind === \"Apply\")\n                    return js.line(`ctx.error(${this.compiledErrorContext})`);\n                else\n                    return js.return(false);\n            });\n        }\n        else if (js.traversalKind === \"Apply\" && \"default\" in this) {\n            js.else(() => js.line(`ctx.queueMorphs(${this.defaultValueMorphsReference})`));\n        }\n        if (js.traversalKind === \"Allows\")\n            js.return(true);\n    }\n}\n","import { implementNode } from \"../shared/implement.js\";\nimport { BaseProp, intersectProps } from \"./prop.js\";\nexport const optionalImplementation = implementNode({\n    kind: \"optional\",\n    hasAssociatedError: false,\n    intersectionIsOpen: true,\n    keys: {\n        key: {},\n        value: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.schema(schema)\n        },\n        default: {\n            preserveUndefined: true\n        }\n    },\n    normalize: schema => schema,\n    defaults: {\n        description: node => `${node.compiledKey}?: ${node.value.description}`\n    },\n    intersections: {\n        optional: intersectProps\n    }\n});\nexport class OptionalNode extends BaseProp {\n    expression = `${this.compiledKey}?: ${this.value.expression}`;\n}\n","import { compileErrorContext, implementNode } from \"../shared/implement.js\";\nimport { BaseProp, intersectProps } from \"./prop.js\";\nexport class RequiredNode extends BaseProp {\n    expression = `${this.compiledKey}: ${this.value.expression}`;\n    errorContext = Object.freeze({\n        code: \"required\",\n        missingValueDescription: this.value.description,\n        relativePath: [this.key]\n    });\n    compiledErrorContext = compileErrorContext(this.errorContext);\n}\nexport const requiredImplementation = implementNode({\n    kind: \"required\",\n    hasAssociatedError: true,\n    intersectionIsOpen: true,\n    keys: {\n        key: {},\n        value: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.schema(schema)\n        }\n    },\n    normalize: schema => schema,\n    defaults: {\n        description: node => `${node.compiledKey}: ${node.value.description}`,\n        expected: ctx => ctx.missingValueDescription,\n        actual: () => \"missing\"\n    },\n    intersections: {\n        required: intersectProps,\n        optional: intersectProps\n    }\n});\n","import { append, throwInternalError, throwParseError } from \"@arktype/util\";\nimport { BaseConstraint } from \"../constraint.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectNodes } from \"../shared/intersections.js\";\nconst fixedSequenceKeySchemaDefinition = {\n    child: true,\n    parse: (schema, ctx) => schema.length === 0 ?\n        // empty affixes are omitted. an empty array should therefore\n        // be specified as `{ proto: Array, length: 0 }`\n        undefined\n        : schema.map(element => ctx.$.schema(element))\n};\nexport const sequenceImplementation = implementNode({\n    kind: \"sequence\",\n    hasAssociatedError: false,\n    collapsibleKey: \"variadic\",\n    keys: {\n        prefix: fixedSequenceKeySchemaDefinition,\n        optionals: fixedSequenceKeySchemaDefinition,\n        variadic: {\n            child: true,\n            parse: (schema, ctx) => ctx.$.schema(schema, ctx)\n        },\n        minVariadicLength: {\n            // minVariadicLength is reflected in the id of this node,\n            // but not its IntersectionNode parent since it is superceded by the minLength\n            // node it implies\n            parse: min => (min === 0 ? undefined : min)\n        },\n        postfix: fixedSequenceKeySchemaDefinition\n    },\n    normalize: schema => {\n        if (typeof schema === \"string\")\n            return { variadic: schema };\n        if (\"variadic\" in schema ||\n            \"prefix\" in schema ||\n            \"optionals\" in schema ||\n            \"postfix\" in schema ||\n            \"minVariadicLength\" in schema) {\n            if (schema.postfix?.length) {\n                if (!schema.variadic)\n                    return throwParseError(postfixWithoutVariadicMessage);\n                if (schema.optionals?.length)\n                    return throwParseError(postfixFollowingOptionalMessage);\n            }\n            if (schema.minVariadicLength && !schema.variadic) {\n                return throwParseError(\"minVariadicLength may not be specified without a variadic element\");\n            }\n            return schema;\n        }\n        return { variadic: schema };\n    },\n    reduce: (raw, $) => {\n        let minVariadicLength = raw.minVariadicLength ?? 0;\n        const prefix = raw.prefix?.slice() ?? [];\n        const optional = raw.optionals?.slice() ?? [];\n        const postfix = raw.postfix?.slice() ?? [];\n        if (raw.variadic) {\n            // optional elements equivalent to the variadic parameter are redundant\n            while (optional.at(-1)?.equals(raw.variadic))\n                optional.pop();\n            if (optional.length === 0) {\n                // If there are no optional, normalize prefix\n                // elements adjacent and equivalent to variadic:\n                // \t\t{ variadic: number, prefix: [string, number] }\n                // reduces to:\n                // \t\t{ variadic: number, prefix: [string], minVariadicLength: 1 }\n                while (prefix.at(-1)?.equals(raw.variadic)) {\n                    prefix.pop();\n                    minVariadicLength++;\n                }\n            }\n            // Normalize postfix elements adjacent and equivalent to variadic:\n            // \t\t{ variadic: number, postfix: [number, number, 5] }\n            // reduces to:\n            // \t\t{ variadic: number, postfix: [5], minVariadicLength: 2 }\n            while (postfix[0]?.equals(raw.variadic)) {\n                postfix.shift();\n                minVariadicLength++;\n            }\n        }\n        else if (optional.length === 0) {\n            // if there's no variadic or optional parameters,\n            // postfix can just be appended to prefix\n            prefix.push(...postfix.splice(0));\n        }\n        if (\n        // if any variadic adjacent elements were moved to minVariadicLength\n        minVariadicLength !== raw.minVariadicLength ||\n            // or any postfix elements were moved to prefix\n            (raw.prefix && raw.prefix.length !== prefix.length)) {\n            // reparse the reduced def\n            return $.node(\"sequence\", {\n                ...raw,\n                // empty lists will be omitted during parsing\n                prefix,\n                postfix,\n                optionals: optional,\n                minVariadicLength\n            }, { prereduced: true });\n        }\n    },\n    defaults: {\n        description: node => {\n            if (node.isVariadicOnly)\n                return `${node.variadic.nestableExpression}[]`;\n            const innerDescription = node.tuple\n                .map(element => element.kind === \"optionals\" ? `${element.node.nestableExpression}?`\n                : element.kind === \"variadic\" ?\n                    `...${element.node.nestableExpression}[]`\n                    : element.node.expression)\n                .join(\", \");\n            return `[${innerDescription}]`;\n        }\n    },\n    intersections: {\n        sequence: (l, r, ctx) => {\n            const rootState = _intersectSequences({\n                l: l.tuple,\n                r: r.tuple,\n                disjoint: new Disjoint({}),\n                result: [],\n                fixedVariants: [],\n                ctx\n            });\n            const viableBranches = rootState.disjoint.isEmpty() ?\n                [rootState, ...rootState.fixedVariants]\n                : rootState.fixedVariants;\n            return (viableBranches.length === 0 ? rootState.disjoint\n                : viableBranches.length === 1 ?\n                    ctx.$.node(\"sequence\", sequenceTupleToInner(viableBranches[0].result))\n                    : ctx.$.node(\"union\", viableBranches.map(state => ({\n                        proto: Array,\n                        sequence: sequenceTupleToInner(state.result)\n                    }))));\n        }\n        // exactLength, minLength, and maxLength don't need to be defined\n        // here since impliedSiblings guarantees they will be added\n        // directly to the IntersectionNode parent of the SequenceNode\n        // they exist on\n    }\n});\nexport class SequenceNode extends BaseConstraint {\n    impliedBasis = this.$.keywords.Array.raw;\n    prefix = this.inner.prefix ?? [];\n    optionals = this.inner.optionals ?? [];\n    prevariadic = [...this.prefix, ...this.optionals];\n    postfix = this.inner.postfix ?? [];\n    isVariadicOnly = this.prevariadic.length + this.postfix.length === 0;\n    minVariadicLength = this.inner.minVariadicLength ?? 0;\n    minLength = this.prefix.length + this.minVariadicLength + this.postfix.length;\n    minLengthNode = this.minLength === 0 ? null : this.$.node(\"minLength\", this.minLength);\n    maxLength = this.variadic ? null : this.minLength + this.optionals.length;\n    maxLengthNode = this.maxLength === null ? null : this.$.node(\"maxLength\", this.maxLength);\n    impliedSiblings = this.minLengthNode ?\n        this.maxLengthNode ?\n            [this.minLengthNode, this.maxLengthNode]\n            : [this.minLengthNode]\n        : this.maxLengthNode ? [this.maxLengthNode]\n            : [];\n    childAtIndex(data, index) {\n        if (index < this.prevariadic.length)\n            return this.prevariadic[index];\n        const firstPostfixIndex = data.length - this.postfix.length;\n        if (index >= firstPostfixIndex)\n            return this.postfix[index - firstPostfixIndex];\n        return (this.variadic ??\n            throwInternalError(`Unexpected attempt to access index ${index} on ${this}`));\n    }\n    // minLength/maxLength should be checked by Intersection before either traversal\n    traverseAllows = (data, ctx) => {\n        for (let i = 0; i < data.length; i++)\n            if (!this.childAtIndex(data, i).traverseAllows(data[i], ctx))\n                return false;\n        return true;\n    };\n    traverseApply = (data, ctx) => {\n        for (let i = 0; i < data.length; i++) {\n            ctx.path.push(i);\n            this.childAtIndex(data, i).traverseApply(data[i], ctx);\n            ctx.path.pop();\n        }\n    };\n    // minLength/maxLength compilation should be handled by Intersection\n    compile(js) {\n        this.prefix.forEach((node, i) => js.traverseKey(`${i}`, `data[${i}]`, node));\n        this.optionals.forEach((node, i) => {\n            const dataIndex = `${i + this.prefix.length}`;\n            js.if(`${dataIndex} >= ${js.data}.length`, () => js.traversalKind === \"Allows\" ? js.return(true) : js.return());\n            js.traverseKey(dataIndex, `data[${dataIndex}]`, node);\n        });\n        if (this.variadic) {\n            if (this.postfix.length) {\n                js.const(\"firstPostfixIndex\", `${js.data}.length${this.postfix.length ? `- ${this.postfix.length}` : \"\"}`);\n            }\n            js.for(`i < ${this.postfix.length ? \"firstPostfixIndex\" : \"data.length\"}`, () => js.traverseKey(\"i\", \"data[i]\", this.variadic), this.prevariadic.length);\n            this.postfix.forEach((node, i) => {\n                const keyExpression = `firstPostfixIndex + ${i}`;\n                js.traverseKey(keyExpression, `data[${keyExpression}]`, node);\n            });\n        }\n        if (js.traversalKind === \"Allows\")\n            js.return(true);\n    }\n    _transform(mapper, ctx) {\n        ctx.path.push(this.$.keywords.nonNegativeIntegerString.raw);\n        const result = super._transform(mapper, ctx);\n        ctx.path.pop();\n        return result;\n    }\n    tuple = sequenceInnerToTuple(this.inner);\n    // this depends on tuple so needs to come after it\n    expression = this.description;\n}\nconst sequenceInnerToTuple = (inner) => {\n    const tuple = [];\n    inner.prefix?.forEach(node => tuple.push({ kind: \"prefix\", node }));\n    inner.optionals?.forEach(node => tuple.push({ kind: \"optionals\", node }));\n    if (inner.variadic)\n        tuple.push({ kind: \"variadic\", node: inner.variadic });\n    inner.postfix?.forEach(node => tuple.push({ kind: \"postfix\", node }));\n    return tuple;\n};\nconst sequenceTupleToInner = (tuple) => tuple.reduce((result, node) => {\n    if (node.kind === \"variadic\")\n        result.variadic = node.node;\n    else\n        result[node.kind] = append(result[node.kind], node.node);\n    return result;\n}, {});\nexport const postfixFollowingOptionalMessage = \"A postfix required element cannot follow an optional element\";\nexport const postfixWithoutVariadicMessage = \"A postfix element requires a variadic element\";\nconst _intersectSequences = (s) => {\n    const [lHead, ...lTail] = s.l;\n    const [rHead, ...rTail] = s.r;\n    if (!lHead || !rHead)\n        return s;\n    const lHasPostfix = lTail.at(-1)?.kind === \"postfix\";\n    const rHasPostfix = rTail.at(-1)?.kind === \"postfix\";\n    const kind = lHead.kind === \"prefix\" || rHead.kind === \"prefix\" ? \"prefix\"\n        : lHead.kind === \"optionals\" || rHead.kind === \"optionals\" ?\n            // if either operand has postfix elements, the full-length\n            // intersection can't include optional elements (though they may\n            // exist in some of the fixed length variants)\n            lHasPostfix || rHasPostfix ?\n                \"prefix\"\n                : \"optionals\"\n            : lHead.kind === \"postfix\" || rHead.kind === \"postfix\" ? \"postfix\"\n                : \"variadic\";\n    if (lHead.kind === \"prefix\" && rHead.kind === \"variadic\" && rHasPostfix) {\n        const postfixBranchResult = _intersectSequences({\n            ...s,\n            fixedVariants: [],\n            r: rTail.map(element => ({ ...element, kind: \"prefix\" }))\n        });\n        if (postfixBranchResult.disjoint.isEmpty())\n            s.fixedVariants.push(postfixBranchResult);\n    }\n    else if (rHead.kind === \"prefix\" &&\n        lHead.kind === \"variadic\" &&\n        lHasPostfix) {\n        const postfixBranchResult = _intersectSequences({\n            ...s,\n            fixedVariants: [],\n            l: lTail.map(element => ({ ...element, kind: \"prefix\" }))\n        });\n        if (postfixBranchResult.disjoint.isEmpty())\n            s.fixedVariants.push(postfixBranchResult);\n    }\n    const result = intersectNodes(lHead.node, rHead.node, s.ctx);\n    if (result instanceof Disjoint) {\n        if (kind === \"prefix\" || kind === \"postfix\") {\n            s.disjoint.add(result.withPrefixKey(\n            // TODO: more precise path handling for Disjoints\n            kind === \"prefix\" ? `${s.result.length}` : `-${lTail.length + 1}`));\n            s.result = [...s.result, { kind, node: s.ctx.$.keywords.never.raw }];\n        }\n        else if (kind === \"optionals\") {\n            // if the element result is optional and unsatisfiable, the\n            // intersection can still be satisfied as long as the tuple\n            // ends before the disjoint element would occur\n            return s;\n        }\n        else {\n            // if the element is variadic and unsatisfiable, the intersection\n            // can be satisfied with a fixed length variant including zero\n            // variadic elements\n            return _intersectSequences({\n                ...s,\n                fixedVariants: [],\n                // if there were any optional elements, there will be no postfix elements\n                // so this mapping will never occur (which would be illegal otherwise)\n                l: lTail.map(element => ({ ...element, kind: \"prefix\" })),\n                r: lTail.map(element => ({ ...element, kind: \"prefix\" }))\n            });\n        }\n    }\n    else\n        s.result = [...s.result, { kind, node: result }];\n    const lRemaining = s.l.length;\n    const rRemaining = s.r.length;\n    if (lHead.kind !== \"variadic\" ||\n        (lRemaining >= rRemaining &&\n            (rHead.kind === \"variadic\" || rRemaining === 1)))\n        s.l = lTail;\n    if (rHead.kind !== \"variadic\" ||\n        (rRemaining >= lRemaining &&\n            (lHead.kind === \"variadic\" || lRemaining === 1)))\n        s.r = rTail;\n    return _intersectSequences(s);\n};\n","import { registeredReference } from \"@arktype/util\";\nexport const arrayIndexMatcher = /(?:0|(?:[1-9]\\\\d*))$/;\nexport const arrayIndexMatcherReference = registeredReference(arrayIndexMatcher);\n","var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for (var i = 0; i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n};\nvar __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        }\n        else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n};\nimport { append, cached, flatMorph, registeredReference, spliterate } from \"@arktype/util\";\nimport { BaseConstraint, constraintKeyParser, flattenConstraints, intersectConstraints } from \"../constraint.js\";\nimport { Disjoint } from \"../shared/disjoint.js\";\nimport { implementNode } from \"../shared/implement.js\";\nimport { intersectNodesRoot } from \"../shared/intersections.js\";\nimport { makeRootAndArrayPropertiesMutable } from \"../shared/utils.js\";\nimport { arrayIndexMatcher, arrayIndexMatcherReference } from \"./shared.js\";\nlet StructureNode = (() => {\n    let _classSuper = BaseConstraint;\n    let _instanceExtraInitializers = [];\n    let _keyof_decorators;\n    return class StructureNode extends _classSuper {\n        static {\n            const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n            _keyof_decorators = [cached];\n            __esDecorate(this, null, _keyof_decorators, { kind: \"method\", name: \"keyof\", static: false, private: false, access: { has: obj => \"keyof\" in obj, get: obj => obj.keyof }, metadata: _metadata }, null, _instanceExtraInitializers);\n            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });\n        }\n        impliedBasis = (__runInitializers(this, _instanceExtraInitializers), this.$.keywords.object.raw);\n        impliedSiblings = this.children.flatMap(n => n.impliedSiblings ?? []);\n        props = this.required ?\n            this.optional ?\n                [...this.required, ...this.optional]\n                : this.required\n            : this.optional ?? [];\n        propsByKey = flatMorph(this.props, (i, node) => [node.key, node]);\n        propsByKeyReference = registeredReference(this.propsByKey);\n        expression = structuralExpression(this);\n        requiredLiteralKeys = this.required?.map(node => node.key) ?? [];\n        optionalLiteralKeys = this.optional?.map(node => node.key) ?? [];\n        literalKeys = [\n            ...this.requiredLiteralKeys,\n            ...this.optionalLiteralKeys\n        ];\n        keyof() {\n            let branches = this.$.units(this.literalKeys).branches;\n            this.index?.forEach(({ signature: index }) => {\n                branches = branches.concat(index.branches);\n            });\n            return this.$.node(\"union\", branches);\n        }\n        exhaustive = this.undeclared !== undefined || this.index !== undefined;\n        omit(...keys) {\n            return this.$.node(\"structure\", omitFromInner(this.inner, keys));\n        }\n        merge(r) {\n            const inner = makeRootAndArrayPropertiesMutable(omitFromInner(this.inner, [r.keyof()]));\n            if (r.required)\n                inner.required = append(inner.required, r.required);\n            if (r.optional)\n                inner.optional = append(inner.optional, r.optional);\n            if (r.index)\n                inner.index = append(inner.index, r.index);\n            if (r.sequence)\n                inner.sequence = r.sequence;\n            if (r.undeclared)\n                inner.undeclared = r.undeclared;\n            else\n                delete inner.undeclared;\n            return this.$.node(\"structure\", inner);\n        }\n        traverseAllows = (data, ctx) => this._traverse(\"Allows\", data, ctx);\n        traverseApply = (data, ctx) => this._traverse(\"Apply\", data, ctx);\n        _traverse = (traversalKind, data, ctx) => {\n            const errorCount = ctx?.currentErrorCount ?? 0;\n            for (let i = 0; i < this.props.length; i++) {\n                if (traversalKind === \"Allows\") {\n                    if (!this.props[i].traverseAllows(data, ctx))\n                        return false;\n                }\n                else {\n                    this.props[i].traverseApply(data, ctx);\n                    if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                        return false;\n                }\n            }\n            if (this.sequence) {\n                if (traversalKind === \"Allows\") {\n                    if (!this.sequence.traverseAllows(data, ctx))\n                        return false;\n                }\n                else {\n                    this.sequence.traverseApply(data, ctx);\n                    if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                        return false;\n                }\n            }\n            if (!this.exhaustive)\n                return true;\n            const keys = Object.keys(data);\n            keys.push(...Object.getOwnPropertySymbols(data));\n            for (let i = 0; i < keys.length; i++) {\n                const k = keys[i];\n                let matched = false;\n                if (this.index) {\n                    for (const node of this.index) {\n                        if (node.signature.traverseAllows(k, ctx)) {\n                            if (traversalKind === \"Allows\") {\n                                ctx?.path.push(k);\n                                const result = node.value.traverseAllows(data[k], ctx);\n                                ctx?.path.pop();\n                                if (!result)\n                                    return false;\n                            }\n                            else {\n                                ctx.path.push(k);\n                                node.value.traverseApply(data[k], ctx);\n                                ctx.path.pop();\n                                if (ctx.failFast && ctx.currentErrorCount > errorCount)\n                                    return false;\n                            }\n                            matched = true;\n                        }\n                    }\n                }\n                if (this.undeclared) {\n                    matched ||= k in this.propsByKey;\n                    matched ||=\n                        this.sequence !== undefined &&\n                            typeof k === \"string\" &&\n                            arrayIndexMatcher.test(k);\n                    if (!matched) {\n                        if (traversalKind === \"Allows\")\n                            return false;\n                        if (this.undeclared === \"reject\")\n                            ctx.error({ expected: \"removed\", actual: null, relativePath: [k] });\n                        else {\n                            ctx.queueMorphs([\n                                data => {\n                                    delete data[k];\n                                    return data;\n                                }\n                            ]);\n                        }\n                        if (ctx.failFast)\n                            return false;\n                    }\n                }\n                ctx?.path.pop();\n            }\n            return true;\n        };\n        compile(js) {\n            if (js.traversalKind === \"Apply\")\n                js.initializeErrorCount();\n            this.props.forEach(prop => {\n                js.check(prop);\n                if (js.traversalKind === \"Apply\")\n                    js.returnIfFailFast();\n            });\n            if (this.sequence) {\n                js.check(this.sequence);\n                if (js.traversalKind === \"Apply\")\n                    js.returnIfFailFast();\n            }\n            if (this.exhaustive) {\n                js.const(\"keys\", \"Object.keys(data)\");\n                js.line(\"keys.push(...Object.getOwnPropertySymbols(data))\");\n                js.for(\"i < keys.length\", () => this.compileExhaustiveEntry(js));\n            }\n            if (js.traversalKind === \"Allows\")\n                js.return(true);\n        }\n        compileExhaustiveEntry(js) {\n            js.const(\"k\", \"keys[i]\");\n            if (this.undeclared)\n                js.let(\"matched\", false);\n            this.index?.forEach(node => {\n                js.if(`${js.invoke(node.signature, { arg: \"k\", kind: \"Allows\" })}`, () => {\n                    js.traverseKey(\"k\", \"data[k]\", node.value);\n                    if (this.undeclared)\n                        js.set(\"matched\", true);\n                    return js;\n                });\n            });\n            if (this.undeclared) {\n                if (this.props?.length !== 0)\n                    js.line(`matched ||= k in ${this.propsByKeyReference}`);\n                if (this.sequence) {\n                    js.line(`matched ||= typeof k === \"string\" && ${arrayIndexMatcherReference}.test(k)`);\n                }\n                js.if(\"!matched\", () => {\n                    if (js.traversalKind === \"Allows\")\n                        return js.return(false);\n                    return this.undeclared === \"reject\" ?\n                        js\n                            .line(`ctx.error({ expected: \"removed\", actual: null, relativePath: [k] })`)\n                            .if(\"ctx.failFast\", () => js.return())\n                        : js.line(`ctx.queueMorphs([data => { delete data[k]; return data }])`);\n                });\n            }\n            return js;\n        }\n    };\n})();\nexport { StructureNode };\nconst omitFromInner = (inner, keys) => {\n    const result = { ...inner };\n    keys.forEach(k => {\n        if (result.required) {\n            result.required = result.required.filter(b => typeof k === \"function\" ? !k.allows(b.key) : k !== b.key);\n        }\n        if (result.optional) {\n            result.optional = result.optional.filter(b => typeof k === \"function\" ? !k.allows(b.key) : k !== b.key);\n        }\n        if (result.index && typeof k === \"function\") {\n            // we only have to filter index nodes if the input was a node, as\n            // literal keys should never subsume an index\n            result.index = result.index.filter(n => !n.signature.extends(k));\n        }\n    });\n    return result;\n};\nconst createStructuralWriter = (childStringProp) => (node) => {\n    if (node.props.length || node.index) {\n        const parts = node.index?.map(String) ?? [];\n        node.props.forEach(node => parts.push(node[childStringProp]));\n        if (node.undeclared)\n            parts.push(`+ (undeclared): ${node.undeclared}`);\n        const objectLiteralDescription = `{ ${parts.join(\", \")} }`;\n        return node.sequence ?\n            `${objectLiteralDescription} & ${node.sequence.description}`\n            : objectLiteralDescription;\n    }\n    return node.sequence?.description ?? \"{}\";\n};\nconst structuralDescription = createStructuralWriter(\"description\");\nconst structuralExpression = createStructuralWriter(\"expression\");\nexport const structureImplementation = implementNode({\n    kind: \"structure\",\n    hasAssociatedError: false,\n    normalize: schema => schema,\n    keys: {\n        required: {\n            child: true,\n            parse: constraintKeyParser(\"required\")\n        },\n        optional: {\n            child: true,\n            parse: constraintKeyParser(\"optional\")\n        },\n        index: {\n            child: true,\n            parse: constraintKeyParser(\"index\")\n        },\n        sequence: {\n            child: true,\n            parse: constraintKeyParser(\"sequence\")\n        },\n        undeclared: {\n            parse: behavior => (behavior === \"ignore\" ? undefined : behavior)\n        }\n    },\n    defaults: {\n        description: structuralDescription\n    },\n    intersections: {\n        structure: (l, r, ctx) => {\n            const lInner = { ...l.inner };\n            const rInner = { ...r.inner };\n            if (l.undeclared) {\n                const lKey = l.keyof();\n                const disjointRKeys = r.requiredLiteralKeys.filter(k => !lKey.allows(k));\n                if (disjointRKeys.length) {\n                    return Disjoint.from(\"presence\", ctx.$.keywords.never.raw, r.propsByKey[disjointRKeys[0]].value).withPrefixKey(disjointRKeys[0]);\n                }\n                if (rInner.optional)\n                    rInner.optional = rInner.optional.filter(n => lKey.allows(n.key));\n                if (rInner.index) {\n                    rInner.index = rInner.index.flatMap(n => {\n                        if (n.signature.extends(lKey))\n                            return n;\n                        const indexOverlap = intersectNodesRoot(lKey, n.signature, ctx.$);\n                        if (indexOverlap instanceof Disjoint)\n                            return [];\n                        const normalized = normalizeIndex(indexOverlap, n.value, ctx.$);\n                        if (normalized.required) {\n                            rInner.required =\n                                rInner.required ?\n                                    [...rInner.required, ...normalized.required]\n                                    : normalized.required;\n                        }\n                        return normalized.index ?? [];\n                    });\n                }\n            }\n            if (r.undeclared) {\n                const rKey = r.keyof();\n                const disjointLKeys = l.requiredLiteralKeys.filter(k => !rKey.allows(k));\n                if (disjointLKeys.length) {\n                    return Disjoint.from(\"presence\", l.propsByKey[disjointLKeys[0]].value, ctx.$.keywords.never.raw).withPrefixKey(disjointLKeys[0]);\n                }\n                if (lInner.optional)\n                    lInner.optional = lInner.optional.filter(n => rKey.allows(n.key));\n                if (lInner.index) {\n                    lInner.index = lInner.index.flatMap(n => {\n                        if (n.signature.extends(rKey))\n                            return n;\n                        const indexOverlap = intersectNodesRoot(rKey, n.signature, ctx.$);\n                        if (indexOverlap instanceof Disjoint)\n                            return [];\n                        const normalized = normalizeIndex(indexOverlap, n.value, ctx.$);\n                        if (normalized.required) {\n                            lInner.required =\n                                lInner.required ?\n                                    [...lInner.required, ...normalized.required]\n                                    : normalized.required;\n                        }\n                        return normalized.index ?? [];\n                    });\n                }\n            }\n            const baseInner = {};\n            if (l.undeclared || r.undeclared) {\n                baseInner.undeclared =\n                    l.undeclared === \"reject\" || r.undeclared === \"reject\" ?\n                        \"reject\"\n                        : \"delete\";\n            }\n            return intersectConstraints({\n                kind: \"structure\",\n                baseInner,\n                l: flattenConstraints(lInner),\n                r: flattenConstraints(rInner),\n                roots: [],\n                ctx\n            });\n        }\n    }\n});\n/** extract enumerable named props from an index signature */\nexport const normalizeIndex = (signature, value, $) => {\n    const [enumerableBranches, nonEnumerableBranches] = spliterate(signature.branches, (k) => k.hasKind(\"unit\"));\n    if (!enumerableBranches.length)\n        return { index: $.node(\"index\", { signature, value }) };\n    const normalized = {};\n    normalized.required = enumerableBranches.map(n => $.node(\"required\", { key: n.unit, value }));\n    if (nonEnumerableBranches.length) {\n        normalized.index = $.node(\"index\", {\n            signature: nonEnumerableBranches,\n            value\n        });\n    }\n    return normalized;\n};\n","import { PredicateNode, predicateImplementation } from \"./predicate.js\";\nimport { DivisorNode, divisorImplementation } from \"./refinements/divisor.js\";\nimport { boundClassesByKind, boundImplementationsByKind } from \"./refinements/kinds.js\";\nimport { RegexNode, regexImplementation } from \"./refinements/regex.js\";\nimport { AliasNode, aliasImplementation } from \"./roots/alias.js\";\nimport { DomainNode, domainImplementation } from \"./roots/domain.js\";\nimport { IntersectionNode, intersectionImplementation } from \"./roots/intersection.js\";\nimport { MorphNode, morphImplementation } from \"./roots/morph.js\";\nimport { ProtoNode, protoImplementation } from \"./roots/proto.js\";\nimport { UnionNode, unionImplementation } from \"./roots/union.js\";\nimport { UnitNode, unitImplementation } from \"./roots/unit.js\";\nimport { IndexNode, indexImplementation } from \"./structure/index.js\";\nimport { OptionalNode, optionalImplementation } from \"./structure/optional.js\";\nimport { RequiredNode, requiredImplementation } from \"./structure/required.js\";\nimport { SequenceNode, sequenceImplementation } from \"./structure/sequence.js\";\nimport { StructureNode, structureImplementation } from \"./structure/structure.js\";\nexport const nodeImplementationsByKind = {\n    ...boundImplementationsByKind,\n    alias: aliasImplementation,\n    domain: domainImplementation,\n    unit: unitImplementation,\n    proto: protoImplementation,\n    union: unionImplementation,\n    morph: morphImplementation,\n    intersection: intersectionImplementation,\n    divisor: divisorImplementation,\n    regex: regexImplementation,\n    predicate: predicateImplementation,\n    required: requiredImplementation,\n    optional: optionalImplementation,\n    index: indexImplementation,\n    sequence: sequenceImplementation,\n    structure: structureImplementation\n};\nexport const nodeClassesByKind = {\n    ...boundClassesByKind,\n    alias: AliasNode,\n    domain: DomainNode,\n    unit: UnitNode,\n    proto: ProtoNode,\n    union: UnionNode,\n    morph: MorphNode,\n    intersection: IntersectionNode,\n    divisor: DivisorNode,\n    regex: RegexNode,\n    predicate: PredicateNode,\n    required: RequiredNode,\n    optional: OptionalNode,\n    index: IndexNode,\n    sequence: SequenceNode,\n    structure: StructureNode\n};\n","import { DynamicBase } from \"@arktype/util\";\nimport { arkKind } from \"./shared/utils.js\";\nexport class RootModule extends DynamicBase {\n    // ensure `[arkKind]` is non-enumerable so it doesn't get spread on import/export\n    get [arkKind]() {\n        return \"module\";\n    }\n}\nexport const SchemaModule = RootModule;\n","import { entriesOf, hasDomain, isArray, printable, throwParseError, unset } from \"@arktype/util\";\nimport { nodeClassesByKind, nodeImplementationsByKind } from \"./kinds.js\";\nimport { Disjoint } from \"./shared/disjoint.js\";\nimport { constraintKeys, defaultValueSerializer, isNodeKind, precedenceOfKind } from \"./shared/implement.js\";\nimport { hasArkKind } from \"./shared/utils.js\";\nconst baseKeys = {\n    description: { meta: true }\n};\nexport const schemaKindOf = (schema, allowedKinds) => {\n    const kind = discriminateRootKind(schema);\n    if (allowedKinds && !allowedKinds.includes(kind)) {\n        return throwParseError(`Root of kind ${kind} should be one of ${allowedKinds}`);\n    }\n    return kind;\n};\nconst discriminateRootKind = (schema) => {\n    switch (typeof schema) {\n        case \"string\":\n            return schema[0] === \"$\" ? \"alias\" : \"domain\";\n        case \"function\":\n            return hasArkKind(schema, \"root\") ? schema.kind : \"proto\";\n        case \"object\": {\n            // throw at end of function\n            if (schema === null)\n                break;\n            if (\"morphs\" in schema)\n                return \"morph\";\n            if (\"branches\" in schema || isArray(schema))\n                return \"union\";\n            if (\"unit\" in schema)\n                return \"unit\";\n            if (\"alias\" in schema)\n                return \"alias\";\n            const schemaKeys = Object.keys(schema);\n            if (schemaKeys.length === 0 || schemaKeys.some(k => k in constraintKeys))\n                return \"intersection\";\n            if (\"proto\" in schema)\n                return \"proto\";\n            if (\"domain\" in schema)\n                return \"domain\";\n        }\n    }\n    return throwParseError(`${printable(schema)} is not a valid type schema`);\n};\nconst nodeCache = {};\nconst serializeListableChild = (listableNode) => isArray(listableNode) ?\n    listableNode.map(node => node.collapsibleJson)\n    : listableNode.collapsibleJson;\nexport const parseNode = (kind, ctx) => {\n    const impl = nodeImplementationsByKind[kind];\n    const inner = {};\n    // ensure node entries are parsed in order of precedence, with non-children\n    // parsed first\n    const schemaEntries = entriesOf(ctx.schema).sort(([lKey], [rKey]) => isNodeKind(lKey) ?\n        isNodeKind(rKey) ? precedenceOfKind(lKey) - precedenceOfKind(rKey)\n            : 1\n        : isNodeKind(rKey) ? -1\n            : lKey < rKey ? -1\n                : 1);\n    const children = [];\n    for (const entry of schemaEntries) {\n        const k = entry[0];\n        const keyImpl = impl.keys[k] ?? baseKeys[k];\n        if (!keyImpl)\n            return throwParseError(`Key ${k} is not valid on ${kind} schema`);\n        const v = keyImpl.parse ? keyImpl.parse(entry[1], ctx) : entry[1];\n        if (v !== unset && (v !== undefined || keyImpl.preserveUndefined))\n            inner[k] = v;\n    }\n    const entries = entriesOf(inner);\n    let json = {};\n    let typeJson = {};\n    entries.forEach(([k, v]) => {\n        const listableNode = v;\n        const keyImpl = impl.keys[k] ?? baseKeys[k];\n        const serialize = keyImpl.serialize ??\n            (keyImpl.child ? serializeListableChild : defaultValueSerializer);\n        json[k] = serialize(listableNode);\n        if (keyImpl.child) {\n            if (isArray(listableNode))\n                children.push(...listableNode);\n            else\n                children.push(listableNode);\n        }\n        if (!keyImpl.meta)\n            typeJson[k] = json[k];\n    });\n    if (impl.finalizeJson) {\n        json = impl.finalizeJson(json);\n        typeJson = impl.finalizeJson(typeJson);\n    }\n    let collapsibleJson = json;\n    const collapsibleKeys = Object.keys(collapsibleJson);\n    if (collapsibleKeys.length === 1 &&\n        collapsibleKeys[0] === impl.collapsibleKey) {\n        collapsibleJson = collapsibleJson[impl.collapsibleKey];\n        if (\n        // if the collapsibleJson is still an object\n        hasDomain(collapsibleJson, \"object\") &&\n            // and the JSON did not include any implied keys\n            Object.keys(json).length === 1) {\n            // we can replace it with its collapsed value\n            json = collapsibleJson;\n            typeJson = collapsibleJson;\n        }\n    }\n    const innerHash = JSON.stringify({ kind, ...json });\n    if (ctx.reduceTo) {\n        nodeCache[innerHash] = ctx.reduceTo;\n        return ctx.reduceTo;\n    }\n    const typeHash = JSON.stringify({ kind, ...typeJson });\n    if (impl.reduce && !ctx.prereduced) {\n        const reduced = impl.reduce(inner, ctx.$);\n        if (reduced) {\n            if (reduced instanceof Disjoint)\n                return reduced.throw();\n            // if we're defining the resolution of an alias and the result is\n            // reduced to another node, add the alias to that node if it doesn't\n            // already have one.\n            if (ctx.alias)\n                reduced.alias ??= ctx.alias;\n            // we can't cache this reduction for now in case the reduction involved\n            // impliedSiblings\n            return reduced;\n        }\n    }\n    // we have to wait until after reduction to return a cached entry,\n    // since reduction can add impliedSiblings\n    if (nodeCache[innerHash])\n        return nodeCache[innerHash];\n    const attachments = {\n        id: ctx.id,\n        kind,\n        impl,\n        inner,\n        entries,\n        json: json,\n        typeJson: typeJson,\n        collapsibleJson: collapsibleJson,\n        children,\n        innerHash,\n        typeHash,\n        $: ctx.$\n    };\n    if (ctx.alias)\n        attachments.alias = ctx.alias;\n    for (const k in inner) {\n        if (k !== \"description\" && k !== \"in\" && k !== \"out\")\n            attachments[k] = inner[k];\n    }\n    const node = new nodeClassesByKind[kind](attachments);\n    nodeCache[innerHash] = node;\n    return node;\n};\n","import { CompiledFunction } from \"@arktype/util\";\nexport class NodeCompiler extends CompiledFunction {\n    traversalKind;\n    path = [];\n    discriminants = [];\n    constructor(traversalKind) {\n        super(\"data\", \"ctx\");\n        this.traversalKind = traversalKind;\n    }\n    invoke(node, opts) {\n        const arg = opts?.arg ?? this.data;\n        if (this.requiresContextFor(node))\n            return `${this.reference(node, opts)}(${arg}, ${this.ctx})`;\n        return `${this.reference(node, opts)}(${arg})`;\n    }\n    reference(node, opts) {\n        const invokedKind = opts?.kind ?? this.traversalKind;\n        const base = `this.${node.id}${invokedKind}`;\n        return opts?.bind ? `${base}.bind(${opts?.bind})` : base;\n    }\n    requiresContextFor(node) {\n        return this.traversalKind === \"Apply\" || node.allowsRequiresContext;\n    }\n    initializeErrorCount() {\n        return this.const(\"errorCount\", \"ctx.currentErrorCount\");\n    }\n    returnIfFail() {\n        return this.if(\"ctx.currentErrorCount > errorCount\", () => this.return());\n    }\n    returnIfFailFast() {\n        return this.if(\"ctx.failFast && ctx.currentErrorCount > errorCount\", () => this.return());\n    }\n    traverseKey(keyExpression, accessExpression, node) {\n        const requiresContext = this.requiresContextFor(node);\n        if (requiresContext)\n            this.line(`${this.ctx}.path.push(${keyExpression})`);\n        this.check(node, {\n            arg: accessExpression\n        });\n        if (requiresContext)\n            this.line(`${this.ctx}.path.pop()`);\n        return this;\n    }\n    check(node, opts) {\n        return this.traversalKind === \"Allows\" ?\n            this.if(`!${this.invoke(node, opts)}`, () => this.return(false))\n            : this.line(this.invoke(node, opts));\n    }\n    writeMethod(name) {\n        return `${name}(${this.argNames.join(\", \")}){\\n${this.body}    }\\n`;\n    }\n}\n","var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {\n    var useValue = arguments.length > 2;\n    for (var i = 0; i < initializers.length; i++) {\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n    }\n    return useValue ? value : void 0;\n};\nvar __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n    var _, done = false;\n    for (var i = decorators.length - 1; i >= 0; i--) {\n        var context = {};\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n        if (kind === \"accessor\") {\n            if (result === void 0) continue;\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n            if (_ = accept(result.get)) descriptor.get = _;\n            if (_ = accept(result.set)) descriptor.set = _;\n            if (_ = accept(result.init)) initializers.unshift(_);\n        }\n        else if (_ = accept(result)) {\n            if (kind === \"field\") initializers.unshift(_);\n            else descriptor[key] = _;\n        }\n    }\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\n    done = true;\n};\nimport { CompiledFunction, DynamicBase, bound, envHasCsp, flatMorph, hasDomain, isArray, printable, throwInternalError, throwParseError } from \"@arktype/util\";\nimport { globalConfig, mergeConfigs } from \"./config.js\";\nimport { validateUninstantiatedGenericNode } from \"./generic.js\";\nimport { nodeImplementationsByKind } from \"./kinds.js\";\nimport { RootModule } from \"./module.js\";\nimport { parseNode, schemaKindOf } from \"./parse.js\";\nimport { normalizeAliasSchema } from \"./roots/alias.js\";\nimport { NodeCompiler } from \"./shared/compile.js\";\nimport { arkKind, hasArkKind, isNode } from \"./shared/utils.js\";\nexport const defaultConfig = Object.assign(flatMorph(nodeImplementationsByKind, (kind, implementation) => [\n    kind,\n    implementation.defaults\n]), {\n    jitless: envHasCsp(),\n    registerKeywords: false,\n    prereducedAliases: false\n});\nconst nonInheritedKeys = [\n    \"registerKeywords\",\n    \"prereducedAliases\"\n];\nexport const extendConfig = (base, extension) => {\n    if (!extension)\n        return base;\n    const result = mergeConfigs(base, extension);\n    nonInheritedKeys.forEach(k => {\n        if (!(k in extension))\n            delete result[k];\n    });\n    return result;\n};\nexport const resolveConfig = (config) => extendConfig(extendConfig(defaultConfig, globalConfig), config);\nconst schemaBranchesOf = (schema) => isArray(schema) ? schema\n    : \"branches\" in schema && isArray(schema.branches) ? schema.branches\n        : undefined;\nconst throwMismatchedNodeRootError = (expected, actual) => throwParseError(`Node of kind ${actual} is not valid as a ${expected} definition`);\nexport const writeDuplicateAliasError = (alias) => `#${alias} duplicates public alias ${alias}`;\nconst nodeCountsByPrefix = {};\nconst nodesById = {};\nlet scopeCount = 0;\nconst scopesById = {};\nlet RawRootScope = (() => {\n    let _instanceExtraInitializers = [];\n    let _schema_decorators;\n    let _defineRoot_decorators;\n    let _units_decorators;\n    return class RawRootScope {\n        static {\n            const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(null) : void 0;\n            _schema_decorators = [bound];\n            _defineRoot_decorators = [bound];\n            _units_decorators = [bound];\n            __esDecorate(this, null, _schema_decorators, { kind: \"method\", name: \"schema\", static: false, private: false, access: { has: obj => \"schema\" in obj, get: obj => obj.schema }, metadata: _metadata }, null, _instanceExtraInitializers);\n            __esDecorate(this, null, _defineRoot_decorators, { kind: \"method\", name: \"defineRoot\", static: false, private: false, access: { has: obj => \"defineRoot\" in obj, get: obj => obj.defineRoot }, metadata: _metadata }, null, _instanceExtraInitializers);\n            __esDecorate(this, null, _units_decorators, { kind: \"method\", name: \"units\", static: false, private: false, access: { has: obj => \"units\" in obj, get: obj => obj.units }, metadata: _metadata }, null, _instanceExtraInitializers);\n            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });\n        }\n        config = __runInitializers(this, _instanceExtraInitializers);\n        resolvedConfig;\n        id = `$${++scopeCount}`;\n        [arkKind] = \"scope\";\n        referencesById = {};\n        references = [];\n        resolutions = {};\n        json = {};\n        exportedNames;\n        aliases = {};\n        resolved = false;\n        // these allow builtin types to be accessed during parsing without cyclic imports\n        // they are populated as each scope is parsed with `registerKeywords` in its config\n        /** @internal */\n        static keywords = {};\n        /** @internal */\n        get keywords() {\n            return RawRootScope.keywords;\n        }\n        static ambient;\n        get ambient() {\n            return this.constructor.ambient;\n        }\n        constructor(\n        /** The set of names defined at the root-level of the scope mapped to their\n         * corresponding definitions.**/\n        def, config) {\n            this.config = config ?? {};\n            this.resolvedConfig = resolveConfig(config);\n            this.exportedNames = Object.keys(def).filter(k => {\n                if (k[0] === \"#\") {\n                    const name = k.slice(1);\n                    if (name in this.aliases)\n                        throwParseError(writeDuplicateAliasError(name));\n                    this.aliases[name] = def[k];\n                    return false;\n                }\n                if (k in this.aliases)\n                    throwParseError(writeDuplicateAliasError(k));\n                this.aliases[k] = def[k];\n                return true;\n            });\n            if (this.ambient) {\n                // ensure exportedResolutions is populated\n                this.ambient.export();\n                // TODO: generics and modules\n                this.resolutions = flatMorph(this.ambient.resolutions, (alias, resolution) => [\n                    alias,\n                    hasArkKind(resolution, \"root\") ?\n                        resolution.bindScope(this)\n                        : resolution\n                ]);\n            }\n            scopesById[this.id] = this;\n        }\n        get raw() {\n            return this;\n        }\n        schema(def, opts) {\n            return this.node(schemaKindOf(def), def, opts);\n        }\n        defineRoot(def) {\n            return def;\n        }\n        units(values, opts) {\n            const uniqueValues = [];\n            for (const value of values)\n                if (!uniqueValues.includes(value))\n                    uniqueValues.push(value);\n            const branches = uniqueValues.map(unit => this.node(\"unit\", { unit }, opts));\n            return this.node(\"union\", branches, {\n                ...opts,\n                prereduced: true\n            });\n        }\n        lazyResolutions = [];\n        lazilyResolve(resolve, syntheticAlias) {\n            if (!syntheticAlias) {\n                nodeCountsByPrefix.synthetic ??= 0;\n                syntheticAlias = `synthetic${++nodeCountsByPrefix.synthetic}`;\n            }\n            const node = this.node(\"alias\", {\n                alias: syntheticAlias,\n                resolve\n            }, { prereduced: true });\n            this.lazyResolutions.push(node);\n            return node;\n        }\n        node = (((kinds, nodeSchema, opts) => {\n            let kind = typeof kinds === \"string\" ? kinds : schemaKindOf(nodeSchema, kinds);\n            let schema = nodeSchema;\n            if (isNode(schema) && schema.kind === kind)\n                return schema.bindScope(this);\n            if (kind === \"alias\" && !opts?.prereduced) {\n                const resolution = this.resolveRoot(normalizeAliasSchema(schema).alias);\n                schema = resolution;\n                kind = resolution.kind;\n            }\n            else if (kind === \"union\" && hasDomain(schema, \"object\")) {\n                const branches = schemaBranchesOf(schema);\n                if (branches?.length === 1) {\n                    schema = branches[0];\n                    kind = schemaKindOf(schema);\n                }\n            }\n            const impl = nodeImplementationsByKind[kind];\n            const normalizedSchema = impl.normalize?.(schema) ?? schema;\n            // check again after normalization in case a node is a valid collapsed\n            // schema for the kind (e.g. sequence can collapse to element accepting a Node)\n            if (isNode(normalizedSchema)) {\n                return normalizedSchema.kind === kind ?\n                    normalizedSchema.bindScope(this)\n                    : throwMismatchedNodeRootError(kind, normalizedSchema.kind);\n            }\n            const prefix = opts?.alias ?? kind;\n            nodeCountsByPrefix[prefix] ??= 0;\n            const id = `${prefix}${++nodeCountsByPrefix[prefix]}`;\n            const node = parseNode(kind, {\n                ...opts,\n                id,\n                $: this,\n                schema: normalizedSchema\n            }).bindScope(this);\n            nodesById[id] = node;\n            if (this.resolved) {\n                // this node was not part of the original scope, so compile an anonymous scope\n                // including only its references\n                if (!this.resolvedConfig.jitless)\n                    bindCompiledScope(node.references);\n            }\n            else {\n                // we're still parsing the scope itself, so defer compilation but\n                // add the node as a reference\n                Object.assign(this.referencesById, node.referencesById);\n            }\n            return node;\n        })).bind(this);\n        parseRoot(def, opts) {\n            return this.schema(def, opts);\n        }\n        resolveRoot(name) {\n            return (this.maybeResolveRoot(name) ??\n                throwParseError(writeUnresolvableMessage(name)));\n        }\n        maybeResolveRoot(name) {\n            const result = this.maybeResolveGenericOrRoot(name);\n            if (hasArkKind(result, \"generic\"))\n                return;\n            return result;\n        }\n        maybeResolveGenericOrRoot(name) {\n            const resolution = this.maybeResolve(name);\n            if (hasArkKind(resolution, \"module\"))\n                return throwParseError(writeMissingSubmoduleAccessMessage(name));\n            return resolution;\n        }\n        preparseRoot(def) {\n            return def;\n        }\n        maybeResolve(name) {\n            const resolution = this.maybeShallowResolve(name);\n            return typeof resolution === \"string\" ?\n                this.node(\"alias\", { alias: resolution }, { prereduced: true })\n                : resolution;\n        }\n        maybeShallowResolve(name) {\n            const cached = this.resolutions[name];\n            if (cached)\n                return cached;\n            let def = this.aliases[name];\n            if (!def)\n                return this.maybeResolveSubalias(name);\n            def = this.preparseRoot(def);\n            if (hasArkKind(def, \"generic\"))\n                return (this.resolutions[name] = validateUninstantiatedGenericNode(def));\n            if (hasArkKind(def, \"module\"))\n                return (this.resolutions[name] = def);\n            this.resolutions[name] = name;\n            return (this.resolutions[name] = this.parseRoot(def));\n        }\n        /** If name is a valid reference to a submodule alias, return its resolution  */\n        maybeResolveSubalias(name) {\n            return resolveSubalias(this.aliases, name);\n        }\n        import(...names) {\n            return new RootModule(flatMorph(this.export(...names), (alias, value) => [\n                `#${alias}`,\n                value\n            ]));\n        }\n        _exportedResolutions;\n        _exports;\n        export(...names) {\n            if (!this._exports) {\n                this._exports = {};\n                for (const name of this.exportedNames)\n                    this._exports[name] = this.maybeResolve(name);\n                this.lazyResolutions.forEach(node => node.resolution);\n                this._exportedResolutions = resolutionsOfModule(this, this._exports);\n                // TODO: add generic json\n                Object.assign(this.json, flatMorph(this._exportedResolutions, (k, v) => hasArkKind(v, \"root\") ? [k, v.json] : []));\n                Object.assign(this.resolutions, this._exportedResolutions);\n                if (this.config.registerKeywords)\n                    Object.assign(RawRootScope.keywords, this._exportedResolutions);\n                this.references = Object.values(this.referencesById);\n                if (!this.resolvedConfig.jitless)\n                    bindCompiledScope(this.references);\n                this.resolved = true;\n            }\n            const namesToExport = names.length ? names : this.exportedNames;\n            return new RootModule(flatMorph(namesToExport, (_, name) => [\n                name,\n                this._exports[name]\n            ]));\n        }\n        resolve(name) {\n            return this.export()[name];\n        }\n    };\n})();\nexport { RawRootScope };\nconst resolveSubalias = (base, name) => {\n    const dotIndex = name.indexOf(\".\");\n    if (dotIndex === -1)\n        return;\n    const dotPrefix = name.slice(0, dotIndex);\n    const prefixSchema = base[dotPrefix];\n    // if the name includes \".\", but the prefix is not an alias, it\n    // might be something like a decimal literal, so just fall through to return\n    if (prefixSchema === undefined)\n        return;\n    if (!hasArkKind(prefixSchema, \"module\"))\n        return throwParseError(writeNonSubmoduleDotMessage(dotPrefix));\n    const subalias = name.slice(dotIndex + 1);\n    const resolution = prefixSchema[subalias];\n    // if the first part of name is a submodule but the suffix is\n    // unresolvable, we can throw immediately\n    if (resolution === undefined) {\n        if (hasArkKind(resolution, \"module\"))\n            return resolveSubalias(resolution, subalias);\n        return throwParseError(writeUnresolvableMessage(name));\n    }\n    if (hasArkKind(resolution, \"root\") || hasArkKind(resolution, \"generic\"))\n        return resolution;\n    throwInternalError(`Unexpected resolution for alias '${name}': ${printable(resolution)}`);\n};\nexport const schemaScope = (aliases, config) => new RootScope(aliases, config);\nexport const RootScope = RawRootScope;\nexport const root = new RootScope({});\nexport const schema = root.schema;\nexport const node = root.node;\nexport const defineRoot = root.defineRoot;\nexport const units = root.units;\nexport const rawRoot = root.raw.schema;\nexport const rawNode = root.raw.node;\nexport const defineRawRoot = root.raw.defineRoot;\nexport const rawUnits = root.raw.units;\nexport class RawRootModule extends DynamicBase {\n}\nconst resolutionsOfModule = ($, typeSet) => {\n    const result = {};\n    for (const k in typeSet) {\n        const v = typeSet[k];\n        if (hasArkKind(v, \"module\")) {\n            const innerResolutions = resolutionsOfModule($, v);\n            const prefixedResolutions = flatMorph(innerResolutions, (innerK, innerV) => [`${k}.${innerK}`, innerV]);\n            Object.assign(result, prefixedResolutions);\n        }\n        else if (hasArkKind(v, \"generic\"))\n            result[k] = v;\n        else if (hasArkKind(v, \"root\"))\n            result[k] = v;\n        else\n            throwInternalError(`Unexpected scope resolution ${printable(v)}`);\n    }\n    return result;\n};\nexport const writeUnresolvableMessage = (token) => `'${token}' is unresolvable`;\nexport const writeNonSubmoduleDotMessage = (name) => `'${name}' must reference a module to be accessed using dot syntax`;\nexport const writeMissingSubmoduleAccessMessage = (name) => `Reference to submodule '${name}' must specify an alias`;\nexport const bindCompiledScope = (references) => {\n    const compiledTraversals = compileScope(references);\n    for (const node of references) {\n        if (node.jit) {\n            // if node has already been bound to another scope or anonymous type, don't rebind it\n            continue;\n        }\n        node.jit = true;\n        node.traverseAllows =\n            compiledTraversals[`${node.id}Allows`].bind(compiledTraversals);\n        if (node.isRoot() && !node.allowsRequiresContext) {\n            // if the reference doesn't require context, we can assign over\n            // it directly to avoid having to initialize it\n            node.allows = node.traverseAllows;\n        }\n        node.traverseApply =\n            compiledTraversals[`${node.id}Apply`].bind(compiledTraversals);\n    }\n};\nconst compileScope = (references) => new CompiledFunction()\n    .block(\"return\", js => {\n    references.forEach(node => {\n        const allowsCompiler = new NodeCompiler(\"Allows\").indent();\n        node.compile(allowsCompiler);\n        const applyCompiler = new NodeCompiler(\"Apply\").indent();\n        node.compile(applyCompiler);\n        js.line(`${allowsCompiler.writeMethod(`${node.id}Allows`)},`).line(`${applyCompiler.writeMethod(`${node.id}Apply`)},`);\n    });\n    return js;\n})\n    .compile()();\n","import { Callable } from \"@arktype/util\";\nimport { arkKind } from \"./shared/utils.js\";\nexport const validateUninstantiatedGenericNode = (g) => {\n    g.$.schema(g.def, {\n    // // TODO: probably don't need raw once this is fixed.\n    // args: flatMorph(g.params, (_, name) => [name, g.$.raw.keywords.unknown])\n    });\n    return g;\n};\nexport class GenericRoot extends Callable {\n    params;\n    def;\n    $;\n    [arkKind] = \"generic\";\n    constructor(params, def, $) {\n        super((...args) => {\n            args;\n            // const argNodes: Record<string, RawRoot> = flatMorph(\n            // \tparams,\n            // \t(i, param) => [param, $.schema(args[i])]\n            // ) as never\n            // { args: argNodes }\n            return $.schema(def);\n        });\n        this.params = params;\n        this.def = def;\n        this.$ = $;\n    }\n}\n","import { schemaScope } from \"../scope.js\";\nexport const tsKeywords = schemaScope({\n    any: {},\n    bigint: \"bigint\",\n    // since we know this won't be reduced, it can be safely cast to a union\n    boolean: [{ unit: false }, { unit: true }],\n    false: { unit: false },\n    never: [],\n    null: { unit: null },\n    number: \"number\",\n    object: \"object\",\n    string: \"string\",\n    symbol: \"symbol\",\n    true: { unit: true },\n    unknown: {},\n    void: { unit: undefined },\n    undefined: { unit: undefined }\n}, { prereducedAliases: true, registerKeywords: true }).export();\n","import { root, schemaScope } from \"../scope.js\";\n// these are needed to create some internal types\nimport { arrayIndexMatcher } from \"../structure/shared.js\";\nimport \"./tsKeywords.js\";\nexport const internalKeywords = schemaScope({\n    lengthBoundable: [\"string\", Array],\n    propertyKey: [\"string\", \"symbol\"],\n    nonNegativeIntegerString: { domain: \"string\", regex: arrayIndexMatcher }\n}, {\n    prereducedAliases: true,\n    registerKeywords: true\n}).export();\n// reduce union of all possible values reduces to unknown\nroot.node(\"union\", {\n    branches: [\n        \"string\",\n        \"number\",\n        \"object\",\n        \"bigint\",\n        \"symbol\",\n        { unit: true },\n        { unit: false },\n        { unit: null },\n        { unit: undefined }\n    ]\n}, { reduceTo: root.node(\"intersection\", {}, { prereduced: true }) });\n","import { schemaScope } from \"../scope.js\";\nexport const jsObjects = schemaScope({\n    Array,\n    Function,\n    Date,\n    Error,\n    Map,\n    RegExp,\n    Set,\n    WeakMap,\n    WeakSet,\n    Promise\n}, { prereducedAliases: true, registerKeywords: true }).export();\n","import { root } from \"../../scope.js\";\nexport const defineRegex = (regex, description) => root.defineRoot({\n    domain: \"string\",\n    regex: {\n        rule: regex.source,\n        flags: regex.flags,\n        description\n    }\n});\n","import { isWellFormedInteger, wellFormedIntegerMatcher, wellFormedNumberMatcher } from \"@arktype/util\";\nimport { root, schemaScope } from \"../scope.js\";\nimport { tryParseDatePattern } from \"./utils/date.js\";\nimport { defineRegex } from \"./utils/regex.js\";\nconst number = root.defineRoot({\n    in: defineRegex(wellFormedNumberMatcher, \"a well-formed numeric string\"),\n    morphs: (s) => Number.parseFloat(s)\n});\nconst integer = root.defineRoot({\n    in: defineRegex(wellFormedIntegerMatcher, \"a well-formed integer string\"),\n    morphs: (s, ctx) => {\n        if (!isWellFormedInteger(s))\n            return ctx.error(\"a well-formed integer string\");\n        const parsed = Number.parseInt(s);\n        return Number.isSafeInteger(parsed) ? parsed : (ctx.error(\"an integer in the range Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER\"));\n    }\n});\nconst url = root.defineRoot({\n    in: \"string\",\n    morphs: (s, ctx) => {\n        try {\n            return new URL(s);\n        }\n        catch {\n            return ctx.error(\"a valid URL\");\n        }\n    }\n});\nconst json = root.defineRoot({\n    in: \"string\",\n    morphs: (s, ctx) => {\n        try {\n            return JSON.parse(s);\n        }\n        catch {\n            return ctx.error(\"a valid JSON string\");\n        }\n    }\n});\nconst date = root.defineRoot({\n    in: \"string\",\n    morphs: (s, ctx) => {\n        const result = tryParseDatePattern(s);\n        return typeof result === \"string\" ? ctx.error(result) : result;\n    }\n});\nexport const parsing = schemaScope({\n    url,\n    number,\n    integer,\n    date,\n    json\n}).export();\n","const dayDelimiterMatcher = /^[./-]$/;\n// ISO 8601 date/time modernized from https://github.com/validatorjs/validator.js/blob/master/src/lib/isISO8601.js\n// Based on https://tc39.es/ecma262/#sec-date-time-string-format, the T\n// delimiter for date/time is mandatory. Regex from validator.js strict matcher:\nconst iso8601Matcher = /^([+-]?\\d{4}(?!\\d{2}\\b))((-?)((0[1-9]|1[0-2])(\\3([12]\\d|0[1-9]|3[01]))?|W([0-4]\\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\\d|[12]\\d{2}|3([0-5]\\d|6[1-6])))([T]((([01]\\d|2[0-3])((:?)[0-5]\\d)?|24:?00)([.,]\\d+(?!:))?)?(\\17[0-5]\\d([.,]\\d+)?)?([zZ]|([+-])([01]\\d|2[0-3]):?([0-5]\\d)?)?)?)?$/;\nconst isValidDateInstance = (date) => !Number.isNaN(+date);\nconst writeFormattedExpected = (format) => `a ${format}-formatted date`;\nexport const tryParseDatePattern = (data, opts) => {\n    if (!opts?.format) {\n        const result = new Date(data);\n        return isValidDateInstance(result) ? result : \"a valid date\";\n    }\n    if (opts.format === \"iso8601\") {\n        return iso8601Matcher.test(data) ?\n            new Date(data)\n            : writeFormattedExpected(\"iso8601\");\n    }\n    const dataParts = data.split(dayDelimiterMatcher);\n    // will be the first delimiter matched, if there is one\n    const delimiter = data[dataParts[0].length];\n    const formatParts = delimiter ? opts.format.split(delimiter) : [opts.format];\n    if (dataParts.length !== formatParts.length)\n        return writeFormattedExpected(opts.format);\n    const parsedParts = {};\n    for (let i = 0; i < formatParts.length; i++) {\n        if (dataParts[i].length !== formatParts[i].length &&\n            // if format is \"m\" or \"d\", data is allowed to be 1 or 2 characters\n            !(formatParts[i].length === 1 && dataParts[i].length === 2))\n            return writeFormattedExpected(opts.format);\n        parsedParts[formatParts[i][0]] = dataParts[i];\n    }\n    const date = new Date(`${parsedParts.m}/${parsedParts.d}/${parsedParts.y}`);\n    if (`${date.getDate()}` === parsedParts.d)\n        return date;\n    return writeFormattedExpected(opts.format);\n};\n","import { root } from \"../../scope.js\";\nimport { defineRegex } from \"./regex.js\";\n// Based on https://github.com/validatorjs/validator.js/blob/master/src/lib/isIP.js\nconst ipv4Segment = \"(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\";\nconst ipv4Address = `(${ipv4Segment}[.]){3}${ipv4Segment}`;\nconst ipv4Matcher = new RegExp(`^${ipv4Address}$`);\nexport const ipv4 = defineRegex(ipv4Matcher, \"a valid IPv4 address\");\nconst ipv6Segment = \"(?:[0-9a-fA-F]{1,4})\";\nconst ipv6Matcher = new RegExp(\"^(\" +\n    `(?:${ipv6Segment}:){7}(?:${ipv6Segment}|:)|` +\n    `(?:${ipv6Segment}:){6}(?:${ipv4Address}|:${ipv6Segment}|:)|` +\n    `(?:${ipv6Segment}:){5}(?::${ipv4Address}|(:${ipv6Segment}){1,2}|:)|` +\n    `(?:${ipv6Segment}:){4}(?:(:${ipv6Segment}){0,1}:${ipv4Address}|(:${ipv6Segment}){1,3}|:)|` +\n    `(?:${ipv6Segment}:){3}(?:(:${ipv6Segment}){0,2}:${ipv4Address}|(:${ipv6Segment}){1,4}|:)|` +\n    `(?:${ipv6Segment}:){2}(?:(:${ipv6Segment}){0,3}:${ipv4Address}|(:${ipv6Segment}){1,5}|:)|` +\n    `(?:${ipv6Segment}:){1}(?:(:${ipv6Segment}){0,4}:${ipv4Address}|(:${ipv6Segment}){1,6}|:)|` +\n    `(?::((?::${ipv6Segment}){0,5}:${ipv4Address}|(?::${ipv6Segment}){1,7}|:))` +\n    \")(%[0-9a-zA-Z-.:]{1,})?$\");\nexport const ipv6 = defineRegex(ipv6Matcher, \"a valid IPv6 address\");\nexport const ip = root.defineRoot([ipv4, ipv6]);\n","import { root, schemaScope } from \"../scope.js\";\nimport { creditCardMatcher, isLuhnValid } from \"./utils/creditCard.js\";\nimport { ip } from \"./utils/ip.js\";\nimport { defineRegex } from \"./utils/regex.js\";\n// Non-trivial expressions should have an explanation or attribution\nconst url = root.defineRoot({\n    domain: \"string\",\n    predicate: {\n        predicate: (s) => {\n            try {\n                new URL(s);\n            }\n            catch {\n                return false;\n            }\n            return true;\n        },\n        description: \"a valid URL\"\n    }\n});\n// https://www.regular-expressions.info/email.html\nconst emailMatcher = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$/;\nconst email = defineRegex(emailMatcher, \"a valid email\");\nconst uuidMatcher = /^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$/;\n// https://github.com/validatorjs/validator.js/blob/master/src/lib/isUUID.js\nconst uuid = defineRegex(uuidMatcher, \"a valid UUID\");\nconst semverMatcher = /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/;\n// https://semver.org/\nconst semver = defineRegex(semverMatcher, \"a valid semantic version (see https://semver.org/)\");\nconst creditCard = root.defineRoot({\n    domain: \"string\",\n    regex: {\n        rule: creditCardMatcher.source,\n        description: \"a valid credit card number\"\n    },\n    predicate: {\n        predicate: isLuhnValid,\n        description: \"a valid credit card number\"\n    }\n});\nexport const validation = schemaScope({\n    alpha: defineRegex(/^[A-Za-z]*$/, \"only letters\"),\n    alphanumeric: defineRegex(/^[A-Za-z\\d]*$/, \"only letters and digits\"),\n    lowercase: defineRegex(/^[a-z]*$/, \"only lowercase letters\"),\n    uppercase: defineRegex(/^[A-Z]*$/, \"only uppercase letters\"),\n    creditCard,\n    email,\n    uuid,\n    url,\n    semver,\n    ip,\n    integer: {\n        domain: \"number\",\n        divisor: 1\n    }\n}, { prereducedAliases: true }).export();\n","// https://github.com/validatorjs/validator.js/blob/master/src/lib/isLuhnNumber.js\nexport const isLuhnValid = (creditCardInput) => {\n    const sanitized = creditCardInput.replace(/[- ]+/g, \"\");\n    let sum = 0;\n    let digit;\n    let tmpNum;\n    let shouldDouble = false;\n    for (let i = sanitized.length - 1; i >= 0; i--) {\n        digit = sanitized.substring(i, i + 1);\n        tmpNum = Number.parseInt(digit, 10);\n        if (shouldDouble) {\n            tmpNum *= 2;\n            if (tmpNum >= 10)\n                sum += (tmpNum % 10) + 1;\n            else\n                sum += tmpNum;\n        }\n        else\n            sum += tmpNum;\n        shouldDouble = !shouldDouble;\n    }\n    return !!(sum % 10 === 0 ? sanitized : false);\n};\n// https://github.com/validatorjs/validator.js/blob/master/src/lib/isCreditCard.js\nexport const creditCardMatcher = /^(?:4[0-9]{12}(?:[0-9]{3,6})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12,15}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11}|6[27][0-9]{14}|^(81[0-9]{14,17}))$/;\n","import { RawRootScope, schemaScope } from \"../scope.js\";\n// the import ordering here is important so builtin keywords can be resolved\n// and used to bootstrap nodes with constraints\nimport { tsKeywords } from \"./tsKeywords.js\";\nimport { jsObjects } from \"./jsObjects.js\";\nimport { parsing } from \"./parsing.js\";\nimport { validation } from \"./validation.js\";\nexport const ambientRootScope = schemaScope({\n    ...tsKeywords,\n    ...jsObjects,\n    ...validation,\n    parse: parsing\n    // TODO: remove cast\n});\nRawRootScope.ambient = ambientRootScope.raw;\nexport const keywordNodes = ambientRootScope.export();\n","import { arkKind } from \"@arktype/schema\";\nimport { Callable } from \"@arktype/util\";\nexport class Generic extends Callable {\n    params;\n    def;\n    $;\n    [arkKind] = \"generic\";\n    constructor(params, def, \n    // TODO: should be Scope<$>, but breaks inference\n    $) {\n        super((...args) => {\n            // const argNodes = flatMorph(params, (i, param: string) => [\n            // \tparam,\n            // \t$.parseRoot(args[i])\n            // ])\n            // { args: argNodes }\n            args;\n            return $.parseRoot(def);\n        });\n        this.params = params;\n        this.def = def;\n        this.$ = $;\n    }\n}\n","import { isKeyOf } from \"@arktype/util\";\nexport class Scanner {\n    chars;\n    i;\n    constructor(def) {\n        this.chars = [...def];\n        this.i = 0;\n    }\n    /** Get lookahead and advance scanner by one */\n    shift() {\n        return (this.chars[this.i++] ?? \"\");\n    }\n    get lookahead() {\n        return (this.chars[this.i] ?? \"\");\n    }\n    get nextLookahead() {\n        return this.chars[this.i + 1] ?? \"\";\n    }\n    get length() {\n        return this.chars.length;\n    }\n    shiftUntil(condition) {\n        let shifted = \"\";\n        while (this.lookahead) {\n            if (condition(this, shifted)) {\n                if (shifted[shifted.length - 1] === Scanner.escapeToken)\n                    shifted = shifted.slice(0, -1);\n                else\n                    break;\n            }\n            shifted += this.shift();\n        }\n        return shifted;\n    }\n    shiftUntilNextTerminator() {\n        this.shiftUntilNonWhitespace();\n        return this.shiftUntil(Scanner.lookaheadIsTerminator);\n    }\n    shiftUntilNonWhitespace() {\n        return this.shiftUntil(Scanner.lookaheadIsNotWhitespace);\n    }\n    jumpToIndex(i) {\n        this.i = i < 0 ? this.length + i : i;\n    }\n    get location() {\n        return this.i;\n    }\n    get unscanned() {\n        return this.chars.slice(this.i, this.length).join(\"\");\n    }\n    get scanned() {\n        return this.chars.slice(0, this.i).join(\"\");\n    }\n    sliceChars(start, end) {\n        return this.chars.slice(start, end).join(\"\");\n    }\n    lookaheadIs(char) {\n        return this.lookahead === char;\n    }\n    lookaheadIsIn(tokens) {\n        return this.lookahead in tokens;\n    }\n}\n(function (Scanner) {\n    Scanner.lookaheadIsTerminator = (scanner) => scanner.lookahead in Scanner.terminatingChars;\n    Scanner.lookaheadIsNotWhitespace = (scanner) => !(scanner.lookahead in Scanner.whiteSpaceTokens);\n    Scanner.terminatingChars = {\n        \"<\": true,\n        \">\": true,\n        \"=\": true,\n        \"|\": true,\n        \"&\": true,\n        \")\": true,\n        \"[\": true,\n        \"%\": true,\n        \" \": true,\n        \",\": true\n    };\n    Scanner.finalizingLookaheads = {\n        \">\": true,\n        \",\": true,\n        \"\": true\n    };\n    Scanner.escapeToken = \"\\\\\";\n    Scanner.whiteSpaceTokens = {\n        \" \": true,\n        \"\\n\": true,\n        \"\\t\": true\n    };\n    Scanner.lookaheadIsFinalizing = (lookahead, unscanned) => lookahead === \">\" ?\n        unscanned[0] === \"=\" ?\n            // >== would only occur in an expression like Array<number>==5\n            // otherwise, >= would only occur as part of a bound like number>=5\n            unscanned[1] === \"=\"\n            // if > is the end of a generic instantiation, the next token will be an operator or the end of the string\n            : unscanned.trimStart() === \"\" ||\n                isKeyOf(unscanned.trimStart()[0], Scanner.terminatingChars)\n        // if the lookahead is a finalizing token but not >, it's unambiguously a finalizer (currently just \",\")\n        : lookahead === \",\";\n})(Scanner || (Scanner = {}));\n","import { ArkErrors, normalizeIndex } from \"@arktype/schema\";\nimport { append, isArray, printable, stringAndSymbolicEntriesOf, throwParseError, unset } from \"@arktype/util\";\nimport { Scanner } from \"./string/shift/scanner.js\";\nexport const parseObjectLiteral = (def, ctx) => {\n    let spread;\n    const structure = {};\n    // We only allow a spread operator to be used as the first key in an object\n    // because to match JS behavior any keys before the spread are overwritten\n    // by the values in the target object, so there'd be no useful purpose in having it\n    // anywhere except for the beginning.\n    const parsedEntries = stringAndSymbolicEntriesOf(def).map(parseEntry);\n    if (parsedEntries[0]?.kind === \"...\") {\n        // remove the spread entry so we can iterate over the remaining entries\n        // expecting non-spread entries\n        const spreadEntry = parsedEntries.shift();\n        const spreadNode = ctx.$.parse(spreadEntry.value, ctx);\n        if (!spreadNode.hasKind(\"intersection\") || !spreadNode.structure) {\n            return throwParseError(writeInvalidSpreadTypeMessage(typeof spreadEntry.value === \"string\" ?\n                spreadEntry.value\n                : printable(spreadEntry.value)));\n        }\n        spread = spreadNode.structure;\n    }\n    for (const entry of parsedEntries) {\n        if (entry.kind === \"...\")\n            return throwParseError(nonLeadingSpreadError);\n        if (entry.kind === \"+\") {\n            if (entry.value !== \"reject\" &&\n                entry.value !== \"delete\" &&\n                entry.value !== \"ignore\")\n                throwParseError(writeInvalidUndeclaredBehaviorMessage(entry.value));\n            structure.undeclared = entry.value;\n            continue;\n        }\n        if (entry.kind === \"index\") {\n            // handle key parsing first to match type behavior\n            const key = ctx.$.parse(entry.key, ctx);\n            const value = ctx.$.parse(entry.value, ctx);\n            const normalizedSignature = normalizeIndex(key, value, ctx.$);\n            if (normalizedSignature.required) {\n                structure.required = append(structure.required, normalizedSignature.required);\n            }\n            if (normalizedSignature.index)\n                structure.index = append(structure.index, normalizedSignature.index);\n        }\n        else {\n            const value = ctx.$.parse(entry.value, ctx);\n            const inner = { key: entry.key, value };\n            if (entry.default !== unset) {\n                const out = value(entry.default);\n                if (out instanceof ArkErrors)\n                    throwParseError(`Default value at ${printable(entry.key)} ${out}`);\n                value.assert(entry.default);\n                inner.default = entry.default;\n            }\n            structure[entry.kind] = append(structure[entry.kind], inner);\n        }\n    }\n    const structureNode = ctx.$.node(\"structure\", structure);\n    return ctx.$.schema({\n        domain: \"object\",\n        structure: spread?.merge(structureNode) ?? structureNode\n    });\n};\nexport const writeInvalidUndeclaredBehaviorMessage = (actual) => `Value of '+' key must be 'reject', 'delete', or 'ignore' (was ${printable(actual)})`;\nexport const nonLeadingSpreadError = \"Spread operator may only be used as the first key in an object\";\nexport const parseEntry = ([key, value]) => {\n    const parsedKey = parseKey(key);\n    if (isArray(value) && value[1] === \"=\") {\n        if (parsedKey.kind !== \"required\")\n            throwParseError(invalidDefaultKeyKindMessage);\n        return {\n            kind: \"optional\",\n            key: parsedKey.key,\n            value: value[0],\n            default: value[2]\n        };\n    }\n    return {\n        kind: parsedKey.kind,\n        key: parsedKey.key,\n        value,\n        default: unset\n    };\n};\n// single quote use here is better for TypeScript's inlined error to avoid escapes\nexport const invalidDefaultKeyKindMessage = `Only required keys may specify default values, e.g. { ark: ['string', '=', '⛵'] }`;\nconst parseKey = (key) => typeof key === \"symbol\" ? { kind: \"required\", key }\n    : key.at(-1) === \"?\" ?\n        key.at(-2) === Scanner.escapeToken ?\n            { kind: \"required\", key: `${key.slice(0, -2)}?` }\n            : {\n                kind: \"optional\",\n                key: key.slice(0, -1)\n            }\n        : key[0] === \"[\" && key.at(-1) === \"]\" ?\n            { kind: \"index\", key: key.slice(1, -1) }\n            : key[0] === Scanner.escapeToken && key[1] === \"[\" && key.at(-1) === \"]\" ?\n                { kind: \"required\", key: key.slice(1) }\n                : key === \"...\" || key === \"+\" ? { kind: key, key }\n                    : {\n                        kind: \"required\",\n                        key: key === \"\\\\...\" ? \"...\"\n                            : key === \"\\\\+\" ? \"+\"\n                                : key\n                    };\nexport const writeInvalidSpreadTypeMessage = (def) => `Spread operand must resolve to an object literal type (was ${def})`;\n","export const minComparators = {\n    \">\": true,\n    \">=\": true\n};\nexport const maxComparators = {\n    \"<\": true,\n    \"<=\": true\n};\nexport const comparators = {\n    \">\": true,\n    \">=\": true,\n    \"<\": true,\n    \"<=\": true,\n    \"==\": true\n};\nexport const invertedComparators = {\n    \"<\": \">\",\n    \">\": \"<\",\n    \"<=\": \">=\",\n    \">=\": \"<=\",\n    \"==\": \"==\"\n};\nexport const writeUnmatchedGroupCloseMessage = (unscanned) => `Unmatched )${(unscanned === \"\" ? \"\" : ` before ${unscanned}`)}`;\nexport const writeUnclosedGroupMessage = (missingChar) => `Missing ${missingChar}`;\nexport const writeOpenRangeMessage = (min, comparator) => `Left bounds are only valid when paired with right bounds (try ...${comparator}${min})`;\nexport const writeUnpairableComparatorMessage = (comparator) => `Left-bounded expressions must specify their limits using < or <= (was ${comparator})`;\nexport const writeMultipleLeftBoundsMessage = (openLimit, openComparator, limit, comparator) => `An expression may have at most one left bound (parsed ${openLimit}${invertedComparators[openComparator]}, ${limit}${invertedComparators[comparator]})`;\n","import { writeUnclosedGroupMessage } from \"../../reduce/shared.js\";\nexport const parseGenericArgs = (name, params, s) => _parseGenericArgs(name, params, s, [], []);\nconst _parseGenericArgs = (name, params, s, argDefs, argNodes) => {\n    const argState = s.parseUntilFinalizer();\n    // remove the finalizing token from the argDef\n    argDefs.push(argState.scanner.scanned.slice(0, -1));\n    argNodes.push(argState.root);\n    if (argState.finalizer === \">\") {\n        if (argNodes.length === params.length) {\n            return {\n                result: argNodes,\n                unscanned: argState.scanner.unscanned\n            };\n        }\n        return argState.error(writeInvalidGenericArgsMessage(name, params, argDefs));\n    }\n    if (argState.finalizer === \",\")\n        return _parseGenericArgs(name, params, s, argDefs, argNodes);\n    return argState.error(writeUnclosedGroupMessage(\">\"));\n};\nexport const writeInvalidGenericArgsMessage = (name, params, argDefs) => `${name}<${params.join(\", \")}> requires exactly ${params.length} args (got ${argDefs.length}${argDefs.length === 0 ? \"\" : `: ${argDefs.join(\", \")}`})`;\n","import { BaseRoot, hasArkKind, writeUnresolvableMessage } from \"@arktype/schema\";\nimport { printable, throwParseError, tryParseNumber, tryParseWellFormedBigint } from \"@arktype/util\";\nimport { writePrefixedPrivateReferenceMessage } from \"../../../semantic/validate.js\";\nimport { parseGenericArgs, writeInvalidGenericArgsMessage } from \"./genericArgs.js\";\nexport const parseUnenclosed = (s) => {\n    const token = s.scanner.shiftUntilNextTerminator();\n    if (token === \"keyof\")\n        s.addPrefix(\"keyof\");\n    else\n        s.root = unenclosedToNode(s, token);\n};\nexport const parseGenericInstantiation = (name, g, s) => {\n    s.scanner.shiftUntilNonWhitespace();\n    const lookahead = s.scanner.shift();\n    if (lookahead !== \"<\")\n        return s.error(writeInvalidGenericArgsMessage(name, g.params, []));\n    const parsedArgs = parseGenericArgs(name, g.params, s);\n    const remainingChars = parsedArgs.unscanned.length;\n    // set the scanner position to where the args scanner left off\n    s.scanner.jumpToIndex(remainingChars === 0 ? s.scanner.length : -remainingChars);\n    return g(...parsedArgs.result);\n};\nconst unenclosedToNode = (s, token) => maybeParseReference(s, token) ??\n    maybeParseUnenclosedLiteral(s, token) ??\n    s.error(token === \"\" ? writeMissingOperandMessage(s)\n        : token[0] === \"#\" ?\n            writePrefixedPrivateReferenceMessage(token)\n            : writeUnresolvableMessage(token));\nconst maybeParseReference = (s, token) => {\n    if (s.ctx.args?.[token])\n        return s.ctx.args[token].raw;\n    const resolution = s.ctx.$.maybeResolve(token);\n    if (resolution instanceof BaseRoot)\n        return resolution;\n    if (resolution === undefined)\n        return;\n    if (hasArkKind(resolution, \"generic\"))\n        return parseGenericInstantiation(token, resolution, s);\n    return throwParseError(`Unexpected resolution ${printable(resolution)}`);\n};\nconst maybeParseUnenclosedLiteral = (s, token) => {\n    const maybeNumber = tryParseNumber(token, { strict: true });\n    if (maybeNumber !== undefined)\n        return s.ctx.$.node(\"unit\", { unit: maybeNumber });\n    const maybeBigint = tryParseWellFormedBigint(token);\n    if (maybeBigint !== undefined)\n        return s.ctx.$.node(\"unit\", { unit: maybeBigint });\n};\nexport const writeMissingOperandMessage = (s) => {\n    const operator = s.previousOperator();\n    return operator ?\n        writeMissingRightOperandMessage(operator, s.scanner.unscanned)\n        : writeExpressionExpectedMessage(s.scanner.unscanned);\n};\nexport const writeMissingRightOperandMessage = (token, unscanned = \"\") => `Token '${token}' requires a right operand${unscanned ? ` before '${unscanned}'` : \"\"}`;\nexport const writeExpressionExpectedMessage = (unscanned) => `Expected an expression${unscanned ? ` before '${unscanned}'` : \"\"}`;\n","import { jsObjects, makeRootAndArrayPropertiesMutable, tsKeywords } from \"@arktype/schema\";\nimport { append, objectKindOrDomainOf, throwParseError } from \"@arktype/util\";\nimport { writeMissingRightOperandMessage } from \"./string/shift/operand/unenclosed.js\";\nexport const parseTuple = (def, ctx) => maybeParseTupleExpression(def, ctx) ?? parseTupleLiteral(def, ctx);\nexport const parseTupleLiteral = (def, ctx) => {\n    let sequences = [{}];\n    let i = 0;\n    while (i < def.length) {\n        let spread = false;\n        let optional = false;\n        if (def[i] === \"...\" && i < def.length - 1) {\n            spread = true;\n            i++;\n        }\n        const element = ctx.$.parse(def[i], ctx);\n        i++;\n        if (def[i] === \"?\") {\n            if (spread)\n                return throwParseError(spreadOptionalMessage);\n            optional = true;\n            i++;\n        }\n        if (spread) {\n            if (!element.extends(jsObjects.Array))\n                return throwParseError(writeNonArraySpreadMessage(element.expression));\n            // a spread must be distributed over branches e.g.:\n            // def: [string, ...(number[] | [true, false])]\n            // nodes: [string, ...number[]] | [string, true, false]\n            sequences = sequences.flatMap(base => \n            // since appendElement mutates base, we have to shallow-ish clone it for each branch\n            element.branches.map(branch => appendSpreadBranch(makeRootAndArrayPropertiesMutable(base), branch)));\n        }\n        else {\n            sequences = sequences.map(base => appendElement(base, optional ? \"optional\" : \"required\", element));\n        }\n    }\n    return ctx.$.raw.schema(sequences.map(sequence => ({\n        proto: Array,\n        sequence\n    })));\n};\nconst appendElement = (base, kind, element) => {\n    switch (kind) {\n        case \"required\":\n            if (base.optionals)\n                // e.g. [string?, number]\n                return throwParseError(requiredPostOptionalMessage);\n            if (base.variadic) {\n                // e.g. [...string[], number]\n                base.postfix = append(base.postfix, element);\n            }\n            else {\n                // e.g. [string, number]\n                base.prefix = append(base.prefix, element);\n            }\n            return base;\n        case \"optional\":\n            if (base.variadic)\n                // e.g. [...string[], number?]\n                return throwParseError(optionalPostVariadicMessage);\n            // e.g. [string, number?]\n            base.optionals = append(base.optionals, element);\n            return base;\n        case \"variadic\":\n            // e.g. [...string[], number, ...string[]]\n            if (base.postfix)\n                throwParseError(multipleVariadicMesage);\n            if (base.variadic) {\n                if (!base.variadic.equals(element)) {\n                    // e.g. [...string[], ...number[]]\n                    throwParseError(multipleVariadicMesage);\n                }\n                // e.g. [...string[], ...string[]]\n                // do nothing, second spread doesn't change the type\n            }\n            else {\n                // e.g. [string, ...number[]]\n                base.variadic = element.raw;\n            }\n            return base;\n    }\n};\nconst appendSpreadBranch = (base, branch) => {\n    const spread = branch.firstReferenceOfKind(\"sequence\");\n    if (!spread) {\n        // the only array with no sequence reference is unknown[]\n        return appendElement(base, \"variadic\", tsKeywords.unknown);\n    }\n    spread.prefix.forEach(node => appendElement(base, \"required\", node));\n    spread.optionals.forEach(node => appendElement(base, \"optional\", node));\n    spread.variadic && appendElement(base, \"variadic\", spread.variadic);\n    spread.postfix.forEach(node => appendElement(base, \"required\", node));\n    return base;\n};\nconst maybeParseTupleExpression = (def, ctx) => {\n    const tupleExpressionResult = isIndexZeroExpression(def) ? prefixParsers[def[0]](def, ctx)\n        : isIndexOneExpression(def) ? indexOneParsers[def[1]](def, ctx)\n            : undefined;\n    return tupleExpressionResult;\n};\nexport const writeNonArraySpreadMessage = (operand) => `Spread element must be an array (was ${operand})`;\nexport const multipleVariadicMesage = \"A tuple may have at most one variadic element\";\nexport const requiredPostOptionalMessage = \"A required element may not follow an optional element\";\nexport const optionalPostVariadicMessage = \"An optional element may not follow a variadic element\";\nexport const spreadOptionalMessage = \"A spread element cannot be optional\";\nexport const parseKeyOfTuple = (def, ctx) => ctx.$.parse(def[1], ctx).keyof();\nconst parseBranchTuple = (def, ctx) => {\n    if (def[2] === undefined)\n        return throwParseError(writeMissingRightOperandMessage(def[1], \"\"));\n    const l = ctx.$.parse(def[0], ctx);\n    const r = ctx.$.parse(def[2], ctx);\n    return def[1] === \"&\" ? l.and(r) : l.or(r);\n};\nconst parseArrayTuple = (def, ctx) => ctx.$.parse(def[0], ctx).array();\nconst isIndexOneExpression = (def) => indexOneParsers[def[1]] !== undefined;\nexport const parseMorphTuple = (def, ctx) => {\n    if (typeof def[2] !== \"function\") {\n        return throwParseError(writeMalformedFunctionalExpressionMessage(\"=>\", def[2]));\n    }\n    // TODO: nested morphs?\n    return ctx.$.parse(def[0], ctx).pipe(def[2]);\n};\nexport const writeMalformedFunctionalExpressionMessage = (operator, value) => `${operator === \":\" ? \"Narrow\" : \"Morph\"} expression requires a function following '${operator}' (was ${typeof value})`;\nexport const parseNarrowTuple = (def, ctx) => {\n    if (typeof def[2] !== \"function\") {\n        return throwParseError(writeMalformedFunctionalExpressionMessage(\":\", def[2]));\n    }\n    return ctx.$.parse(def[0], ctx).constrain(\"predicate\", def[2]);\n};\nconst parseAttributeTuple = (def, ctx) => ctx.$.parse(def[0], ctx).configureShallowDescendants(def[2]);\nconst indexOneParsers = {\n    \"|\": parseBranchTuple,\n    \"&\": parseBranchTuple,\n    \"[]\": parseArrayTuple,\n    \":\": parseNarrowTuple,\n    \"=>\": parseMorphTuple,\n    \"@\": parseAttributeTuple\n};\nconst prefixParsers = {\n    keyof: parseKeyOfTuple,\n    instanceof: (def, ctx) => {\n        if (typeof def[1] !== \"function\") {\n            return throwParseError(writeInvalidConstructorMessage(objectKindOrDomainOf(def[1])));\n        }\n        const branches = def\n            .slice(1)\n            .map(ctor => typeof ctor === \"function\" ?\n            ctx.$.node(\"proto\", { proto: ctor })\n            : throwParseError(writeInvalidConstructorMessage(objectKindOrDomainOf(ctor))));\n        return branches.length === 1 ?\n            branches[0]\n            : ctx.$.node(\"union\", { branches });\n    },\n    \"===\": (def, ctx) => ctx.$.units(def.slice(1))\n};\nconst isIndexZeroExpression = (def) => prefixParsers[def[0]] !== undefined;\nexport const writeInvalidConstructorMessage = (actual) => `Expected a constructor following 'instanceof' operator (was ${actual})`;\n","import { hasArkKind } from \"@arktype/schema\";\nimport { isThunk, objectKindOf, printable, throwParseError } from \"@arktype/util\";\nimport { parseObjectLiteral } from \"./objectLiteral.js\";\nimport { parseTuple } from \"./tuple.js\";\nexport const parseObject = (def, ctx) => {\n    const objectKind = objectKindOf(def);\n    switch (objectKind) {\n        case undefined:\n            if (hasArkKind(def, \"root\"))\n                return def;\n            return parseObjectLiteral(def, ctx);\n        case \"Array\":\n            return parseTuple(def, ctx);\n        case \"RegExp\":\n            return ctx.$.node(\"intersection\", {\n                domain: \"string\",\n                regex: def\n            }, { prereduced: true });\n        case \"Function\": {\n            const resolvedDef = isThunk(def) ? def() : def;\n            if (hasArkKind(resolvedDef, \"root\"))\n                return resolvedDef;\n            return throwParseError(writeBadDefinitionTypeMessage(\"Function\"));\n        }\n        default:\n            return throwParseError(writeBadDefinitionTypeMessage(objectKind ?? printable(def)));\n    }\n};\nexport const writeBadDefinitionTypeMessage = (actual) => `Type definitions must be strings or objects (was ${actual})`;\n","import { throwParseError, tryParseNumber } from \"@arktype/util\";\nexport const isDateLiteral = (value) => typeof value === \"string\" &&\n    value[0] === \"d\" &&\n    (value[1] === \"'\" || value[1] === '\"') &&\n    value.at(-1) === value[1];\nexport const isValidDate = (d) => d.toString() !== \"Invalid Date\";\nexport const extractDateLiteralSource = (literal) => literal.slice(2, -1);\nexport const writeInvalidDateMessage = (source) => `'${source}' could not be parsed by the Date constructor`;\nexport const tryParseDate = (source, errorOnFail) => maybeParseDate(source, errorOnFail);\nconst maybeParseDate = (source, errorOnFail) => {\n    const stringParsedDate = new Date(source);\n    if (isValidDate(stringParsedDate))\n        return stringParsedDate;\n    const epochMillis = tryParseNumber(source);\n    if (epochMillis !== undefined) {\n        const numberParsedDate = new Date(epochMillis);\n        if (isValidDate(numberParsedDate))\n            return numberParsedDate;\n    }\n    return errorOnFail ?\n        throwParseError(errorOnFail === true ? writeInvalidDateMessage(source) : errorOnFail)\n        : undefined;\n};\n","import { internalKeywords, jsObjects, tsKeywords, writeUnboundableMessage } from \"@arktype/schema\";\nimport { isKeyOf, throwParseError } from \"@arktype/util\";\nimport { invertedComparators, maxComparators, writeUnpairableComparatorMessage } from \"../../reduce/shared.js\";\nimport { extractDateLiteralSource, isDateLiteral } from \"../operand/date.js\";\nexport const parseBound = (s, start) => {\n    const comparator = shiftComparator(s, start);\n    if (s.root.hasKind(\"unit\")) {\n        if (typeof s.root.unit === \"number\") {\n            s.reduceLeftBound(s.root.unit, comparator);\n            s.unsetRoot();\n            return;\n        }\n        if (s.root.unit instanceof Date) {\n            const literal = `d'${s.root.description ?? s.root.unit.toISOString()}'`;\n            s.unsetRoot();\n            s.reduceLeftBound(literal, comparator);\n            return;\n        }\n    }\n    return parseRightBound(s, comparator);\n};\nconst oneCharComparators = {\n    \"<\": true,\n    \">\": true\n};\nexport const comparatorStartChars = {\n    \"<\": 1,\n    \">\": 1,\n    \"=\": 1\n};\nconst shiftComparator = (s, start) => s.scanner.lookaheadIs(\"=\") ? `${start}${s.scanner.shift()}`\n    : isKeyOf(start, oneCharComparators) ? start\n        : s.error(singleEqualsMessage);\nexport const writeIncompatibleRangeMessage = (l, r) => `Bound kinds ${l} and ${r} are incompatible`;\nexport const getBoundKinds = (comparator, limit, root, boundKind) => {\n    if (root.extends(tsKeywords.number)) {\n        if (typeof limit !== \"number\") {\n            return throwParseError(writeInvalidLimitMessage(comparator, limit, boundKind));\n        }\n        return (comparator === \"==\" ? [\"min\", \"max\"]\n            : comparator[0] === \">\" ? [\"min\"]\n                : [\"max\"]);\n    }\n    if (root.extends(internalKeywords.lengthBoundable)) {\n        if (typeof limit !== \"number\") {\n            return throwParseError(writeInvalidLimitMessage(comparator, limit, boundKind));\n        }\n        return (comparator === \"==\" ? [\"minLength\", \"maxLength\"]\n            : comparator[0] === \">\" ? [\"minLength\"]\n                : [\"maxLength\"]);\n    }\n    if (root.extends(jsObjects.Date)) {\n        // allow either numeric or date limits\n        return (comparator === \"==\" ? [\"after\", \"before\"]\n            : comparator[0] === \">\" ? [\"after\"]\n                : [\"before\"]);\n    }\n    return throwParseError(writeUnboundableMessage(root.expression));\n};\nexport const singleEqualsMessage = \"= is not a valid comparator. Use == to check for equality\";\nconst openLeftBoundToRoot = (leftBound) => ({\n    rule: isDateLiteral(leftBound.limit) ?\n        extractDateLiteralSource(leftBound.limit)\n        : leftBound.limit,\n    exclusive: leftBound.comparator.length === 1\n});\nexport const parseRightBound = (s, comparator) => {\n    // store the node that will be bounded\n    const previousRoot = s.unsetRoot();\n    const previousScannerIndex = s.scanner.location;\n    s.parseOperand();\n    const limitNode = s.unsetRoot();\n    // after parsing the next operand, use the locations to get the\n    // token from which it was parsed\n    const limitToken = s.scanner.sliceChars(previousScannerIndex, s.scanner.location);\n    s.root = previousRoot;\n    if (!limitNode.hasKind(\"unit\") ||\n        (typeof limitNode.unit !== \"number\" && !(limitNode.unit instanceof Date)))\n        return s.error(writeInvalidLimitMessage(comparator, limitToken, \"right\"));\n    const limit = limitNode.unit;\n    // apply the newly-parsed right bound\n    const exclusive = comparator.length === 1;\n    // if the comparator is ==, both the min and max of that pair will be applied\n    for (const kind of getBoundKinds(comparator, typeof limit === \"number\" ? limit : limitToken, previousRoot, \"right\"))\n        s.constrainRoot(kind, { rule: limit, exclusive });\n    if (!s.branches.leftBound)\n        return;\n    // if there's an open left bound, perform additional validation and apply it\n    if (!isKeyOf(comparator, maxComparators))\n        return s.error(writeUnpairableComparatorMessage(comparator));\n    const lowerBoundKind = getBoundKinds(s.branches.leftBound.comparator, s.branches.leftBound.limit, previousRoot, \"left\");\n    s.constrainRoot(lowerBoundKind[0], openLeftBoundToRoot(s.branches.leftBound));\n    s.branches.leftBound = null;\n};\nexport const writeInvalidLimitMessage = (comparator, limit, boundKind) => `Comparator ${boundKind === \"left\" ? invertedComparators[comparator] : comparator} must be ${boundKind === \"left\" ? \"preceded\" : \"followed\"} by a corresponding literal (was ${limit})`;\n","import { tryParseInteger } from \"@arktype/util\";\nexport const parseDivisor = (s) => {\n    const divisorToken = s.scanner.shiftUntilNextTerminator();\n    const divisor = tryParseInteger(divisorToken, {\n        errorOnFail: writeInvalidDivisorMessage(divisorToken)\n    });\n    if (divisor === 0)\n        s.error(writeInvalidDivisorMessage(0));\n    s.root = s.root.constrain(\"divisor\", divisor);\n};\nexport const writeInvalidDivisorMessage = (divisor) => `% operator must be followed by a non-zero integer literal (was ${divisor})`;\n","import { isKeyOf } from \"@arktype/util\";\nimport { Scanner } from \"../scanner.js\";\nimport { comparatorStartChars, parseBound } from \"./bounds.js\";\nimport { parseDivisor } from \"./divisor.js\";\nexport const parseOperator = (s) => {\n    const lookahead = s.scanner.shift();\n    return (lookahead === \"\" ? s.finalize(\"\")\n        : lookahead === \"[\" ?\n            s.scanner.shift() === \"]\" ?\n                s.setRoot(s.root.array())\n                : s.error(incompleteArrayTokenMessage)\n            : lookahead === \"|\" || lookahead === \"&\" ? s.pushRootToBranch(lookahead)\n                : lookahead === \")\" ? s.finalizeGroup()\n                    : Scanner.lookaheadIsFinalizing(lookahead, s.scanner.unscanned) ?\n                        s.finalize(lookahead)\n                        : isKeyOf(lookahead, comparatorStartChars) ? parseBound(s, lookahead)\n                            : lookahead === \"%\" ? parseDivisor(s)\n                                : lookahead === \" \" ? parseOperator(s)\n                                    : s.error(writeUnexpectedCharacterMessage(lookahead)));\n};\nexport const writeUnexpectedCharacterMessage = (char, shouldBe = \"\") => `'${char}' is not allowed here${shouldBe && ` (should be ${shouldBe})`}`;\nexport const incompleteArrayTokenMessage = `Missing expected ']'`;\n","import { throwParseError } from \"@arktype/util\";\nimport { writeUnexpectedCharacterMessage } from \"./string/shift/operator/operator.js\";\nimport { Scanner } from \"./string/shift/scanner.js\";\nexport const parseGenericParams = (def) => _parseGenericParams(new Scanner(def));\nexport const emptyGenericParameterMessage = \"An empty string is not a valid generic parameter name\";\nconst _parseGenericParams = (scanner) => {\n    const param = scanner.shiftUntilNextTerminator();\n    if (param === \"\")\n        throwParseError(emptyGenericParameterMessage);\n    scanner.shiftUntilNonWhitespace();\n    const nextNonWhitespace = scanner.shift();\n    return (nextNonWhitespace === \"\" ? [param]\n        : nextNonWhitespace === \",\" ? [param, ..._parseGenericParams(scanner)]\n            : throwParseError(writeUnexpectedCharacterMessage(nextNonWhitespace, \",\")));\n};\n","import { isKeyOf } from \"@arktype/util\";\nimport { tryParseDate, writeInvalidDateMessage } from \"./date.js\";\nexport const parseEnclosed = (s, enclosing) => {\n    const enclosed = s.scanner.shiftUntil(untilLookaheadIsClosing[enclosingTokens[enclosing]]);\n    if (s.scanner.lookahead === \"\")\n        return s.error(writeUnterminatedEnclosedMessage(enclosed, enclosing));\n    // Shift the scanner one additional time for the second enclosing token\n    s.scanner.shift();\n    if (enclosing === \"/\") {\n        // fail parsing if the regex is invalid\n        new RegExp(enclosed);\n        s.root = s.ctx.$.node(\"intersection\", {\n            domain: \"string\",\n            regex: enclosed\n        }, { prereduced: true });\n    }\n    else if (isKeyOf(enclosing, enclosingQuote))\n        s.root = s.ctx.$.node(\"unit\", { unit: enclosed });\n    else {\n        const date = tryParseDate(enclosed, writeInvalidDateMessage(enclosed));\n        s.root = s.ctx.$.node(\"unit\", { unit: date, description: enclosed });\n    }\n};\nexport const enclosingQuote = {\n    \"'\": 1,\n    '\"': 1\n};\nexport const enclosingChar = {\n    \"/\": 1,\n    \"'\": 1,\n    '\"': 1\n};\nexport const enclosingTokens = {\n    \"d'\": \"'\",\n    'd\"': '\"',\n    \"'\": \"'\",\n    '\"': '\"',\n    \"/\": \"/\"\n};\nexport const untilLookaheadIsClosing = {\n    \"'\": scanner => scanner.lookahead === `'`,\n    '\"': scanner => scanner.lookahead === `\"`,\n    \"/\": scanner => scanner.lookahead === `/`\n};\nconst enclosingCharDescriptions = {\n    '\"': \"double-quote\",\n    \"'\": \"single-quote\",\n    \"/\": \"forward slash\"\n};\nexport const writeUnterminatedEnclosedMessage = (fragment, enclosingStart) => `${enclosingStart}${fragment} requires a closing ${enclosingCharDescriptions[enclosingTokens[enclosingStart]]}`;\n","import { Scanner } from \"../scanner.js\";\nimport { enclosingChar, enclosingQuote, parseEnclosed } from \"./enclosed.js\";\nimport { parseUnenclosed, writeMissingOperandMessage } from \"./unenclosed.js\";\nexport const parseOperand = (s) => s.scanner.lookahead === \"\" ? s.error(writeMissingOperandMessage(s))\n    : s.scanner.lookahead === \"(\" ? s.shiftedByOne().reduceGroupOpen()\n        : s.scanner.lookaheadIsIn(enclosingChar) ? parseEnclosed(s, s.scanner.shift())\n            : s.scanner.lookaheadIsIn(Scanner.whiteSpaceTokens) ?\n                parseOperand(s.shiftedByOne())\n                : s.scanner.lookahead === \"d\" ?\n                    s.scanner.nextLookahead in enclosingQuote ?\n                        parseEnclosed(s, `${s.scanner.shift()}${s.scanner.shift()}`)\n                        : parseUnenclosed(s)\n                    : parseUnenclosed(s);\n","export const writeUnsatisfiableExpressionError = (expression) => `${expression} results in an unsatisfiable type`;\nexport const writePrefixedPrivateReferenceMessage = (def) => `Private type references should not include '#'. Use '${def.slice(1)}' instead.`;\n","import { throwInternalError, throwParseError } from \"@arktype/util\";\nimport { writeUnexpectedCharacterMessage } from \"./shift/operator/operator.js\";\nexport const fullStringParse = (s) => {\n    s.parseOperand();\n    const result = parseUntilFinalizer(s).root;\n    if (!result) {\n        return throwInternalError(`Root was unexpectedly unset after parsing string '${s.scanner.scanned}'`);\n    }\n    s.scanner.shiftUntilNonWhitespace();\n    if (s.scanner.lookahead) {\n        // throw a parse error if non-whitespace characters made it here without being parsed\n        throwParseError(writeUnexpectedCharacterMessage(s.scanner.lookahead));\n    }\n    return result;\n};\nexport const parseUntilFinalizer = (s) => {\n    while (s.finalizer === undefined)\n        next(s);\n    return s;\n};\nconst next = (s) => s.hasRoot() ? s.parseOperator() : s.parseOperand();\n","import { isKeyOf, throwInternalError, throwParseError } from \"@arktype/util\";\nimport { parseOperand } from \"../shift/operand/operand.js\";\nimport { parseOperator } from \"../shift/operator/operator.js\";\nimport { Scanner } from \"../shift/scanner.js\";\nimport { parseUntilFinalizer } from \"../string.js\";\nimport { invertedComparators, minComparators, writeMultipleLeftBoundsMessage, writeOpenRangeMessage, writeUnclosedGroupMessage, writeUnmatchedGroupCloseMessage, writeUnpairableComparatorMessage } from \"./shared.js\";\nexport class DynamicState {\n    ctx;\n    scanner;\n    // set root type to `any` so that all constraints can be applied\n    root;\n    branches = {\n        prefixes: [],\n        leftBound: null,\n        intersection: null,\n        union: null\n    };\n    finalizer;\n    groups = [];\n    constructor(def, ctx) {\n        this.ctx = ctx;\n        this.scanner = new Scanner(def);\n    }\n    error(message) {\n        return throwParseError(message);\n    }\n    hasRoot() {\n        return this.root !== undefined;\n    }\n    setRoot(root) {\n        this.root = root;\n    }\n    unsetRoot() {\n        const value = this.root;\n        this.root = undefined;\n        return value;\n    }\n    constrainRoot(...args) {\n        this.root = this.root.constrain(args[0], args[1]);\n    }\n    finalize(finalizer) {\n        if (this.groups.length)\n            return this.error(writeUnclosedGroupMessage(\")\"));\n        this.finalizeBranches();\n        this.finalizer = finalizer;\n    }\n    reduceLeftBound(limit, comparator) {\n        const invertedComparator = invertedComparators[comparator];\n        if (!isKeyOf(invertedComparator, minComparators))\n            return this.error(writeUnpairableComparatorMessage(comparator));\n        if (this.branches.leftBound) {\n            return this.error(writeMultipleLeftBoundsMessage(this.branches.leftBound.limit, this.branches.leftBound.comparator, limit, invertedComparator));\n        }\n        this.branches.leftBound = {\n            comparator: invertedComparator,\n            limit\n        };\n    }\n    finalizeBranches() {\n        this.assertRangeUnset();\n        if (this.branches.union) {\n            this.pushRootToBranch(\"|\");\n            this.root = this.branches.union;\n        }\n        else if (this.branches.intersection) {\n            this.pushRootToBranch(\"&\");\n            this.root = this.branches.intersection;\n        }\n        else\n            this.applyPrefixes();\n    }\n    finalizeGroup() {\n        this.finalizeBranches();\n        const topBranchState = this.groups.pop();\n        if (!topBranchState)\n            return this.error(writeUnmatchedGroupCloseMessage(this.scanner.unscanned));\n        this.branches = topBranchState;\n    }\n    addPrefix(prefix) {\n        this.branches.prefixes.push(prefix);\n    }\n    applyPrefixes() {\n        while (this.branches.prefixes.length) {\n            const lastPrefix = this.branches.prefixes.pop();\n            this.root =\n                lastPrefix === \"keyof\" ?\n                    this.root.keyof()\n                    : throwInternalError(`Unexpected prefix '${lastPrefix}'`);\n        }\n    }\n    pushRootToBranch(token) {\n        this.assertRangeUnset();\n        this.applyPrefixes();\n        const root = this.root;\n        this.branches.intersection = this.branches.intersection?.and(root) ?? root;\n        if (token === \"|\") {\n            this.branches.union =\n                this.branches.union?.or(this.branches.intersection) ??\n                    this.branches.intersection;\n            this.branches.intersection = null;\n        }\n        this.root = undefined;\n    }\n    parseUntilFinalizer() {\n        return parseUntilFinalizer(new DynamicState(this.scanner.unscanned, this.ctx));\n    }\n    parseOperator() {\n        return parseOperator(this);\n    }\n    parseOperand() {\n        return parseOperand(this);\n    }\n    assertRangeUnset() {\n        if (this.branches.leftBound) {\n            return this.error(writeOpenRangeMessage(this.branches.leftBound.limit, this.branches.leftBound.comparator));\n        }\n    }\n    reduceGroupOpen() {\n        this.groups.push(this.branches);\n        this.branches = {\n            prefixes: [],\n            leftBound: null,\n            union: null,\n            intersection: null\n        };\n    }\n    previousOperator() {\n        return (this.branches.leftBound?.comparator ??\n            this.branches.prefixes.at(-1) ??\n            (this.branches.intersection ? \"&\"\n                : this.branches.union ? \"|\"\n                    : undefined));\n    }\n    shiftedByOne() {\n        this.scanner.shift();\n        return this;\n    }\n}\n","import { ArkErrors, BaseRoot } from \"@arktype/schema\";\nimport { Callable } from \"@arktype/util\";\nimport { Generic } from \"./generic.js\";\nimport { parseGenericParams } from \"./parser/generic.js\";\nconst typeParserAttachments = Object.freeze({\n    errors: ArkErrors\n});\nexport class RawTypeParser extends Callable {\n    constructor($) {\n        super((...args) => {\n            if (args.length === 1) {\n                // treat as a simple definition\n                return $.parseRoot(args[0]);\n            }\n            if (args.length === 2 &&\n                typeof args[0] === \"string\" &&\n                args[0][0] === \"<\" &&\n                args[0].at(-1) === \">\") {\n                // if there are exactly two args, the first of which looks like <${string}>,\n                // treat as a generic\n                const params = parseGenericParams(args[0].slice(1, -1));\n                const def = args[1];\n                // TODO: validateUninstantiatedGeneric, remove this cast\n                return new Generic(params, def, $);\n            }\n            // otherwise, treat as a tuple expression. technically, this also allows\n            // non-expression tuple definitions to be parsed, but it's not a supported\n            // part of the API as specified by the associated types\n            return $.parseRoot(args);\n        }, { bind: $, attach: typeParserAttachments });\n    }\n}\nexport const Type = BaseRoot;\n","import { RawRootScope, hasArkKind } from \"@arktype/schema\";\nimport { domainOf, hasDomain, isThunk, throwParseError } from \"@arktype/util\";\nimport { Generic } from \"./generic.js\";\nimport { createMatchParser } from \"./match.js\";\nimport { parseObject, writeBadDefinitionTypeMessage } from \"./parser/definition.js\";\nimport { parseGenericParams } from \"./parser/generic.js\";\nimport { DynamicState } from \"./parser/string/reduce/dynamic.js\";\nimport { fullStringParse } from \"./parser/string/string.js\";\nimport { RawTypeParser } from \"./type.js\";\nexport const scope = ((def, config = {}) => new RawScope(def, config));\nexport class RawScope extends RawRootScope {\n    parseCache = {};\n    constructor(def, config) {\n        const aliases = {};\n        for (const k in def) {\n            const parsedKey = parseScopeKey(k);\n            aliases[parsedKey.name] =\n                parsedKey.params.length ?\n                    // TODO: this\n                    new Generic(parsedKey.params, def[k], {})\n                    : def[k];\n        }\n        super(aliases, config);\n    }\n    type = new RawTypeParser(this);\n    match = createMatchParser(this);\n    declare = (() => ({\n        type: this.type\n    })).bind(this);\n    define = ((def) => def).bind(this);\n    preparseRoot(def) {\n        if (isThunk(def) && !hasArkKind(def, \"generic\"))\n            return def();\n        return def;\n    }\n    parseRoot(def) {\n        // args: { this: {} as RawRoot },\n        return this.parse(def, {\n            $: this,\n            args: {}\n            // type parsing can bypass nodes if it hits the cache,\n            // so bind it directly (could be optimized)\n        }).bindScope(this);\n    }\n    parse(def, ctx) {\n        if (typeof def === \"string\") {\n            if (ctx.args && Object.keys(ctx.args).every(k => !def.includes(k))) {\n                // we can only rely on the cache if there are no contextual\n                // resolutions like \"this\" or generic args\n                return this.parseString(def, ctx);\n            }\n            if (!this.parseCache[def])\n                this.parseCache[def] = this.parseString(def, ctx);\n            return this.parseCache[def];\n        }\n        return hasDomain(def, \"object\") ?\n            parseObject(def, ctx)\n            : throwParseError(writeBadDefinitionTypeMessage(domainOf(def)));\n    }\n    parseString(def, ctx) {\n        return (this.maybeResolveRoot(def) ??\n            ((def.endsWith(\"[]\") &&\n                this.maybeResolveRoot(def.slice(0, -2))?.array()) ||\n                fullStringParse(new DynamicState(def, ctx))));\n    }\n}\nexport const writeShallowCycleErrorMessage = (name, seen) => `Alias '${name}' has a shallow resolution cycle: ${[...seen, name].join(\":\")}`;\nexport const parseScopeKey = (k) => {\n    const firstParamIndex = k.indexOf(\"<\");\n    if (firstParamIndex === -1) {\n        return {\n            name: k,\n            params: []\n        };\n    }\n    if (k.at(-1) !== \">\") {\n        throwParseError(`'>' must be the last character of a generic declaration in a scope`);\n    }\n    return {\n        name: k.slice(0, firstParamIndex),\n        params: parseGenericParams(k.slice(firstParamIndex + 1, -1))\n    };\n};\n","export const createMatchParser = ($) => (() => { }).bind($);\n// const matchParser = (isRestricted: boolean) => {\n// \tconst handledCases: { when: RawRoot; then: Morph }[] = []\n// \tlet defaultCase: ((x: unknown) => unknown) | null = null\n// \tconst parser = {\n// \t\twhen: (when: unknown, then: Morph) => {\n// \t\t\thandledCases.push({ when: $.parseRoot(when, {}), then })\n// \t\t\treturn parser\n// \t\t},\n// \t\tfinalize: () => {\n// \t\t\t// TODO: exhaustiveness checking\n// \t\t\tconst branches = handledCases.flatMap(({ when, then }) => {\n// \t\t\t\tif (when.kind === \"union\") {\n// \t\t\t\t\treturn when.branches.map((branch) => ({\n// \t\t\t\t\t\tin: branch,\n// \t\t\t\t\t\tmorph: then\n// \t\t\t\t\t}))\n// \t\t\t\t}\n// \t\t\t\tif (when.kind === \"morph\") {\n// \t\t\t\t\treturn [{ in: when, morph: [when.morph, then] }]\n// \t\t\t\t}\n// \t\t\t\treturn [{ in: when, morph: then }]\n// \t\t\t})\n// \t\t\tif (defaultCase) {\n// \t\t\t\tbranches.push({ in: keywordNodes.unknown, morph: defaultCase })\n// \t\t\t}\n// \t\t\tconst matchers = $.node(\"union\", {\n// \t\t\t\tbranches,\n// \t\t\t\tordered: true\n// \t\t\t})\n// \t\t\treturn matchers.assert\n// \t\t},\n// \t\torThrow: () => {\n// \t\t\t// implicitly finalize, we don't need to do anything else because we throw either way\n// \t\t\treturn parser.finalize()\n// \t\t},\n// \t\tdefault: (x: unknown) => {\n// \t\t\tif (x instanceof Function) {\n// \t\t\t\tdefaultCase = x as never\n// \t\t\t} else {\n// \t\t\t\tdefaultCase = () => x\n// \t\t\t}\n// \t\t\treturn parser.finalize()\n// \t\t}\n// \t}\n// \treturn parser\n// }\n// return Object.assign(() => matchParser(false), {\n// \tonly: () => matchParser(true)\n// }) as never\n","import { keywordNodes } from \"@arktype/schema\";\nimport { RawScope, scope } from \"./scope.js\";\nexport const tsGenerics = {};\nexport const ambient = scope(keywordNodes);\nRawScope.ambient = ambient.raw;\nexport const ark = ambient.export();\nexport const type = ambient.type;\nexport const match = ambient.match;\nexport const define = ambient.define;\nexport const declare = ambient.declare;\n","import { FieldError, FieldErrors } from 'react-hook-form';\nimport { toNestErrors, validateFieldsNatively } from '@hookform/resolvers';\nimport type { Resolver } from './types';\nimport { ArkErrors } from 'arktype';\n\nconst parseErrorSchema = (e: ArkErrors): Record<string, FieldError> => {\n  // copy code to type to match FieldError shape\n  e.forEach((e) => Object.assign(e, { type: e.code }));\n  // need to cast here because TS doesn't understand we added the type field\n  return e.byPath as never;\n};\n\nexport const arktypeResolver: Resolver =\n  (schema, _schemaOptions, resolverOptions = {}) =>\n  (values, _, options) => {\n    const out = schema(values);\n\n    if (out instanceof ArkErrors) {\n      return {\n        values: {},\n        errors: toNestErrors(parseErrorSchema(out), options),\n      };\n    }\n\n    options.shouldUseNativeValidation && validateFieldsNatively({}, options);\n\n    return {\n      errors: {} as FieldErrors,\n      values: resolverOptions.raw ? values : out,\n    };\n  };\n"],"names":["ReadonlyArray","Array","includes","array","element","append","to","value","opts","undefined","isArray","prepend","unshift","push","appendUnique","InternalArktypeError","Error","throwInternalError","message","throwError","ctor","ParseError","name","throwParseError","flatMorph","o","flatMapEntry","inputIsArray","entries","Object","flatMap","entry","i","result","length","objectResult","fromEntries","values","entriesOf","isKeyOf","k","InnerDynamicBase","constructor","properties","assign","this","DynamicBase","NoopBase","CastableBase","splitByKeys","leftKeys","l","r","omit","keys","isEmptyObject","stringAndSymbolicEntriesOf","getOwnPropertySymbols","map","unset","Symbol","bound","target","ctx","addInitializer","bind","cached","context","call","defineProperty","kind","enumerable","isThunk","DynamicFunction","Function","args","params","slice","body","at","super","e","Callable","f","setPrototypeOf","prototype","attach","envHasCsp","thunk","cachedThunk","hasDomain","data","domainOf","builtinType","domainDescriptions","bigint","number","object","string","symbol","boolean","null","builtinConstructors","Date","Map","RegExp","Set","String","Number","Boolean","WeakMap","WeakSet","Promise","objectKindOf","getPrototypeOf","objectKindOrDomainOf","objectKindDescriptions","getExactBuiltinConstructorName","constructorName","prototypeKeysOf","curr","getOwnPropertyNames","baseKeysByDomain","constructorExtends","base","current","serializePrimitive","JSON","stringify","registry","globalThis","$ark","namesByResolution","nameCounts","register","existingName","get","baseNameFor","set","registeredReference","isDotAccessible","keyName","test","compileSerializedValue","prefix","toLowerCase","description","CompiledFunction","argNames","arg","indentation","indent","dedent","prop","key","optional","compileLiteralPropAccess","index","indexPropAccess","line","statement","repeat","identifier","expression","condition","then","block","elseIf","until","initialValue","forIn","contents","suffix","compile","serializeLiteralKey","Hkt","Kind","Instantiable","reify","def","hkt","UnaryKind","pipe","kinds","In","reduce","out","wellFormedNumberMatcher","isWellFormedNumber","numberLikeMatcher","wellFormedIntegerMatcher","isWellFormedInteger","integerLikeMatcher","isIntegerLike","numericLiteralDescriptions","integer","writeMalformedNumericLiteralMessage","tryParseNumber","token","options","parseNumeric","parseInt","parseKind","isNaN","s","isKindLike","strict","isWellFormed","errorOnFail","printable","toDateString","_serialize","printableOpts","onSymbol","onCycle","v","onFunction","seen","nextSeen","item","onUndefined","makeRootAndArrayPropertiesMutable","arkKind","hasArkKind","isNode","basisKinds","structuralKinds","refinementKinds","constraintKinds","rootKinds","nodeKinds","constraintKeys","structureKeys","precedenceByKind","isNodeKind","precedenceOfKind","schemaKindsRightOf","defaultValueSerializer","compileErrorContext","implementNode","_","implementation","hasAssociatedError","defaults","expected","actual","problem","path","problemWithLocation","propString","globalConfig","ArkError","input","nodeConfig","defineProperties","getOwnPropertyDescriptors","code","errors","hasCode","config","relativePath","propAccessChain","pathToPropString","toString","ArkErrors","byPath","count","mutable","add","error","existing","errorIntersection","existingIndex","indexOf","summary","join","TraversalContext","root","queuedMorphs","branches","currentBranch","queueMorphs","morphs","finalize","hasError","parent","pathIndex","morph","currentErrorCount","failFast","errCtx","segment","invalid","pushBranch","popBranch","pop","BaseNode","attachments","pipedFromCtx","includesMorph","allowsRequiresContext","allows","traverseApply","$","resolvedConfig","qualifiedId","id","hasKind","hasDefault","undeclared","children","some","child","inner","predicate","referencesById","references","precedence","jit","traverseAllows","traverse","_in","getIo","_out","_description","ioInner","keySchemaImplementation","impl","meta","childValue","node","toJSON","json","equals","other","typeHash","isBasis","isConstraint","isRefinement","isRoot","hasUnit","hasOpenIntersection","intersectionIsOpen","nestableExpression","bindScope","create","firstReference","filter","find","n","firstReferenceOrThrow","firstReferenceOfKind","firstReferenceOfKindOrThrow","transform","mapper","_transform","shouldTransform","lazilyResolve","transformedNode","innerWithTransformedChildren","transformed","transformedInner","in","keywords","unknown","configureShallowDescendants","configOrDescription","Disjoint","sources","clone","from","flat","disjointKinds","disjoint","describeReasons","reasons","pathString","parse","isEmpty","invert","invertedEntries","disjoints","forEach","withPrefixKey","entriesWithPrefix","segments","source","describeReason","intersectionCache","intersectNodesRoot","intersectNodes","operator","lrCacheKey","rlCacheKey","rlResult","lrResult","pipeToMorph","pipeFromMorph","intersections","validatedOut","outIntersection","BaseConstraint","impliedSiblings","intersect","RawPrimitiveConstraint","errorContext","js","traversalKind","return","compiledCondition","if","compiledNegation","compiledErrorContext","constraintKeyParser","schema","sort","innerHash","intersectConstraints","head","shift","raw","baseInner","unflattenConstraints","prereduced","roots","matched","splice","flattenConstraints","constraints","constraint","predicateImplementation","collapsibleKey","normalize","divisorImplementation","rule","divisor","Math","abs","greatestCommonDivisor","previous","BaseRange","boundOperandKind","operandKindsByBoundKind","compiledActual","comparator","compileComparator","exclusive","numericLimit","valueOf","negatedComparators","stringLimit","dateLimitToString","limitKind","isStricterThan","overlapsRange","overlapIsUnit","boundKindPairsByLower","min","minLength","after","parseExclusiveKey","flag","parseDateLimit","limit","max","maxLength","before","toLocaleString","afterImplementation","serialize","toISOString","beforeImplementation","unit","exactLengthImplementation","exactLength","maxImplementation","maxLengthImplementation","boundImplementationsByKind","boundClassesByKind","impliedBasis","lengthBoundable","regexImplementation","flags","regex","BaseRoot","_keyof","keyof","rawKeyOf","rNode","parseRoot","and","throw","or","assert","extract","branch","extends","exclude","proto","sequence","intersection","subsumes","configure","describe","acc","pipeOnce","narrow","constrain","toUpperCase","writeInvalidOperandMessage","throwInvalidOperandError","onUndeclaredKey","defineRightwardIntersections","AliasNode","_get_resolution_decorators","_classSuper","_instanceExtraInitializers","_metadata","metadata","descriptorIn","decorators","contextIn","initializers","extraInitializers","accept","TypeError","descriptor","getOwnPropertyDescriptor","done","p","access","init","__esDecorate","static","private","has","obj","resolution","configurable","writable","thisArg","useValue","arguments","__runInitializers","alias","resolve","resolveRoot","invoke","normalizeAliasSchema","aliasImplementation","neverIfDisjoint","never","RawBasis","units","literalKeys","domainImplementation","domain","metaKeys","intersectIntersections","lBasis","rBasis","basisResult","intersectionImplementation","rawSchema","structure","hasRootStructureKey","normalizedStructure","normalized","finalizeJson","rest","collapsibleJson","structureJson","minVariadicLength","sequenceJson","variadic","basis","morphInputKinds","morphImplementation","m","inTersection","inBranch","protoImplementation","builtinName","unionChildKinds","unionImplementation","ordered","reducedBranches","reduceBranches","describeBranches","pathDescriptions","branchesAtPath","errorAtPath","every","union","isNever","resultBranches","intersectBranches","UnionNode","_discriminate_decorators","discriminate","isBoolean","unitBranches","discriminant","discriminantJson","discriminantToJson","b","compileIndiscriminable","cases","caseKeys","const","serializedValue","casesBySpecifier","lIndex","rIndex","discriminantKinds","qualifiedDiscriminant","lSerialized","rSerialized","bestDiscriminantEntry","a","specifier","bestCases","parseDiscriminantKey","defaultBranches","caseBranches","prunedBranches","pruned","pruneDiscriminant","caseNode","default","descriptions","batchesByR","candidatesByR","branchIntersection","batch","uniquenessByIndex","j","lastPathIndex","lastIndexOf","discriminantKind","nodeKind","unitImplementation","preserveUndefined","rConstraint","compileEqualityCheck","negated","indexImplementation","signature","propertyKey","writeInvalidPropertyKeyMessage","enumerableBranches","writeEnumerableIndexBranches","valueIntersection","indexSchema","intersectProps","required","compiledKey","defaultIntersection","BaseProp","serializedKey","defaultValueMorphs","defaultValueMorphsReference","allowed","traverseKey","else","optionalImplementation","requiredImplementation","missingValueDescription","fixedSequenceKeySchemaDefinition","sequenceImplementation","optionals","postfix","postfixWithoutVariadicMessage","postfixFollowingOptionalMessage","isVariadicOnly","tuple","rootState","_intersectSequences","fixedVariants","viableBranches","sequenceTupleToInner","state","lHead","lTail","rHead","rTail","lHasPostfix","rHasPostfix","postfixBranchResult","lRemaining","rRemaining","arrayIndexMatcher","arrayIndexMatcherReference","StructureNode","_keyof_decorators","props","propsByKey","propsByKeyReference","structuralExpression","requiredLiteralKeys","optionalLiteralKeys","concat","exhaustive","omitFromInner","merge","_traverse","errorCount","initializeErrorCount","check","returnIfFailFast","for","compileExhaustiveEntry","let","createStructuralWriter","childStringProp","parts","objectLiteralDescription","structuralDescription","structureImplementation","behavior","lInner","rInner","lKey","disjointRKeys","indexOverlap","normalizeIndex","rKey","disjointLKeys","nonEnumerableBranches","list","by","spliterate","nodeImplementationsByKind","nodeClassesByKind","getBaseDomainKeys","compiledValue","serializedConstructor","serializedMorphs","compiledMorphs","lastMorph","refinements","returnIfFail","instance","serializedPredicate","freeze","prevariadic","minLengthNode","maxLengthNode","childAtIndex","firstPostfixIndex","dataIndex","keyExpression","nonNegativeIntegerString","sequenceInnerToTuple","RootModule","baseKeys","schemaKindOf","allowedKinds","discriminateRootKind","schemaKeys","nodeCache","serializeListableChild","listableNode","NodeCompiler","discriminants","requiresContextFor","reference","accessExpression","requiresContext","writeMethod","defaultConfig","jitless","registerKeywords","prereducedAliases","nonInheritedKeys","extendConfig","extension","extensions","mergeConfigs","writeDuplicateAliasError","nodeCountsByPrefix","scopeCount","RawRootScope","_schema_decorators","_defineRoot_decorators","_units_decorators","defineRoot","resolutions","exportedNames","aliases","resolved","ambient","resolveConfig","export","uniqueValues","lazyResolutions","syntheticAlias","synthetic","nodeSchema","schemaBranchesOf","normalizedSchema","schemaEntries","keyImpl","typeJson","collapsibleKeys","reduceTo","reduced","parseNode","bindCompiledScope","maybeResolveRoot","writeUnresolvableMessage","maybeResolveGenericOrRoot","maybeResolve","writeMissingSubmoduleAccessMessage","preparseRoot","maybeShallowResolve","g","maybeResolveSubalias","resolveSubalias","import","names","_exportedResolutions","_exports","resolutionsOfModule","dotIndex","dotPrefix","prefixSchema","writeNonSubmoduleDotMessage","subalias","schemaScope","RootScope","typeSet","prefixedResolutions","innerK","innerV","compiledTraversals","compileScope","allowsCompiler","applyCompiler","tsKeywords","any","false","true","void","internalKeywords","jsObjects","defineRegex","parseFloat","parsed","isSafeInteger","url","URL","parsing","date","tryParseDatePattern","ipv4Segment","ipv4Address","ipv4","ipv6Segment","ipv6","ip","email","uuid","semver","creditCard","creditCardInput","sanitized","replace","digit","tmpNum","sum","shouldDouble","substring","validation","alpha","alphanumeric","lowercase","uppercase","ambientRootScope","keywordNodes","Generic","Scanner","chars","lookahead","nextLookahead","shiftUntil","shifted","escapeToken","shiftUntilNextTerminator","shiftUntilNonWhitespace","lookaheadIsTerminator","lookaheadIsNotWhitespace","jumpToIndex","location","unscanned","scanned","sliceChars","start","end","lookaheadIs","char","lookaheadIsIn","tokens","scanner","terminatingChars","whiteSpaceTokens","finalizingLookaheads","lookaheadIsFinalizing","trimStart","parseEntry","parsedKey","parseKey","invalidDefaultKeyKindMessage","minComparators","maxComparators","invertedComparators","writeUnclosedGroupMessage","missingChar","writeUnpairableComparatorMessage","_parseGenericArgs","argDefs","argNodes","argState","parseUntilFinalizer","finalizer","writeInvalidGenericArgsMessage","writeMissingOperandMessage","previousOperator","writeMissingRightOperandMessage","writeExpressionExpectedMessage","appendElement","requiredPostOptionalMessage","optionalPostVariadicMessage","multipleVariadicMesage","appendSpreadBranch","spread","parseBranchTuple","writeMalformedFunctionalExpressionMessage","indexOneParsers","prefixParsers","instanceof","writeInvalidConstructorMessage","writeBadDefinitionTypeMessage","isValidDate","d","writeInvalidDateMessage","oneCharComparators","comparatorStartChars","getBoundKinds","boundKind","writeInvalidLimitMessage","writeUnboundableMessage","writeInvalidDivisorMessage","parseOperator","setRoot","incompleteArrayTokenMessage","pushRootToBranch","finalizeGroup","shiftComparator","reduceLeftBound","unsetRoot","literal","previousRoot","previousScannerIndex","parseOperand","limitNode","limitToken","constrainRoot","leftBound","lowerBoundKind","parseRightBound","parseBound","divisorToken","parseDivisor","writeUnexpectedCharacterMessage","shouldBe","parseGenericParams","_parseGenericParams","param","nextNonWhitespace","parseEnclosed","enclosing","enclosed","untilLookaheadIsClosing","enclosingTokens","writeUnterminatedEnclosedMessage","enclosingQuote","stringParsedDate","epochMillis","numberParsedDate","maybeParseDate","enclosingChar","enclosingCharDescriptions","fragment","enclosingStart","shiftedByOne","reduceGroupOpen","addPrefix","parsedArgs","parseGenericArgs","remainingChars","parseGenericInstantiation","maybeParseReference","maybeNumber","maybeBigint","maybeIntegerLiteral","BigInt","tryParseWellFormedBigint","maybeParseUnenclosedLiteral","unenclosedToNode","parseUnenclosed","next","hasRoot","DynamicState","prefixes","groups","finalizeBranches","invertedComparator","openLimit","openComparator","writeMultipleLeftBoundsMessage","assertRangeUnset","applyPrefixes","topBranchState","lastPrefix","typeParserAttachments","RawTypeParser","RawScope","parseCache","parseScopeKey","type","match","createMatchParser","declare","define","parseString","objectKind","parsedEntries","spreadEntry","spreadNode","writeInvalidSpreadTypeMessage","normalizedSignature","structureNode","parseObjectLiteral","isIndexZeroExpression","isIndexOneExpression","maybeParseTupleExpression","sequences","parseTupleLiteral","parseTuple","resolvedDef","parseObject","endsWith","fullStringParse","firstParamIndex","scope","_schemaOptions","resolverOptions","toNestErrors","shouldUseNativeValidation","validateFieldsNatively"],"mappings":"6TAgBO,MAWMA,EAAgBC,MAChBC,EAAW,CAACC,EAAOC,IAAYD,EAAMD,SAASE,GAW9CC,EAAS,CAACC,EAAIC,EAAOC,SAChBC,IAAVF,EACOD,GAAM,QACNG,IAAPH,OACkBG,IAAVF,EAAsB,GACxBN,MAAMS,QAAQH,GAASA,EACnB,CAACA,IAEXC,GAAMG,QACNV,MAAMS,QAAQH,GAASD,EAAGM,WAAWL,GAASD,EAAGM,QAAQL,GAEzDN,MAAMS,QAAQH,GAASD,EAAGO,QAAQN,GAASD,EAAGO,KAAKN,GAChDD,GA6BEQ,EAAe,CAACR,EAAIC,SAClBE,IAAPH,EACO,CAACC,IACPD,EAAGJ,SAASK,IACbD,EAAGO,KAAKN,GACLD,GCrFJ,MAAMS,UAA6BC,OAEnC,MAAMC,EAAqBC,GAAWC,EAAWD,EAASH,GACpDI,EAAa,CAACD,EAASE,EAAOJ,SACvC,MAAM,IAAII,EAAKF,EAAQ,EAEpB,MAAMG,UAAmBL,MAC5BM,KAAO,aAEJ,MAAMC,EAAkBL,GAAWC,EAAWD,EAASG,GCRvD,SAASG,EAAUC,EAAGC,GACzB,MAAMC,EAAe1B,MAAMS,QAAQe,GAC7BG,EAAUC,OAAOD,QAAQH,GAAGK,QAAQ,CAACC,EAAOC,KAC9C,MAAMC,EAASN,EAAeD,EAAaM,EAAGD,EAAM,IAAML,KAAgBK,EAAOC,GAQjF,OAPiB/B,MAAMS,QAAQuB,EAAO,KAAyB,IAAlBA,EAAOC,OAGhDD,EAGE,CAACA,EACQ,GAEbE,EAAeN,OAAOO,YAAYR,GACxC,MAAkC,iBAApBA,EAAQ,KAAK,GACvBC,OAAOQ,OAAOF,GACZA,CACV,CCjBO,MAAMG,EAAab,GAAMI,OAAOD,QAAQH,GAClCW,EAAeR,GAAYC,OAAOO,YAAYR,GAE9CW,EAAU,CAACC,EAAGf,IAAMe,KAAKf,EAIzBgB,EAAmB,MAC5B,WAAAC,CAAYC,GACRd,OAAOe,OAAOC,KAAMF,EACvB,GAGE,MAAMG,UAAoBL,GAE1B,MAAMM,EAAW,QAGjB,MAAMC,UAAqBD,GAE3B,MAAME,EAAc,CAACxB,EAAGyB,KAC3B,MAAMC,EAAI,CAAA,EACJC,EAAI,CAAA,EACV,IAAIZ,EACJ,IAAKA,KAAKf,EACFe,KAAKU,EACLC,EAAEX,GAAKf,EAAEe,GAETY,EAAEZ,GAAKf,EAAEe,GAEjB,MAAO,CAACW,EAAGC,EAAE,EAGJC,EAAO,CAAC5B,EAAG6B,IAASL,EAAYxB,EAAG6B,GAAM,GACzCC,EAAiB9B,GAAgC,IAA1BI,OAAOyB,KAAK7B,GAAGS,OACtCsB,EAA8B/B,GAAM,IAC1CI,OAAOD,QAAQH,MACfI,OAAO4B,sBAAsBhC,GAAGiC,IAAIlB,GAAK,CAACA,EAAGf,EAAEe,MAOzCmB,EAAQC,OAAO,qCC3CfC,EAAQ,CAACC,EAAQC,KAC1BA,EAAIC,eAAe,WACfnB,KAAKkB,EAAIzC,MAAQuB,KAAKkB,EAAIzC,MAAM2C,KAAKpB,KAC7C,EAAM,EAEOqB,EAAS,CAACJ,EAAQK,IAAY,WACvC,MAAM5D,EAAQuD,EAAOM,KAAKvB,MAO1B,OANAhB,OAAOwC,eAAexB,KAAMsB,EAAQ7C,KAAuB,WAAjB6C,EAAQG,KAC9C,CAAE/D,SACA,CACEA,MAAO,IAAMA,EACbgE,YAAY,IAEbhE,CACX,EAKaiE,EAAWjE,GAA2B,mBAAVA,GAAyC,IAAjBA,EAAM2B,OAS1DuC,EAAkB,cAAcC,SACzC,WAAAhC,IAAeiC,GACX,MAAMC,EAASD,EAAKE,MAAM,GAAI,GACxBC,EAAOH,EAAKI,IAAI,GACtB,IACIC,SAASJ,EAAQE,EACpB,CACD,MAAOG,GACH,OAAOhE,EAAmB,8FACXgE,gCACAN,EAAKE,MAAM,GAAI,iCACpBF,EAAKI,IAAI,wBAEtB,CACJ,GAGE,MAAMG,UAAiBnC,EAC1B,WAAAL,CAAYyC,EAAG3E,GAEX,OADAwE,QACOnD,OAAOe,OAAOf,OAAOuD,eAAeD,EAAElB,KAAKzD,GAAMyD,MAAQpB,MAAOA,KAAKH,YAAY2C,WAAY7E,GAAM8E,OAC7G,EAWE,MAAMC,EA7Cc,CAACC,IACxB,IAAIvD,EAAS0B,EACb,MAAO,IAAO1B,IAAW0B,EAAS1B,EA2CD,MACjC,IACI,OAAO,IAAIyC,SAAS,eAAb,EACV,CACD,MAAOO,GACH,OAAO,CACV,GAjD0CO,GAAWvD,CAAO,EA2CxCwD,GC9DZC,EAAY,CAACC,EAAMrB,IAASsB,EAASD,KAAUrB,EAC/CsB,EAAYD,IACrB,MAAME,SAAqBF,EAC3B,MAAwB,WAAhBE,EACK,OAATF,EACI,OACE,SACY,aAAhBE,EAA6B,SACzBA,CAAa,EAedC,EAAqB,CAP9BC,OAAQ,WACRC,OAAQ,WACRC,OAAQ,YACRC,OAAQ,WACRC,OAAQ,WATRC,QAAS,UACTC,KAAM,OACN5F,UAAW,aCTF6F,EAAsB,CAC/BrG,YACAsG,UACAvF,YACA0D,kBACA8B,QACAC,cACAC,QACAC,cACAC,cACAC,gBACAC,gBACAC,gBACAC,iBAESC,EAAgBtB,IACzB,IAAIN,EAAYxD,OAAOqF,eAAevB,GACtC,KAAON,GAAW3C,eACZH,EAAQ8C,EAAU3C,YAAYpB,KAAMgF,MAChCX,aAAgBW,EAAoBjB,EAAU3C,YAAYpB,SAChE+D,EAAYxD,OAAOqF,eAAe7B,GACtC,MAAM/D,EAAO+D,GAAW3C,aAAapB,KACrC,QAAab,IAATa,GAA+B,WAATA,EAE1B,OAAOA,CAAI,EAEF6F,EAAwBxB,GAA0B,iBAATA,GAA8B,OAATA,EACvEsB,EAAatB,IAAS,SACpBC,EAASD,GAEFjF,EAAWiF,GAAS1F,MAAMS,QAAQiF,GAElCyB,EAAyB,CAClCnH,MAAO,WACPyE,SAAU,aACV6B,KAAM,SACNE,OAAQ,WACRzF,MAAO,WACPwF,IAAK,QACLE,IAAK,QACLC,OAAQ,kBACRC,OAAQ,kBACRC,QAAS,mBACTG,QAAS,YACTF,QAAS,YACTC,QAAS,aAIAM,EAAkCjG,IAC3C,MAAMkG,EAAkBzF,OAAOT,GAAME,MAAQ,KAC7C,OAAQgG,GACJ/E,EAAQ+E,EAAiBhB,IACzBA,EAAoBgB,KAAqBlG,EACzCkG,EACE,IAAI,EAkBDC,EAAmBhH,IAC5B,MAAM0B,EAAS,GACf,IAAIuF,EAAOjH,EACX,KAAOiH,IAAS3F,OAAOwD,WAAhBmC,MAA6BA,GAAqC,CACrE,IAAK,MAAMhF,KAAKX,OAAO4F,oBAAoBD,GAC7B,gBAANhF,GAAwBP,EAAO/B,SAASsC,IACxCP,EAAOpB,KAAK2B,GACpB,IAAK,MAAM2D,KAAUtE,OAAO4B,sBAAsB+D,GACzCvF,EAAO/B,SAASiG,IACjBlE,EAAOpB,KAAKsF,GACpBqB,EAAO3F,OAAOqF,eAAeM,EAChC,CACD,OAAOvF,CAAM,EAEXyF,EAAmB,CACrB3B,OAAQwB,EAAgB,IACxBnB,QAASmB,GAAgB,GACzBlB,KAAM,GACNL,OAAQuB,EAAgB,GAExBtB,OAAQ,GACRC,OAAQqB,EAAgB,IACxBpB,OAAQoB,EAAgB3D,UACxBnD,UAAW,IAGFkH,EAAqB,CAACvG,EAAMwG,KACrC,IAAIC,EAAUzG,EAAKiE,UACnB,KAAmB,OAAZwC,GAAkB,CACrB,GAAIA,IAAYD,EAAKvC,UACjB,OAAO,EACXwC,EAAUhG,OAAOqF,eAAeW,EACnC,CACD,OAAO,CAAK,EC9GHC,EAAsBvH,GAA4B,iBAAVA,EAAqBwH,KAAKC,UAAUzH,GAClE,iBAAVA,EAAqB,GAAGA,KAC3B,GAAGA,ICEA0H,EAAW,CAAA,EACxBC,WAAWC,KAAOF,EAClB,MAAMG,EAAoB,IAAItB,QACxBuB,EAAa,CAAA,EACNC,EAAY/H,IACrB,MAAMgI,EAAeH,EAAkBI,IAAIjI,GAC3C,GAAIgI,EACA,OAAOA,EACX,IAAIjH,EAAOmH,EAAYlI,GAOvB,OANI8H,EAAW/G,GACXA,EAAO,GAAGA,IAAO+G,EAAW/G,OAE5B+G,EAAW/G,GAAQ,EACvB2G,EAAS3G,GAAQf,EACjB6H,EAAkBM,IAAInI,EAAOe,GACtBA,CAAI,EAGFqH,EAAuBpI,GADD,QACqB+H,EAAS/H,KACpDqI,EAAmBC,GAAY,6BAA6BC,KAAKD,GACjEE,EAA0BxI,GAAUmF,EAAUnF,EAAO,WAA8B,iBAAVA,EAClFoI,EAAoBpI,GAClBuH,EAAmBvH,GACnBkI,EAAelI,IACjB,cAAeA,GACX,IAAK,SAAU,CACX,GAAc,OAAVA,EACA,MACJ,MAAMyI,EAAS/B,EAAa1G,IAAU,SAEtC,OAAOyI,EAAO,GAAGC,cAAgBD,EAAOnE,MAAM,EACjD,CACD,IAAK,WACD,OAAO+D,EAAgBrI,EAAMe,MAAQf,EAAMe,KAAO,KACtD,IAAK,SACD,OAAOf,EAAM2I,aAAeN,EAAgBrI,EAAM2I,aAC9C3I,EAAM2I,YACJ,SAEd,OAAOjI,EAAmB,6DAA6D2E,EAASrF,KAAS,ECxCtG,MAAM4I,UAAyBnG,EAClCoG,SACAtE,KAAO,GACP,WAAApC,IAAeiC,GACXK,QACAnC,KAAKuG,SAAWzE,EAChB,IAAK,MAAM0E,KAAO1E,EAAM,CACpB,GAAI0E,KAAOxG,KACP,MAAM,IAAI7B,MAAM,aAAaqI,2DAGjCxG,KAAKwG,GAAOA,CACf,CACJ,CACDC,YAAc,EACd,MAAAC,GAEI,OADA1G,KAAKyG,aAAe,EACbzG,IACV,CACD,MAAA2G,GAEI,OADA3G,KAAKyG,aAAe,EACbzG,IACV,CACD,IAAA4G,CAAKC,EAAKC,GAAW,GACjB,OAAOC,EAAyBF,EAAKC,EACxC,CACD,KAAAE,CAAMH,EAAKC,GAAW,GAClB,OAAOG,GAAgB,GAAGJ,IAAOC,EACpC,CACD,IAAAI,CAAKC,GAGD,OADAnH,KAAKiC,MAAQ,GAAG,IAAImF,OAAOpH,KAAKyG,eAAeU,MACxCnH,IACV,CACD,MAAMqH,EAAYC,GAEd,OADAtH,KAAKkH,KAAK,SAASG,OAAgBC,KAC5BtH,IACV,CACD,IAAIqH,EAAYC,GACZ,OAAOtH,KAAKkH,KAAK,OAAOG,OAAgBC,IAC3C,CACD,GAAAzB,CAAIwB,EAAYC,GACZ,OAAOtH,KAAKkH,KAAK,GAAGG,OAAgBC,IACvC,CACD,GAAGC,EAAWC,GACV,OAAOxH,KAAKyH,MAAM,OAAOF,KAAcC,EAC1C,CACD,MAAAE,CAAOH,EAAWC,GACd,OAAOxH,KAAKyH,MAAM,YAAYF,KAAcC,EAC/C,CACD,KAAKA,GACD,OAAOxH,KAAKyH,MAAM,OAAQD,EAC7B,CAED,IAAIG,EAAO1F,EAAM2F,EAAe,GAC5B,OAAO5H,KAAKyH,MAAM,gBAAgBG,MAAiBD,UAAe1F,EACrE,CAED,KAAA4F,CAAMzE,EAAQnB,GACV,OAAOjC,KAAKyH,MAAM,mBAAmBrE,KAAWnB,EACnD,CACD,KAAAwF,CAAMtB,EAAQ2B,EAAUC,EAAS,IAK7B,OAJA/H,KAAKkH,KAAK,GAAGf,OACbnG,KAAK0G,SACLoB,EAAS9H,MACTA,KAAK2G,SACE3G,KAAKkH,KAAK,IAAIa,IACxB,CACD,OAAOT,EAAa,IAChB,OAAOtH,KAAKkH,KAAK,UAAUI,IAC9B,CACD,OAAAU,GACI,OAAO,IAAIpG,KAAmB5B,KAAKuG,SAAUvG,KAAKiC,KACrD,EAEE,MAAM8E,EAA2B,CAACF,EAAKC,GAAW,IAClC,iBAARD,GAAoBd,EAAgBc,GACpC,GAAGC,EAAW,IAAM,MAAMD,IAC9BI,GAAgBgB,EAAoBpB,GAAMC,GAExCmB,EAAuBpB,GAAuB,iBAARA,EAAmBf,EAAoBe,GAAO3B,KAAKC,UAAU0B,GACnGI,GAAkB,CAACJ,EAAKC,GAAW,IAAU,GAAGA,EAAW,KAAO,MAAMD,KCnF9E,IAAIqB,IACX,SAAWA,GAGPA,EAAIC,KAFJ,QAKAD,EAAIE,aAFJ,QAGAF,EAAIG,MAASC,GAAQA,EAAIC,IAGzBL,EAAIM,UAFJ,QAGAN,EAAIO,KAAO,IAAIC,IAAUC,GAAMD,EAAME,OAAO,CAACC,EAAKpH,IAASA,EAAK8G,IAAIM,GAAMF,EAC7E,CAZD,CAYGT,KAAQA,GAAM,CAAA,ICEV,MAAMY,GAA0B,4CAC1BC,GAAqBD,GAAwB7C,KAAK7E,KAAK0H,IAC9DE,GAAoB,gBAObC,GAA2B,yBAC3BC,GAAsBD,GAAyBhD,KAAK7E,KAAK6H,IAChEE,GAAqB,UACrBC,GAAgBD,GAAmBlD,KAAK7E,KAAK+H,IAC7CE,GAA6B,CAC/BlG,OAAQ,WACRD,OAAQ,WACRoG,QAAS,cAEAC,GAAsC,CAACjB,EAAK7G,IAAS,IAAI6G,oBAAsBe,GAA2B5H,2HAI1G+H,GAAiB,CAACC,EAAOC,IAAYC,GAAaF,EAAO,SAAUC,GAE1EC,GAAe,CAACF,EAAOhI,EAAMiI,KAC/B,MAAMhM,EALQ,EAAC4K,EAAK7G,IAAkB,WAATA,EAAoBsC,OAAOuE,GAAOvE,OAAO6F,SAAStB,GAKjEuB,CAAUJ,EAAOhI,GAC/B,OAAKsC,OAAO+F,MAAMpM,IALH,EAAC4K,EAAK7G,KAASA,MAAS,WAATA,EAlBO,KAAnBsI,EAkB6CzB,GAlBrCjJ,QAAgB2J,GAAkB/C,KAAK8D,GAkBKX,GAAcd,GAlBnE,IAACyB,CAkBsE,EAMhFC,CAAWP,EAAOhI,GACdiI,GAASO,OATJ,EAAC3B,EAAK7G,IAAkB,WAATA,EAAoBsH,GAAmBT,GAAOY,GAAoBZ,GAU/E4B,CAAaT,EAAOhI,GAAQ/D,EAASgB,EAAgB6K,GAAoCE,EAAOhI,IAEpG/D,EAGPgM,GAASS,YACbzL,GAAyC,IAAzBgL,GAASS,YACrB,mBAAmBd,GAA2B5H,YAAegI,KAC3DC,GAASS,kBACbvM,CAAW,ECjDRwM,GAAY,CAACtH,EAAM4D,KAC5B,OAAQ3D,EAASD,IACb,IAAK,SACD,OAAOA,aAAgBY,KACnBZ,EAAKuH,eACHnF,KAAKC,UAAUmF,GAAWxH,EAAMyH,GAAe,IAAK,KAAM7D,GACpE,IAAK,SACD,OAAO6D,GAAcC,SAAS1H,GAClC,QACI,OAAOmC,EAAmBnC,GACjC,EAECyH,GAAgB,CAClBE,QAAS,IAAM,UACfD,SAAUE,GAAK,UAAUjF,EAASiF,MAClCC,WAAYD,GAAK,YAAYjF,EAASiF,OAEpCJ,GAAa,CAACxH,EAAMnF,EAAMiN,KAC5B,OAAQ7H,EAASD,IACb,IAAK,SAAU,CACX,GAAoB,mBAATA,EACP,OAAOyH,GAAcI,WAAW7H,GACpC,GAAI8H,EAAKvN,SAASyF,GACd,MAAO,UACX,MAAM+H,EAAW,IAAID,EAAM9H,GAC3B,GAAI1F,MAAMS,QAAQiF,GACd,OAAOA,EAAKjC,IAAIiK,GAAQR,GAAWQ,EAAMnN,EAAMkN,IACnD,GAAI/H,aAAgBY,KAChB,OAAOZ,EAAKuH,eAChB,MAAMjL,EAAS,CAAA,EACf,IAAK,MAAMO,KAAKmD,EACZ1D,EAAOO,GAAK2K,GAAWxH,EAAKnD,GAAIhC,EAAMkN,GAC1C,OAAOzL,CACV,CACD,IAAK,SACD,OAAOmL,GAAcC,SAAS1H,GAClC,IAAK,SACD,MAAO,GAAGA,KACd,IAAK,YACD,OAAOnF,EAAKoN,aAAe,YAC/B,QACI,OAAOjI,EACd,EC9CQkI,GAAqCpM,GAGlDD,EAAUC,EAAG,CAACe,EAAG+K,IAAM,CAAC/K,EAAG9B,EAAQ6M,GAAK,IAAIA,GAAKA,IAOpCO,GAAUlK,OAAO,uBACjBmK,GAAa,CAACxN,EAAO+D,IAAS/D,IAAQuN,MAAaxJ,EACnD0J,GAAUzN,GAAUwN,GAAWxN,EAAO,SAAWwN,GAAWxN,EAAO,cCXnE0N,GAAa,CAAC,OAAQ,QAAS,UAC/BC,GAAkB,CAC3B,WACA,WACA,QACA,YAESC,GAAkB,CAC3B,QACA,UACA,cACA,MACA,MACA,YACA,YACA,SACA,SAESC,GAAkB,IACxBD,MACAD,GACH,YACA,aAESG,GAAY,CACrB,QACA,QACA,QACA,OACA,eACA,QACA,UAESC,GAAY,IAAID,MAAcD,IAC9BG,GAAiB/M,EAAU4M,GAAiB,CAACpM,EAAGsC,IAAS,CAACA,EAAM,IAChEkK,GAAgBhN,EAAU,IAAI0M,GAAiB,cAAe,CAAClM,EAAGQ,IAAM,CAACA,EAAG,IAC5EiM,GAAmBjN,EAAU8M,GAAW,CAACtM,EAAGsC,IAAS,CAACA,EAAMtC,IAC5D0M,GAAcnO,GAA2B,iBAAVA,GAAsBA,KAASkO,GAO9DE,GAAoBrK,GAASmK,GAAiBnK,GAC9CsK,GAAsBtK,GAAS+J,GAAUxJ,MAAM8J,GAAiBrK,GAAQ,GACxEuK,GAA0BtB,GAClB,iBAANA,GACM,kBAANA,GACM,iBAANA,GACD,OAANA,EACOA,EACJxE,EAAuBwE,GAErBuB,GAAuB/K,IAChC,IAAI9B,EAAS,KACb,IAAK,MAAOO,EAAG+K,KAAM1L,OAAOD,QAAQmC,GAChC9B,GAAU,GAAGO,MAAMuG,EAAuBwE,OAC9C,OAAOtL,EAAS,IAAI,EAEX8M,GAAiBC,IAC1B,MAAMC,EAAiBD,EAkBvB,OAjBIC,EAAeC,qBACfD,EAAeE,SAASC,WAAarL,GAAO,gBAAiBA,EACzDA,EAAImF,YACF+F,EAAeE,SAASjG,YAAYnF,GAC1CkL,EAAeE,SAASE,SAAW1J,GAAQsH,GAAUtH,GACrDsJ,EAAeE,SAASG,UAAYvL,GAAO,WAAWA,EAAIqL,WAAWrL,EAAIsL,OAAS,SAAStL,EAAIsL,UAAY,KAC3GJ,EAAeE,SAASjO,UAAY6C,IAChC,GAAwB,IAApBA,EAAIwL,KAAKrN,OACT,OAAO6B,EAAIuL,QACf,MAAME,EAAsB,GAAGzL,EAAI0L,cAAc1L,EAAIuL,UACrD,MAA+B,MAA3BE,EAAoB,GAEb,YAAYA,IAEhBA,CAAmB,GAG3BP,CAAc,EChFZS,GAAe,CAAA,ECCrB,MAAMC,WAAiB3M,EAC1B4M,MACA9B,CAACA,IAAW,QACZyB,KACA5J,KACAkK,WACA,WAAAnN,CAAYkN,EAAO7L,GACfiB,QACAnC,KAAK+M,MAAQA,EbiCrB/N,OAAOiO,iBahCkBjN,KbgCKhB,OAAOkO,0BahCNH,IACvB,MAAMjK,EAAO5B,EAAI4B,KACE,UAAfiK,EAAMI,OAENJ,EAAMK,OAASL,EAAMK,OAAOnO,QAAQmD,GAAKA,EAAEiL,QAAQ,SAAWjL,EAAEgL,OAAShL,IAE7EpC,KAAKgN,WAAa9L,EAAIoM,OAAOtN,KAAKmN,MAClCnN,KAAK0M,KAAOK,EAAML,MAAQ,IAAIxL,EAAIwL,MAC9BK,EAAMQ,cACNvN,KAAK0M,KAAK1O,QAAQ+O,EAAMQ,cAC5BvN,KAAK8C,KAAO,SAAUiK,EAAQA,EAAMjK,KAAOA,CAC9C,CACD,OAAAuK,CAAQF,GACJ,OAAOnN,KAAKmN,OAASA,CACxB,CACD,cAAIP,GACA,MHtBwB,CAACF,IAC7B,MAAMc,EGqBsBxN,KAAK0M,KHrBJ9D,OAAO,CAACmB,EAAGpK,IAAmB,iBAANA,GAAkBoG,EAAgBpG,GACnF,GAAGoK,KAAKpK,IACN,GAAGoK,KAAKK,GAAUzK,MAAO,IAC/B,MAA8B,MAAvB6N,EAAgB,GAAaA,EAAgBxL,MAAM,GAAKwL,CAAe,EGkBnEC,EACV,CACD,YAAIlB,GACA,OAAQvM,KAAK+M,MAAMR,UAAYvM,KAAKgN,WAAWT,WAAWvM,KAAK+M,MAClE,CACD,UAAIP,GAGA,YAA6B5O,IAAtBoC,KAAK+M,MAAMP,OACdxM,KAAK+M,MAAMP,OACTxM,KAAKgN,WAAWR,SAASxM,KAAK8C,KACvC,CACD,WAAI2J,GACA,OAAOzM,KAAK+M,MAAMN,SAAWzM,KAAKgN,WAAWP,QAAQzM,KACxD,CACD,WAAI3B,GACA,OAAO2B,KAAK+M,MAAM1O,SAAW2B,KAAKgN,WAAW3O,QAAQ2B,KACxD,CACD,QAAA0N,GACI,OAAO1N,KAAK3B,OACf,CACD,QACI,MAAM2B,IACT,EAEE,MAAM2N,WAAkBxQ,EAC3B+D,IACA,WAAArB,CAAYqB,GACRiB,QACAnC,KAAKkB,IAAMA,CACd,CACD0M,OAAS,CAAA,EACTC,MAAQ,EACRC,QAAU9N,KACV,GAAA+N,CAAIC,GACA,MAAMC,EAAWjO,KAAK4N,OAAOI,EAAMpB,YACnC,GAAIqB,EAAU,CACV,MAAMC,EAAoB,IAAIpB,GAAS,CACnCK,KAAM,eACNC,OAAQa,EAASZ,QAAQ,gBACrB,IAAIY,EAASb,OAAQY,GACnB,CAACC,EAAUD,IAClBhO,KAAKkB,KACFiN,EAAgBnO,KAAKoO,QAAQH,GAInCjO,KAAK8N,SAA2B,IAAnBK,EAAuBnO,KAAKX,OAAS8O,GAC9CD,EACJlO,KAAK4N,OAAOI,EAAMpB,YAAcsB,CACnC,MAEGlO,KAAK4N,OAAOI,EAAMpB,YAAcoB,EAChChO,KAAK8N,QAAQ9P,KAAKgQ,GAEtBhO,KAAK6N,OACR,CACD,WAAIQ,GACA,OAAOrO,KAAK0N,UACf,CACD,WAAIrP,GACA,OAAO2B,KAAK0N,UACf,CACD,QAAAA,GACI,OAAO1N,KAAKsO,KAAK,KACpB,CACD,QACI,MAAMtO,IACT,EC9FE,MAAMuO,GACTC,KACAlB,OACAZ,KAAO,GACP+B,aAAe,GACfrB,OAAS,IAAIO,GAAU3N,MACvB0O,SAAW,GACX9D,KAAO,CAAA,EACP,WAAA/K,CAAY2O,EAAMlB,GACdtN,KAAKwO,KAAOA,EACZxO,KAAKsN,OAASA,CACjB,CACD,iBAAIqB,GACA,OAAO3O,KAAK0O,SAASxM,IAAI,EAC5B,CACD,WAAA0M,CAAYC,GACR,MAAM9B,EAAQ,CACVL,KAAM,IAAI1M,KAAK0M,MACfmC,UAEJ7O,KAAK2O,eAAeF,aAAazQ,KAAK+O,IAClC/M,KAAKyO,aAAazQ,KAAK+O,EAC9B,CACD,QAAA+B,GACI,GAAI9O,KAAK+O,WACL,OAAO/O,KAAKoN,OAChB,IAAIvE,EAAM7I,KAAKwO,KACf,GAAIxO,KAAKyO,aAAapP,OAClB,IAAK,IAAIF,EAAI,EAAGA,EAAIa,KAAKyO,aAAapP,OAAQF,IAAK,CAC/C,MAAMuN,KAAEA,EAAImC,OAAEA,GAAW7O,KAAKyO,aAAatP,GACrC0H,EAAM6F,EAAKxK,IAAI,GACrB,IAAI8M,EACJ,QAAYpR,IAARiJ,EAAmB,CAEnBmI,EAASnG,EACT,IAAK,IAAIoG,EAAY,EAAGA,EAAYvC,EAAKrN,OAAS,EAAG4P,IACjDD,EAASA,EAAOtC,EAAKuC,GAC5B,CACDjP,KAAK0M,KAAOA,EACZ,IAAK,MAAMwC,KAASL,EAAQ,CACxB,MAAMzP,EAAS8P,OAAiBtR,IAAXoR,EAAuBnG,EAAMmG,EAAOnI,GAAM7G,MAC/D,GAAIZ,aAAkBuO,GAClB,OAAOvO,EACX,GAAIY,KAAK+O,WACL,OAAO/O,KAAKoN,OAChB,GAAIhO,aAAkB0N,GAIlB,OADA9M,KAAKgO,MAAM5O,GACJY,KAAKoN,YAIDxP,IAAXoR,EACAnG,EAAMzJ,EAEN4P,EAAOnI,GAAOzH,CACrB,CACJ,CAEL,OAAOyJ,CACV,CACD,qBAAIsG,GACA,OAAQnP,KAAK2O,cACT3O,KAAK2O,cAAcX,MACf,EACE,EACJhO,KAAKoN,OAAOS,KACrB,CACD,QAAAkB,GACI,OAAkC,IAA3B/O,KAAKmP,iBACf,CACD,YAAIC,GACA,OAAgC,IAAzBpP,KAAK0O,SAASrP,MACxB,CACD,KAAA2O,CAAMjB,GACF,MAAMsC,EAA0B,iBAAVtC,EAClBA,EAAMI,KACFJ,EACE,IAAKA,EAAOI,KAAM,aACtB,CAAEA,KAAM,YAAaZ,SAAUQ,GAC/BiB,EAAQ,IAAIlB,GAASuC,EAAQrP,MAKnC,OAJIA,KAAK2O,cACL3O,KAAK2O,cAAcX,MAAQA,EAE3BhO,KAAKoN,OAAOW,IAAIC,GACbA,CACV,CACD,QAAIlL,GACA,IAAI1D,EAASY,KAAKwO,KAClB,IAAK,MAAMc,KAAWtP,KAAK0M,KACvBtN,EAASA,IAASkQ,GACtB,OAAOlQ,CACV,CACD,OAAAmQ,CAAQxC,GAEJ,OADA/M,KAAKgO,MAAMjB,IACJ,CACV,CACD,UAAAyC,GACIxP,KAAK0O,SAAS1Q,KAAK,CACfgQ,WAAOpQ,EACP6Q,aAAc,IAErB,CACD,SAAAgB,GACI,OAAOzP,KAAK0O,SAASgB,KACxB,ECxGE,MAAMC,WAAiBtN,EAC1BuN,YACA,WAAA/P,CAAY+P,GACRzN,MAGA,CAACW,EAAM+M,KACH,IAAK7P,KAAK8P,gBACL9P,KAAK+P,uBACN/P,KAAKgQ,OAAOlN,GACZ,OAAOA,EACX,GAAI+M,EACA,OAAO7P,KAAKiQ,cAAcnN,EAAM+M,GACpC,MAAM3O,EAAM,IAAIqN,GAAiBzL,EAAM9C,KAAKkQ,EAAEC,gBAE9C,OADAnQ,KAAKiQ,cAAcnN,EAAM5B,GAClBA,EAAI4N,UAAU,EACtB,CAAErM,OAAQmN,IACb5P,KAAK4P,YAAcA,CACtB,CACDQ,YAAc,GAAGpQ,KAAKkQ,EAAEG,KAAKrQ,KAAKqQ,KAClCP,cAA8B,UAAd9P,KAAKyB,MAChBzB,KAAKsQ,QAAQ,aAAetQ,KAAKuQ,cACjCvQ,KAAKsQ,QAAQ,cAAoC,WAApBtQ,KAAKwQ,YACnCxQ,KAAKyQ,SAASC,KAAKC,GAASA,EAAMb,eACtCC,sBAEC/P,KAAKsQ,QAAQ,cAAgD,IAAhCtQ,KAAK4Q,MAAMC,UAAUxR,QACjC,UAAdW,KAAKyB,MACLzB,KAAKyQ,SAASC,KAAKC,GAASA,EAAMZ,uBACtCe,eAAiB9Q,KAAKyQ,SAAS7H,OAAO,CAACxJ,EAAQuR,IAAU3R,OAAOe,OAAOX,EAAQuR,EAAMG,gBAAiB,CAAE,CAAC9Q,KAAKqQ,IAAKrQ,OACnH,cAAI+Q,GACA,OAAO/R,OAAOQ,OAAOQ,KAAK8Q,eAC7B,CACDE,WAAalF,GAAiB9L,KAAKyB,MACnCwP,KAAM,EACNjB,OAAUlN,GACF9C,KAAK+P,sBACE/P,KAAKkR,eAAepO,EAAM,IAAIyL,GAAiBzL,EAAM9C,KAAKkQ,EAAEC,iBAEhEnQ,KAAKkR,eAAepO,GAE/B,QAAAqO,CAASrO,GACL,OAAO9C,KAAK8C,EACf,CAIDsO,IACA,MAAI,GAEA,OADApR,KAAKoR,MAAQpR,KAAKqR,MAAM,MACjBrR,KAAKoR,GACf,CACDE,KACA,OAAIzI,GAEA,OADA7I,KAAKsR,OAAStR,KAAKqR,MAAM,OAClBrR,KAAKsR,IACf,CACDC,aACA,eAAIlL,GAIA,OAHArG,KAAKuR,eACDvR,KAAK4Q,MAAMvK,aACPrG,KAAKkQ,EAAEC,eAAenQ,KAAKyB,MAAM4E,cAAcrG,MAChDA,KAAKuR,YACf,CACD,KAAAF,CAAM5P,GACF,IAAKzB,KAAK8P,cACN,OAAO9P,KACX,MAAMwR,EAAU,CAAA,EAChB,IAAK,MAAO7R,EAAG+K,KAAM1K,KAAKjB,QAAS,CAC/B,MAAM0S,EAA0BzR,KAAK0R,KAAKjR,KAAKd,GAC/C,IAAI8R,EAAwBE,KAE5B,GAAIF,EAAwBd,MAAO,CAC/B,MAAMiB,EAAalH,EACnB8G,EAAQ7R,GACJ9B,EAAQ+T,GACJA,EAAW/Q,IAAI8P,GAASA,EAAMlP,IAC5BmQ,EAAWnQ,EACxB,MAEG+P,EAAQ7R,GAAK+K,CACpB,CACD,OAAO1K,KAAKkQ,EAAE2B,KAAK7R,KAAKyB,KAAM+P,EACjC,CACD,MAAAM,GACI,OAAO9R,KAAK+R,IACf,CACD,QAAArE,GACI,OAAO1N,KAAKsH,UACf,CACD,MAAA0K,CAAOC,GACH,OAAOjS,KAAKkS,WAAaD,EAAMC,QAClC,CACD,OAAA5B,CAAQ7O,GACJ,OAAOzB,KAAKyB,OAASA,CACxB,CACD,OAAA0Q,GACI,OAAO9U,EAAS+N,GAAYpL,KAAKyB,KACpC,CACD,YAAA2Q,GACI,OAAO/U,EAASkO,GAAiBvL,KAAKyB,KACzC,CACD,YAAA4Q,GACI,OAAOhV,EAASiO,GAAiBtL,KAAKyB,KACzC,CACD,MAAA6Q,GACI,OAAOjV,EAASmO,GAAWxL,KAAKyB,KACnC,CACD,OAAA8Q,CAAQ7U,GACJ,OAAOsC,KAAKsQ,QAAQ,SAAWtQ,KAAKgQ,OAAOtS,EAC9C,CACD,mBAAA8U,GACI,OAAOxS,KAAK0R,KAAKe,kBACpB,CACD,sBAAIC,GACA,OAAO1S,KAAKsH,UACf,CACD,SAAAqL,CAAUzC,GACN,OAAIlQ,KAAKkQ,IAAMA,EACJlQ,KACJ,IAAIA,KAAKH,YAAYb,OAAOe,QC3HdgN,ED2HkC/M,KAAK4P,YC3H7B5Q,OAAO4T,OAAO5T,OAAOqF,eAAe0I,GAAQ/N,OAAOkO,0BAA0BH,KD2HlC,CAAEmD,OC3HxD,IAACnD,CD4HxB,CACD,cAAA8F,CAAeC,GACX,OAAO9S,KAAK+Q,WAAWgC,KAAKC,GAAKA,IAAMhT,MAAQ8S,EAAOE,GACzD,CACD,qBAAAC,CAAsBH,GAClB,OAAQ9S,KAAK6S,eAAeC,IACxBxU,EAAW,GAAG0B,KAAKqQ,2CAA2CyC,IACrE,CACD,oBAAAI,CAAqBzR,GACjB,OAAOzB,KAAK6S,eAAgBhB,GAASA,EAAKpQ,OAASA,EACtD,CACD,2BAAA0R,CAA4B1R,GACxB,OAAQzB,KAAK6S,eAAehB,GAAQA,EAAKpQ,OAASA,IAC9CnD,EAAW,GAAG0B,KAAKqQ,aAAa5O,eACvC,CACD,SAAA2R,CAAUC,EAAQ1V,GACd,OAAOqC,KAAKsT,WAAWD,EAAQ,CAC3BzI,KAAM,CAAE,EACR8B,KAAM,GACN6G,gBAAiB5V,GAAM4V,iBAAoB,MAAM,IAExD,CACD,UAAAD,CAAWD,EAAQnS,GACf,GAAIA,EAAI0J,KAAK5K,KAAKqQ,IAId,OAAOrQ,KAAKkQ,EAAEsD,cAActS,EAAI0J,KAAK5K,KAAKqQ,KAC9C,IAAKnP,EAAIqS,gBAAgBvT,KAAMkB,GAC3B,OAAOlB,KACX,IAAIyT,EACJvS,EAAI0J,KAAK5K,KAAKqQ,IAAM,IAAMoD,EAC1B,MAAMC,EAA+B/U,EAAUqB,KAAK4Q,MAAO,CAACjR,EAAG+K,KAC3D,IAAK1K,KAAK0R,KAAKjR,KAAKd,GAAGgR,MACnB,MAAO,CAAChR,EAAG+K,GACf,MAAM+F,EAAW/F,EACjB,IAAK7M,EAAQ4S,GAAW,CACpB,MAAMkD,EAAclD,EAAS6C,WAAWD,EAAQnS,GAChD,OAAOyS,EAAc,CAAChU,EAAGgU,GAAe,EAC3C,CACD,MAAMA,EAAclD,EAASxR,QAAQ+T,GACRA,EAAEM,WAAWD,EAAQnS,IACnB,IAE/B,OAAOyS,EAAYtU,OAAS,CAACM,EAAGgU,GAAe,EAAE,UAE9CzS,EAAI0J,KAAK5K,KAAKqQ,IACrB,MAAMuD,EAAmBP,EAAOrT,KAAKyB,KAAMiS,EAA8BxS,GACzE,OAAyB,OAArB0S,GAGAlT,EAAckT,GAFP,KAIQ,aAAd5T,KAAKyB,MACQ,aAAdzB,KAAKyB,MACS,UAAdzB,KAAKyB,MACH,UAAWmS,GAEC,UAAd5T,KAAKyB,OAELmS,EAAiBC,KAAO7T,KAAKkQ,EAAE4D,SAC1BC,SAEDN,EAAkBzT,KAAKkQ,EAAE2B,KAAK7R,KAAKyB,KAAMmS,IANtC,IAOd,CACD,2BAAAI,CAA4BC,GACxB,MAAM3G,EAAwC,iBAAxB2G,EAClB,CAAE5N,YAAa4N,GACbA,EACN,OAAOjU,KAAKoT,UAAU,CAAC3R,EAAMmP,KAAW,IAAKA,KAAUtD,IAAW,CAC9DiG,gBAAiB1B,GAAsB,cAAdA,EAAKpQ,MAErC,EElME,MAAMyS,GACTC,QACA,WAAAtU,CAAYsU,GACRnU,KAAKmU,QAAUA,CAClB,CACD,KAAAC,GACI,OAAO,IAAIF,GAASlU,KAAKmU,QAC5B,CACD,WAAOE,CAAK5S,EAAMnB,EAAGC,GACjB,OAAO,IAAI2T,GAAS,CAChB,KAAM,CACFzS,CAACA,GAAO,CACJnB,IACAC,OAIf,CACD,kBAAOhB,CAAYR,GACf,OAAKA,EAAQM,OAGN,IAAI6U,GAAS,CAAE,KAAM3U,EAAYR,KAF7BX,EAAmB,0DAGjC,CACD,QAAIkW,GACA,OAAO7U,EAAUO,KAAKmU,SAASlV,QAAQ,EAAEyN,EAAM6H,KAAmB9U,EAAU8U,GAAe1T,IAAI,EAAEY,EAAM+S,MAAe,CAClH9H,OACAjL,OACA+S,cAEP,CACD,eAAAC,GACI,MAAMC,EAAU1U,KAAKsU,KACrB,GAAuB,IAAnBI,EAAQrV,OAAc,CACtB,MAAMqN,KAAEA,EAAI8H,SAAEA,GAAaE,EAAQ,GAC7BC,EAAazP,KAAK0P,MAAMlI,GAAM4B,KAAK,KACzC,MAAO,eAAeqG,GAAc,OAAOA,UAAmBF,GAAgBD,qCACjF,CACD,MAAO,iEAAiEE,EACnE7T,IAAI,EAAG6L,OAAM8H,cAAe,GAAG9H,MAAS+H,GAAgBD,MACxDlG,KAAK,SACb,CACD,OAAAuG,GACI,OAA4B,IAArB7U,KAAKsU,KAAKjV,MACpB,CACD,QACI,OAAOX,EAAgBsB,KAAKyU,kBAC/B,CACD,MAAAK,GACI,MAAMC,EAAkBtV,EAAUO,KAAKmU,SAAStT,IAAI,EAAE6L,EAAMsI,KAAe,CACvEtI,EACA/N,EAAUqW,EAAW,CAACvT,EAAM+S,IAAa,CACrC/S,EACA,CAAEnB,EAAGkU,EAASjU,EAAGA,EAAGiU,EAASlU,OAGrC,OAAO,IAAI4T,GAAS3U,EAAYwV,GACnC,CACD,GAAAhH,CAAIhB,GACAtN,EAAUsN,EAAMoH,SAASc,QAAQ,EAAEvI,EAAMsI,KAAehW,OAAOe,OAAOC,KAAKmU,QAAQzH,IAAS,CAAE,EAAEsI,GACnG,CACD,aAAAE,CAAcrO,GACV,MAAMsO,EAAoB1V,EAAUO,KAAKmU,SAAStT,IAAI,EAAE6L,EAAMsI,MAC1D,MAAMI,EAAWlQ,KAAK0P,MAAMlI,GAG5B,OAFA0I,EAASrX,QAAuB,iBAAR8I,EAAmBpB,EAASoB,GAAOA,GAEpD,CADgB3B,KAAKC,UAAUiQ,GACdJ,EAAU,GAEtC,OAAO,IAAId,GAAS3U,EAAY4V,GACnC,CACD,QAAAzH,GACI,OAAOtD,GAAUpK,KAAKmU,QACzB,EAEL,MAAMM,GAAmBY,GAAW,GAAGC,GAAeD,EAAO/U,UAAUgV,GAAeD,EAAO9U,KACvF+U,GAAkB5X,GAAUwN,GAAWxN,EAAO,QAAUA,EAAM4J,WAC9DzJ,EAAQH,GAASA,EAAMmD,IAAIyU,IAAgBhH,KAAK,OAC5CxK,OAAOpG,GC5EX6X,GAAoB,CAAA,EACbC,GAAqB,CAAClV,EAAGC,EAAG2P,IAAMuF,GAAenV,EAAGC,EAAG,CAAE2P,IAAG4E,QAAQ,EAAOrM,MAAM,IAEjFgN,GAAiB,CAACnV,EAAGC,EAAGW,KACjC,MAAMwU,EAAWxU,EAAIuH,KAAO,KAAO,IAC7BkN,EAAa,GAAGrV,EAAE4R,WAAWwD,IAAWnV,EAAE2R,WAChD,QAAsCtU,IAAlC2X,GAAkBI,GAClB,OAAOJ,GAAkBI,GAC7B,IAAKzU,EAAIuH,KAAM,CAEX,MAAMmN,EAAa,GAAGrV,EAAE2R,WAAWwD,IAAWpV,EAAE4R,WAChD,QAAsCtU,IAAlC2X,GAAkBK,GAA2B,CAG7C,MAAMC,EAAWN,GAAkBK,GAC7BE,EAAWD,aAAoB3B,GAAW2B,EAASf,SAAWe,EAGpE,OADAN,GAAkBI,GAAcG,EACzBA,CACV,CACJ,CACD,GAAIxV,EAAE0R,OAAOzR,GACT,OAAOD,EACX,IAAIlB,EACJ,GAAI8B,EAAIuH,MAAQnI,EAAEgQ,QAAQ,SACtBlR,EACI8B,EAAI4T,OACAiB,GAAYxV,EAAGD,EAAGY,GAChB8U,GAAc1V,EAAGC,EAAGW,QAE7B,GAAIA,EAAIuH,MAAQlI,EAAE+P,QAAQ,SAC3BlR,EACI8B,EAAI4T,OACAkB,GAAczV,EAAGD,EAAGY,GAClB6U,GAAYzV,EAAGC,EAAGW,OAE3B,CACD,MACMkL,EAAiB9L,EAAEoR,KAAKuE,cAAc1V,EAAEkB,OAASlB,EAAEmR,KAAKuE,cAAc3V,EAAEmB,MAC9ErC,OACuBxB,IAAnBwO,EAII,MAPa9L,EAAE0Q,WAAazQ,EAAEyQ,WAAa1Q,EAAEmB,KAAOlB,EAAEkB,QAQnCnB,EAAEmB,KAAO2K,EAAe9L,EAAGC,EAAGW,GAC3CkL,EAAe7L,EAAGD,EAAG,IAAKY,EAAK4T,QAAS5T,EAAI4T,QAC7D,CAUD,OATI3J,GAAO/L,KAGHkB,EAAE0R,OAAO5S,GACTA,EAASkB,EACJC,EAAEyR,OAAO5S,KACdA,EAASmB,IAEjBgV,GAAkBI,GAAcvW,EACzBA,CAAM,EAGJ4W,GAAgB,CAAC3B,EAAM5W,EAAIyD,KACpC,MAAM2N,EAAS,IAAIwF,EAAKxF,QACxB,GAAIwF,EAAK6B,aAAc,CAEnB,MAAMC,EAAkBV,GAAepB,EAAK6B,aAAczY,EAAIyD,GAC9D,GAAIiV,aAA2BjC,GAC3B,OAAOiC,EACXtH,EAAOA,EAAOxP,OAAS,GAAK8W,CAC/B,MAEGtH,EAAO7Q,KAAKP,GAChB,OAAOyD,EAAIgP,EAAE2B,KAAK,QAAS,CACvBhD,SACAgF,GAAIQ,EAAKR,IACX,EAEOkC,GAAc,CAAC1B,EAAM5W,EAAIyD,KAClC,MAAM9B,EAASqW,GAAepB,EAAM5W,EAAGoW,GAAI3S,GAC3C,OAAI9B,aAAkB8U,GACX9U,EACJ8B,EAAIgP,EAAE2B,KAAK,QAAS,CACvBhD,OAAQpR,EAAGoR,OACXgF,GAAIzU,GACN,EChFC,MAAMgX,WAAuBzG,GAChC1E,CAACA,IAAW,aACZoL,gBACA,SAAAC,CAAU/V,GACN,OAAOiV,GAAmBxV,KAAMO,EAAGP,KAAKkQ,EAC3C,EAEE,MAAMqG,WAA+BH,GACxCnG,cAAgB,CAACnN,EAAM5B,KACdlB,KAAKkR,eAAepO,EAAM5B,IAC3BA,EAAI8M,MAAMhO,KAAKwW,aAAa,EAEpC,OAAAxO,CAAQyO,GACqB,WAArBA,EAAGC,cACHD,EAAGE,OAAO3W,KAAK4W,mBAEfH,EAAGI,GAAG7W,KAAK8W,iBAAkB,IAAML,EAAGvP,KAAK,GAAGuP,EAAGvV,aAAalB,KAAK+W,yBAE1E,CACD,gBAAIP,GACA,MAAO,CAAErJ,KAAMnN,KAAKyB,KAAM4E,YAAarG,KAAKqG,eAAgBrG,KAAK4Q,MACpE,CACD,wBAAImG,GACA,OAAO9K,GAAoBjM,KAAKwW,aACnC,EAEE,MAAMQ,GAAuBvV,GAAS,CAACwV,EAAQ/V,KAClD,GAAIrD,EAAQoZ,GAAS,CACjB,GAAsB,IAAlBA,EAAO5X,OAEP,OAEJ,OAAO4X,EACFpW,IAAIoW,GAAU/V,EAAIgP,EAAE2B,KAAKpQ,EAAMwV,IAC/BC,KAAK,CAAC5W,EAAGC,IAAOD,EAAE6W,UAAY5W,EAAE4W,WAAa,EAAI,EACzD,CACD,MAAMxG,EAAQzP,EAAIgP,EAAE2B,KAAKpQ,EAAMwV,GAC/B,OAAOtG,EAAM6B,sBAAwB,CAAC7B,GAASA,CAAK,EAE3CyG,GAAwBrN,IACjC,MAAMsN,EAAOtN,EAAExJ,EAAE+W,QACjB,IAAKD,EAAM,CACP,IAAIjY,EAAwB,IAAf2K,EAAEzJ,EAAEjB,QAA2B,cAAX0K,EAAEtI,KAC/BsI,EAAE7I,IAAIgP,EAAE4D,SAASC,QAAQwD,IACvBxN,EAAE7I,IAAIgP,EAAE2B,KAAK9H,EAAEtI,KAAMzC,OAAOe,OAAOgK,EAAEyN,UAAWC,GAAqB1N,EAAEzJ,IAAK,CAAEoX,YAAY,IAChG,IAAK,MAAMlJ,KAAQzE,EAAE4N,MAAO,CACxB,GAAIvY,aAAkB8U,GAClB,OAAO9U,EACXA,EAASqW,GAAejH,EAAMpP,EAAQ2K,EAAE7I,IAC3C,CACD,OAAO9B,CACV,CACD,IAAIwY,GAAU,EACd,IAAK,IAAIzY,EAAI,EAAGA,EAAI4K,EAAEzJ,EAAEjB,OAAQF,IAAK,CACjC,MAAMC,EAASqW,GAAe1L,EAAEzJ,EAAEnB,GAAIkY,EAAMtN,EAAE7I,KAC9C,GAAe,OAAX9B,EAAJ,CAEA,GAAIA,aAAkB8U,GAClB,OAAO9U,EACX,GAAKwY,GASA,IAAK7N,EAAEzJ,EAAEjD,SAAS+B,GACnB,OAAOhB,EAAmB,kFAAkFgB,SAVlG,CACV,GAAIA,EAAOkT,SAGP,OAFAvI,EAAE4N,MAAM3Z,KAAKoB,GACb2K,EAAEzJ,EAAEuX,OAAO1Y,GACJiY,GAAqBrN,GAEhCA,EAAEzJ,EAAEnB,GAAKC,EACTwY,GAAU,CACb,CAXY,CAehB,CAKD,OAJKA,GACD7N,EAAEzJ,EAAEtC,KAAKqZ,GACE,iBAAXtN,EAAEtI,MACF4V,EAAKhB,iBAAiBpB,QAAQpD,GAAQ5T,EAAa8L,EAAExJ,EAAGsR,IACrDuF,GAAqBrN,EAAE,EAErB+N,GAAsBlH,GAChB5R,OAAOD,QAAQ6R,GACzB3R,QAAQ,EAAEU,EAAG+K,KAAO/K,KAAK+L,GAAiBhB,EAAI,IAC9CwM,KAAK,CAAC5W,EAAGC,IAAMD,EAAE0Q,WAAazQ,EAAEyQ,YAAc,EAC7C1Q,EAAE0Q,WAAazQ,EAAEyQ,WAAa,EAC1B1Q,EAAE6W,UAAY5W,EAAE4W,WAAa,EACzB,GAILM,GAAwBM,IACjC,MAAMnH,EAAQ,CAAA,EACd,IAAK,MAAMoH,KAAcD,EACrB,GAAIC,EAAWxF,sBACX5B,EAAMoH,EAAWvW,MAAQjE,EAAOoT,EAAMoH,EAAWvW,MAAOuW,OAEvD,CACD,GAAIpH,EAAMoH,EAAWvW,MACjB,OAAOrD,EAAmB,yDAAyD4Z,EAAWvW,QAElGmP,EAAMoH,EAAWvW,MAAQuW,CAC5B,CAEL,OAAOpH,CAAK,ECxGHqH,GAA0B/L,GAAc,CACjDzK,KAAM,YACN4K,oBAAoB,EACpB6L,eAAgB,YAChBzX,KAAM,CACFoQ,UAAW,CAAE,GAEjBsH,UAAWlB,GAA4B,mBAAXA,EAAwB,CAAEpG,UAAWoG,GAAWA,EAC5E3K,SAAU,CACNjG,YAAawL,GAAQ,sBAAsBA,EAAKhB,UAAUpS,MAAQ,4BAEtEgU,oBAAoB,EACpBwD,cAAe,CAKXpF,UAAW,IAAM,QClBZuH,GAAwBlM,GAAc,CAC/CzK,KAAM,UACNyW,eAAgB,OAChBzX,KAAM,CACF4X,KAAM,CAAE,GAEZF,UAAWlB,GAA4B,iBAAXA,EAAsB,CAAEoB,KAAMpB,GAAWA,EACrE5K,oBAAoB,EACpBC,SAAU,CACNjG,YAAawL,GAAsB,IAAdA,EAAKwG,KAAa,aAAe,iBAAiBxG,EAAKwG,QAEhFpC,cAAe,CACXqC,QAAS,CAAChY,EAAGC,EAAGW,IAAQA,EAAIgP,EAAE2B,KAAK,UAAW,CAC1CwG,KAAME,KAAKC,IAAKlY,EAAE+X,KAAO9X,EAAE8X,KAAQI,GAAsBnY,EAAE+X,KAAM9X,EAAE8X,YAazEI,GAAwB,CAACnY,EAAGC,KAC9B,IAAImY,EACAD,EAAwBnY,EACxB0E,EAAUzE,EACd,KAAmB,IAAZyE,GACH0T,EAAW1T,EACXA,EAAUyT,EAAwBzT,EAClCyT,EAAwBC,EAE5B,OAAOD,CAAqB,ECnCzB,MAAME,WAAkBpC,GAC3BqC,iBAAmBC,GAAwB7Y,KAAKyB,MAChDqX,eAA2C,UAA1B9Y,KAAK4Y,iBAA+B,OACrB,WAA1B5Y,KAAK4Y,iBAAgC,cACjC,iBACVG,WAAaC,GAAkBhZ,KAAKyB,KAAMzB,KAAKiZ,WAC/CC,aAAelZ,KAAKqY,KAAKc,UACzB7R,WAAa,GAAGtH,KAAK+Y,aAAa/Y,KAAKqY,OACvCzB,kBAAoB,GAAG5W,KAAK8Y,kBAAkB9Y,KAAK+Y,cAAc/Y,KAAKkZ,eACtEpC,iBAAmB,GAAG9W,KAAK8Y,kBAAkBM,GAAmBpZ,KAAK+Y,eAAe/Y,KAAKkZ,eAGzFG,YAAwC,SAA1BrZ,KAAK4Y,iBACfU,GAAkBtZ,KAAKkZ,cACrB,GAAGlZ,KAAKkZ,eACdK,UAAqC,MAAzBvZ,KAAK+Y,WAAW,GAAe,QAAU,QACrD,cAAAS,CAAejZ,GAIX,OAH+C,UAAnBP,KAAKuZ,UAC7BvZ,KAAKkZ,aAAe3Y,EAAE2Y,aACpBlZ,KAAKkZ,aAAe3Y,EAAE2Y,eAEvBlZ,KAAKkZ,eAAiB3Y,EAAE2Y,eACF,IAAnBlZ,KAAKiZ,YACJ1Y,EAAE0Y,SACd,CACD,aAAAQ,CAAclZ,GACV,OAAIP,KAAKwZ,eAAejZ,KAEpBP,KAAKkZ,eAAiB3Y,EAAE2Y,eAAiBlZ,KAAKiZ,YAAa1Y,EAAE0Y,UAGpE,CACD,aAAAS,CAAcnZ,GACV,OAAQP,KAAKkZ,eAAiB3Y,EAAE2Y,eAAiBlZ,KAAKiZ,YAAc1Y,EAAE0Y,SACzE,EAEL,MAAMG,GAAqB,CACvB,IAAK,KACL,KAAM,IACN,IAAK,KACL,KAAM,KAEGO,GAAwB,CACjCC,IAAK,MACLC,UAAW,YACXC,MAAO,UAEEC,GAAoB,CAE7BnF,MAAQoF,GAASA,QAAQpc,GAEhBqc,GAAkBC,GAA2B,iBAAVA,GAAuC,iBAAVA,EACzE,IAAIxW,KAAKwW,GACPA,EACArB,GAA0B,CAC5Be,IAAK,QACLO,IAAK,QACLN,UAAW,SACXO,UAAW,SACXN,MAAO,OACPO,OAAQ,QAECrB,GAAoB,CAACvX,EAAMwX,IAAc,GAAGvZ,EAAQ+B,EAAMkY,IAAyB,IAAM,MAAMV,EAAY,GAAK,MAChHK,GAAqBY,GAA2B,iBAAVA,EAAqBA,EAAQ,IAAIxW,KAAKwW,GAAOI,iBC/DnFC,GAAsBrO,GAAc,CAC7CzK,KAAM,QACNyW,eAAgB,OAChB7L,oBAAoB,EACpB5L,KAAM,CACF4X,KAAM,CACFzD,MAAOqF,GACPO,UAAWvD,GAAUA,EAAOwD,eAEhCxB,UAAWc,IAEf5B,UAAWlB,GAA6B,iBAAXA,GACP,iBAAXA,GACPA,aAAkBvT,KAClB,CAAE2U,KAAMpB,GACNA,EACN3K,SAAU,CACNjG,YAAawL,GAAQA,EAAKoH,UACtB,SAASpH,EAAKwH,cACZ,GAAGxH,EAAKwH,uBACd7M,OAAQ1J,GAAQA,EAAKwX,kBAEzBrE,cAAe,CACX6D,MAAO,CAACxZ,EAAGC,IAAOD,EAAEkZ,eAAejZ,GAAKD,EAAIC,KCtBvCma,GAAuBxO,GAAc,CAC9CzK,KAAM,SACNyW,eAAgB,OAChB7L,oBAAoB,EACpB5L,KAAM,CACF4X,KAAM,CACFzD,MAAOqF,GACPO,UAAWvD,GAAUA,EAAOwD,eAEhCxB,UAAWc,IAEf5B,UAAWlB,GAA6B,iBAAXA,GACP,iBAAXA,GACPA,aAAkBvT,KAClB,CAAE2U,KAAMpB,GACNA,EACN3K,SAAU,CACNjG,YAAawL,GAAQA,EAAKoH,UACtB,UAAUpH,EAAKwH,cACb,GAAGxH,EAAKwH,yBACd7M,OAAQ1J,GAAQA,EAAKwX,kBAEzBrE,cAAe,CACXoE,OAAQ,CAAC/Z,EAAGC,IAAOD,EAAEkZ,eAAejZ,GAAKD,EAAIC,EAC7CuZ,MAAO,CAACO,EAAQP,EAAO5Y,IAAQmZ,EAAOZ,cAAcK,GAChDO,EAAOX,cAAcI,GACjB5Y,EAAIgP,EAAE2B,KAAK,OAAQ,CAAE8I,KAAMN,EAAOhC,OAChC,KACJnE,GAASG,KAAK,QAASgG,EAAQP,MC5BhCc,GAA4B1O,GAAc,CACnDzK,KAAM,cACNyW,eAAgB,OAChBzX,KAAM,CACF4X,KAAM,CAAE,GAEZF,UAAWlB,GAA4B,iBAAXA,EAAsB,CAAEoB,KAAMpB,GAAWA,EACrE5K,oBAAoB,EACpBC,SAAU,CACNjG,YAAawL,GAAQ,kBAAkBA,EAAKwG,QAEhDpC,cAAe,CACX4E,YAAa,CAACva,EAAGC,EAAGW,IAAQ,IAAIgT,GAAS,CACrC,aAAc,CACVyG,KAAM,CACFra,EAAGY,EAAIgP,EAAE2B,KAAK,OAAQ,CAAE8I,KAAMra,EAAE+X,OAChC9X,EAAGW,EAAIgP,EAAE2B,KAAK,OAAQ,CAAE8I,KAAMpa,EAAE8X,WAI5CwB,UAAW,CAACgB,EAAahB,KAAeA,EAAUZ,UAC9C4B,EAAYxC,KAAOwB,EAAUxB,KAC3BwC,EAAYxC,MAAQwB,EAAUxB,MAChCwC,EACE3G,GAASG,KAAK,QAASwG,EAAahB,GAC1CO,UAAW,CAACS,EAAaT,KAAeA,EAAUnB,UAC9C4B,EAAYxC,KAAO+B,EAAU/B,KAC3BwC,EAAYxC,MAAQ+B,EAAU/B,MAChCwC,EACE3G,GAASG,KAAK,QAASwG,EAAaT,MC7BrCU,GAAoB5O,GAAc,CAC3CzK,KAAM,MACNyW,eAAgB,OAChB7L,oBAAoB,EACpB5L,KAAM,CACF4X,KAAM,CAAE,EACRY,UAAWc,IAEf5B,UAAWlB,GAA4B,iBAAXA,EAAsB,CAAEoB,KAAMpB,GAAWA,EACrE3K,SAAU,CACNjG,YAAawL,GAAQ,GAAGA,EAAKoH,UAAY,YAAc,aAAapH,EAAKwG,QAE7EpC,cAAe,CACXkE,IAAK,CAAC7Z,EAAGC,IAAOD,EAAEkZ,eAAejZ,GAAKD,EAAIC,EAC1CqZ,IAAK,CAACO,EAAKP,EAAK1Y,IAAQiZ,EAAIV,cAAcG,GACtCO,EAAIT,cAAcE,GACd1Y,EAAIgP,EAAE2B,KAAK,OAAQ,CAAE8I,KAAMR,EAAI9B,OAC7B,KACJnE,GAASG,KAAK,QAAS8F,EAAKP,MClB7BmB,GAA0B7O,GAAc,CACjDzK,KAAM,YACNyW,eAAgB,OAChB7L,oBAAoB,EACpB5L,KAAM,CACF4X,KAAM,CAAE,EACRY,UAAWc,IAEf5B,UAAWlB,GAA4B,iBAAXA,EAAsB,CAAEoB,KAAMpB,GAAWA,EACrE3K,SAAU,CACNjG,YAAawL,GAAQA,EAAKoH,UACtB,oBAAoBpH,EAAKwG,OACvB,kBAAkBxG,EAAKwG,OAC7B7L,OAAQ1J,GAAQ,GAAGA,EAAKzD,UAE5B4W,cAAe,CACXmE,UAAW,CAAC9Z,EAAGC,IAAOD,EAAEkZ,eAAejZ,GAAKD,EAAIC,EAChDsZ,UAAW,CAACM,EAAKP,EAAK1Y,IAAQiZ,EAAIV,cAAcG,GAC5CO,EAAIT,cAAcE,GACd1Y,EAAIgP,EAAE2B,KAAK,cAAe,CAAEwG,KAAM8B,EAAI9B,OACpC,KACJnE,GAASG,KAAK,QAAS8F,EAAKP,MCjB7BoB,GAA6B,CACtCpB,ICN6B1N,GAAc,CAC3CzK,KAAM,MACNyW,eAAgB,OAChB7L,oBAAoB,EACpB5L,KAAM,CACF4X,KAAM,CAAE,EACRY,UAAWc,IAEf5B,UAAWlB,GAA4B,iBAAXA,EAAsB,CAAEoB,KAAMpB,GAAWA,EACrE3K,SAAU,CACNjG,YAAawL,GAAQ,GAAGA,EAAKoH,UAAY,YAAc,cAAcpH,EAAKwG,QAE9EpC,cAAe,CACX2D,IAAK,CAACtZ,EAAGC,IAAOD,EAAEkZ,eAAejZ,GAAKD,EAAIC,KDN9C4Z,IAAKW,GACLjB,UERmC3N,GAAc,CACjDzK,KAAM,YACNyW,eAAgB,OAChB7L,oBAAoB,EACpB5L,KAAM,CACF4X,KAAM,CAAE,EACRY,UAAWc,IAEf5B,UAAWlB,GAA4B,iBAAXA,EAAsB,CAAEoB,KAAMpB,GAAWA,EACrE3K,SAAU,CACNjG,YAAawL,GAAQA,EAAKoH,UACR,IAAdpH,EAAKwG,KACD,YACE,oBAAoBxG,EAAKwG,OACf,IAAdxG,EAAKwG,KAAa,YACd,mBAAmBxG,EAAKwG,OAClC7L,OAAQ1J,GAAQ,GAAGA,EAAKzD,UAE5B4W,cAAe,CACX4D,UAAW,CAACvZ,EAAGC,IAAOD,EAAEkZ,eAAejZ,GAAKD,EAAIC,KFVpD6Z,UAAWW,GACXF,YAAaD,GACbd,MAAOS,GACPF,OAAQK,IAECO,GAAqB,CAC9BrB,ICCG,cAAsBjB,GACzBuC,aAAelb,KAAKkQ,EAAE4D,SAAS3Q,OAAOoU,IACtCrG,eAAiBlR,KAAKiZ,UAAYnW,GAAQA,EAAO9C,KAAKqY,KAAOvV,GAAQA,GAAQ9C,KAAKqY,MDFlF8B,IFMG,cAAsBxB,GACzBuC,aAAelb,KAAKkQ,EAAE4D,SAAS3Q,OAAOoU,IACtCrG,eAAiBlR,KAAKiZ,UAAYnW,GAAQA,EAAO9C,KAAKqY,KAAOvV,GAAQA,GAAQ9C,KAAKqY,MEPlFwB,UEKG,cAA4BlB,GAC/BuC,aAAelb,KAAKkQ,EAAE4D,SAASqH,gBAAgB5D,IAC/CrG,eAAiBlR,KAAKiZ,UAClBnW,GAAQA,EAAKzD,OAASW,KAAKqY,KACzBvV,GAAQA,EAAKzD,QAAUW,KAAKqY,MFRlC+B,UDOG,cAA4BzB,GAC/BuC,aAAelb,KAAKkQ,EAAE4D,SAASqH,gBAAgB5D,IAC/CrG,eAAiBlR,KAAKiZ,UAClBnW,GAAQA,EAAKzD,OAASW,KAAKqY,KACzBvV,GAAQA,EAAKzD,QAAUW,KAAKqY,MCVlCwC,YHcG,cAA8BtE,GACjCrF,eAAiBpO,GAAQA,EAAKzD,SAAWW,KAAKqY,KAC9CzB,kBAAoB,mBAAmB5W,KAAKqY,OAC5CvB,iBAAmB,mBAAmB9W,KAAKqY,OAC3C6C,aAAelb,KAAKkQ,EAAE4D,SAASqH,gBAAgB5D,IAC/CjQ,WAAa,aAAatH,KAAKqY,UGlB/ByB,MLMG,cAAwBnB,GAC3BuC,aAAelb,KAAKkQ,EAAE4D,SAASpQ,KAAK6T,IACpCrG,eAAiBlR,KAAKiZ,UAAYnW,GAAQA,EAAO9C,KAAKqY,KAAOvV,GAAQA,GAAQ9C,KAAKqY,MKPlFgC,OJWG,cAAyB1B,GAC5BzH,eAAiBlR,KAAKiZ,UAAYnW,GAAQA,EAAO9C,KAAKqY,KAAOvV,GAAQA,GAAQ9C,KAAKqY,KAClF6C,aAAelb,KAAKkQ,EAAE4D,SAASpQ,KAAK6T,MOlC3B6D,GAAsBlP,GAAc,CAC7CzK,KAAM,QACNyW,eAAgB,OAChBzX,KAAM,CACF4X,KAAM,CAAE,EACRgD,MAAO,CAAE,GAEblD,UAAWlB,GAA4B,iBAAXA,EAAsB,CAAEoB,KAAMpB,GACpDA,aAAkBrT,OAChBqT,EAAOoE,MACH,CAAEhD,KAAMpB,EAAO5B,OAAQgG,MAAOpE,EAAOoE,OACnC,CAAEhD,KAAMpB,EAAO5B,QACnB4B,EACV5K,oBAAoB,EACpBoG,oBAAoB,EACpBnG,SAAU,CACNjG,YAAawL,GAAQ,cAAcA,EAAKwG,QAE5CpC,cAAe,CAGXqF,MAAO,IAAM,QCfd,MAAMC,WAAiB5L,GAC1BjB,SAAW1O,KAAKsQ,QAAQ,SAAWtQ,KAAK4Q,MAAMlC,SAAW,CAAC1O,MAC1DiL,CAACA,IAAW,OACZ,OAAIsM,GACA,OAAOvX,IACV,CACDwb,OACA,KAAAC,GAOI,OANKzb,KAAKwb,SACNxb,KAAKwb,OAASxb,KAAK0b,WACiB,IAAhC1b,KAAKwb,OAAO9M,SAASrP,QACrBX,EAAgB,SAASsB,KAAKsH,gDAG/BtH,KAAKwb,MACf,CACD,SAAAlF,CAAU/V,GACN,MAAMob,EAAQ3b,KAAKkQ,EAAE0L,UAAUrb,GAC/B,OAAOiV,GAAmBxV,KAAM2b,EAAO3b,KAAKkQ,EAC/C,CACD,GAAA2L,CAAItb,GACA,MAAMnB,EAASY,KAAKsW,UAAU/V,GAC9B,OAAOnB,aAAkB8U,GAAW9U,EAAO0c,QAAU1c,CACxD,CACD,EAAA2c,CAAGxb,GACC,MAAMob,EAAQ3b,KAAKkQ,EAAE0L,UAAUrb,GACzBmO,EAAW,IAAI1O,KAAK0O,YAAaiN,EAAMjN,UAC7C,OAAO1O,KAAKkQ,EAAE+G,OAAOvI,EACxB,CACD,MAAAsN,CAAOlZ,GACH,MAAM1D,EAASY,KAAKmR,SAASrO,GAC7B,OAAO1D,aAAkBuO,GAAYvO,EAAO0c,QAAU1c,CACzD,CAMD,OAAA6c,CAAQ1b,GACJ,MAAMob,EAAQ3b,KAAKkQ,EAAE0L,UAAUrb,GAC/B,OAAOP,KAAKkQ,EAAE+G,OAAOjX,KAAK0O,SAASoE,OAAOoJ,GAAUA,EAAOC,QAAQR,IACtE,CACD,OAAAS,CAAQ7b,GACJ,MAAMob,EAAQ3b,KAAKkQ,EAAE0L,UAAUrb,GAC/B,OAAOP,KAAKkQ,EAAE+G,OAAOjX,KAAK0O,SAASoE,OAAOoJ,IAAWA,EAAOC,QAAQR,IACvE,CACD,KAAAre,GACI,OAAO0C,KAAKkQ,EAAE+G,OAAO,CACjBoF,MAAOjf,MACPkf,SAAUtc,MACX,CAAE0X,YAAY,GACpB,CACD,QAAQnX,GACJ,MAAMgc,EAAevc,KAAKsW,UAAU/V,GACpC,QAAUgc,aAAwBrI,KAAalU,KAAKgS,OAAOuK,EAC9D,CACD,QAAAC,CAASjc,GACL,OAAOA,EAAE4b,QAAQnc,KACpB,CACD,SAAAyc,CAAUxI,GACN,OAAOjU,KAAKgU,4BAA4BC,EAC3C,CACD,QAAAyI,CAASrW,GACL,OAAOrG,KAAKyc,UAAUpW,EACzB,CACD,MAAAuM,CAAO7F,GAGH,OAAO/M,KAAKgc,OAAOjP,EACtB,CACD,IAAAtE,IAAQoG,GACJ,OAAOA,EAAOjG,OAAO,CAAC+T,EAAKzN,IAAUyN,EAAIC,SAAS1N,GAAQlP,KAC7D,CACD,QAAA4c,CAAS1N,GACL,GAAIhE,GAAWgE,EAAO,QAClB,Od9E8BuG,Gc8ETzV,KAAMkP,Ed9EwB,CAAEgB,Ec8EnBlQ,KAAKkQ,Ed9EiB4E,QAAQ,EAAOrM,MAAM,Ic+EjF,GAAIzI,KAAKsQ,QAAQ,SAAU,CACvB,MAAM5B,EAAW1O,KAAK0O,SAAS7N,IAAIgR,GAAQA,EAAKpJ,KAAKyG,IACrD,OAAOlP,KAAKkQ,EAAE2B,KAAK,QAAS,IAAK7R,KAAK4Q,MAAOlC,YAChD,CACD,OAAI1O,KAAKsQ,QAAQ,SACNtQ,KAAKkQ,EAAE2B,KAAK,QAAS,IACrB7R,KAAK4Q,MACR/B,OAAQ,IAAI7O,KAAK6O,OAAQK,KAG1BlP,KAAKkQ,EAAE2B,KAAK,QAAS,CACxBgC,GAAI7T,KACJ6O,OAAQ,CAACK,IAEhB,CACD,MAAA2N,CAAOhM,GACH,OAAO7Q,KAAK8c,UAAU,YAAajM,EACtC,CACD,SAAAiM,CAAUrb,EAAMwV,GACZ,MAAMe,EAAahY,KAAKkQ,EAAE2B,KAAKpQ,EAAMwV,GACrC,OAAIe,EAAWkD,eAAiBlb,KAAKmc,QAAQnE,EAAWkD,cbKxB,KAAIpZ,IAASpD,EACX,EAAC+C,EAAM8K,EAAUC,KAAW,Sc9G3CzC,Ed8GyDtI,Ec9GlDsI,EAAE,GAAGgT,cAAgBhT,EAAE/H,MAAM,sBd8G8CuK,EAASlG,oBAAoBmG,EAAO4P,QAAQ7P,GAAUlG,ec9GzI,IAAC0D,Cd8GsJ,EAD5GiT,IAA8Blb,IaJhFmb,CAAyBxb,EAAMuW,EAAWkD,aAAclb,MAE5DA,KAAK6b,IAEZ7b,KAAKkQ,EAAE2B,KAAK,eAAgB,CACxBpQ,CAACA,GAAOuW,IAEf,CACD,eAAAkF,CAAgB1M,GACZ,OAAOxQ,KAAKoT,UAAU,CAAC3R,EAAMmP,IAAmB,cAATnP,EACpB,WAAf+O,EACIhQ,EAAKoQ,EAAO,CAAEJ,WAAY,IACxB,IAAKI,EAAOJ,cAChBI,EAAO,CAAE2C,gBAAiB1B,IAASxU,EAASgO,GAAiBwG,EAAKpQ,OAC3E,EErHE,MAAM0b,GAA+B,CAAC1b,EAAM2K,IAAmBzN,EAAUoN,GAAmBtK,GAAO,CAACtC,EAAGsC,IAAS,CACnHA,EACA2K,ICoCJ,IAAIgR,GAAY,MACZ,IAEIC,EAFAC,EAAc/B,GACdgC,EAA6B,GAEjC,OAAO,cAAwBD,SAEvB,MAAME,EAA8B,mBAAXzc,QAAyBA,OAAO0c,SAAWze,OAAO4T,OAAO0K,EAAYvc,OAAO0c,WAAa,WAAQ,EAC1HJ,EAA6B,CAAChc,GAxCQ,SAAU9C,EAAMmf,EAAcC,EAAYC,EAAWC,EAAcC,GACjH,SAASC,EAAOzb,GAAK,QAAU,IAANA,GAA6B,mBAANA,EAAkB,MAAM,IAAI0b,UAAU,qBAAsB,OAAO1b,CAAI,CAKvH,IAJA,IAGI6J,EAHA1K,EAAOmc,EAAUnc,KAAMoF,EAAe,WAATpF,EAAoB,MAAiB,WAATA,EAAoB,MAAQ,QACrFR,EAA0B1C,EAAOqf,EAAkB,OAAIrf,EAAOA,EAAKiE,UAAY,KAC/Eyb,EAA8Bhd,EAASjC,OAAOkf,yBAAyBjd,EAAQ2c,EAAUnf,MAAQ,CAAA,EAC9F0f,GAAO,EACLhf,EAAIwe,EAAWte,OAAS,EAAGF,GAAK,EAAGA,IAAK,CAC7C,IAAImC,EAAU,CAAA,EACd,IAAK,IAAI8c,KAAKR,EAAWtc,EAAQ8c,GAAW,WAANA,EAAiB,CAAA,EAAKR,EAAUQ,GACtE,IAAK,IAAIA,KAAKR,EAAUS,OAAQ/c,EAAQ+c,OAAOD,GAAKR,EAAUS,OAAOD,GACrE9c,EAAQH,eAAiB,SAAUmB,GAAK,GAAI6b,EAAM,MAAM,IAAIH,UAAU,0DAA2DF,EAAkB9f,KAAK+f,EAAOzb,GAAK,QACpK,IAAIlD,GAAS,EAAIue,EAAWxe,IAAa,aAATsC,EAAsB,CAAEkE,IAAKsY,EAAWtY,IAAKE,IAAKoY,EAAWpY,KAAQoY,EAAWpX,GAAMvF,GACtH,GAAa,aAATG,EAAqB,CACrB,QAAe,IAAXrC,EAAmB,SACvB,GAAe,OAAXA,GAAqC,iBAAXA,EAAqB,MAAM,IAAI4e,UAAU,oBACnE7R,EAAI4R,EAAO3e,EAAOuG,QAAMsY,EAAWtY,IAAMwG,IACzCA,EAAI4R,EAAO3e,EAAOyG,QAAMoY,EAAWpY,IAAMsG,IACzCA,EAAI4R,EAAO3e,EAAOkf,QAwBoM,KAxBhLvgB,QAAQoO,EACrD,MACQA,EAAI4R,EAAO3e,MACH,UAATqC,EAqBsN,KArBvL1D,QAAQoO,GACtC8R,EAAWpX,GAAOsF,EAE9B,CACGlL,GAAQjC,OAAOwC,eAAeP,EAAQ2c,EAAUnf,KAAMwf,GAC1DE,GAAO,CACX,CAeYI,CAAave,KAAM,EAAMqd,EAA4B,CAAE5b,KAAM,SAAUhD,KAAM,aAAc+f,QAAQ,EAAOC,SAAS,EAAOJ,OAAQ,CAAEK,IAAKC,GAAO,eAAgBA,EAAKhZ,IAAKgZ,GAAOA,EAAIC,YAAcnB,SAAUD,GAAa,EAAMD,GAC5NC,GAAWxe,OAAOwC,eAAexB,KAAMe,OAAO0c,SAAU,CAAE/b,YAAY,EAAMmd,cAAc,EAAMC,UAAU,EAAMphB,MAAO8f,GAC9H,CACDlW,YAnDoD,SAAUyX,EAASlB,EAAcngB,GAEzF,IADA,IAAIshB,EAAWC,UAAU5f,OAAS,EACzBF,EAAI,EAAGA,EAAI0e,EAAaxe,OAAQF,IACrCzB,EAAQshB,EAAWnB,EAAa1e,GAAGoC,KAAKwd,EAASrhB,GAASmgB,EAAa1e,GAAGoC,KAAKwd,EAGvF,CA6CsBG,CAAkBlf,KAAMud,GAA6Bvd,KAAKmf,OACxE,cAAIP,GACA,OAAO5e,KAAKof,aAAepf,KAAKkQ,EAAEmP,YAAYrf,KAAKmf,MACtD,CACD,QAAAzD,GACI,OAAO1b,KAAK4e,WAAWnD,OAC1B,CACDvK,eAAiB,CAACpO,EAAM5B,KACpB,MAAM0J,EAAO1J,EAAI0J,KAAK5K,KAAKqQ,IAC3B,QAAIzF,GAAMvN,SAASyF,KAEnB5B,EAAI0J,KAAK5K,KAAKqQ,IAAM7S,EAAOoN,EAAM9H,GAC1B9C,KAAK4e,WAAW1N,eAAepO,EAAM5B,GAAI,EAEpD+O,cAAgB,CAACnN,EAAM5B,KACnB,MAAM0J,EAAO1J,EAAI0J,KAAK5K,KAAKqQ,IACvBzF,GAAMvN,SAASyF,KAEnB5B,EAAI0J,KAAK5K,KAAKqQ,IAAM7S,EAAOoN,EAAM9H,GACjC9C,KAAK4e,WAAW3O,cAAcnN,EAAM5B,GAAI,EAE5C,OAAA8G,CAAQyO,GACJA,EAAGI,GAAG,YAAY7W,KAAKqQ,qBAAsB,IAAMoG,EAAGE,QAAO,IAC7DF,EAAGvP,KAAK,YAAYlH,KAAKqQ,aAAanJ,KAAK,YAAYlH,KAAKqQ,iBAC5DoG,EAAGE,OAAOF,EAAG6I,OAAOtf,KAAK4e,YAC5B,EAER,EAtCe,GAwCT,MAAMW,GAAwBtI,GAA6B,iBAAXA,EAAsB,CAAEkI,MAAOlI,EAAOjV,MAAM,IAAOiV,EAC7FuI,GAAsBtT,GAAc,CAC7CzK,KAAM,QACN4K,oBAAoB,EACpB6L,eAAgB,QAChBzX,KAAM,CACF0e,MAAO,CACH3E,UAAWvD,GAAU,IAAIA,KAE7BmI,QAAS,CAAE,GAEfjH,UAAWoH,GACXjT,SAAU,CACNjG,YAAawL,GAAQA,EAAKsN,OAE9BlJ,cAAe,CACXkJ,MAAO,CAAC7e,EAAGC,EAAGW,IAAQA,EAAIgP,EAAEsD,cAAc,IAAMiM,GAAgBhK,GAAenV,EAAEse,WAAYre,EAAEqe,WAAY1d,GAAMA,EAAIgP,GAAI,GAAG5P,EAAE6e,QAAQje,EAAIuH,KAAO,KAAO,MAAMlI,EAAE4e,YAC7JhC,GAA6B,QAAS,CAAC7c,EAAGC,EAAGW,IAAQA,EAAIgP,EAAEsD,cAAc,IAAMiM,GAAgBhK,GAAenV,EAAEse,WAAYre,EAAGW,GAAMA,EAAIgP,GAAI,GAAG5P,EAAE6e,QAAQje,EAAIuH,KAAO,KAAO,MAAMlI,EAAE4e,aAGzLM,GAAkB,CAACrgB,EAAQ8Q,IAAO9Q,aAAkB8U,GAAWhE,EAAE4D,SAAS4L,MAAMnI,IAAMnY,EClGrF,MAAMugB,WAAiBpE,GAC1B,QAAAG,GACI,OAAO1b,KAAKkQ,EAAE0P,MAAM5f,KAAK6f,YAC5B,CACD5P,cAAgB,CAACnN,EAAM5B,KACdlB,KAAKkR,eAAepO,EAAM5B,IAC3BA,EAAI8M,MAAMhO,KAAKwW,aAAa,EAEpC,gBAAIA,GACA,MAAO,CAAErJ,KAAMnN,KAAKyB,KAAM4E,YAAarG,KAAKqG,eAAgBrG,KAAK4Q,MACpE,CACD,wBAAImG,GACA,OAAO9K,GAAoBjM,KAAKwW,aACnC,CACD,OAAAxO,CAAQyO,GACqB,WAArBA,EAAGC,cACHD,EAAGE,OAAO3W,KAAK4W,mBAEfH,EAAGI,GAAG7W,KAAK8W,iBAAkB,IAAML,EAAGvP,KAAK,GAAGuP,EAAGvV,aAAalB,KAAK+W,yBAE1E,ECPE,MAAM+I,GAAuB5T,GAAc,CAC9CzK,KAAM,SACN4K,oBAAoB,EACpB6L,eAAgB,SAChBzX,KAAM,CACFsf,OAAQ,CAAE,GAEd5H,UAAWlB,GAA4B,iBAAXA,EAAsB,CAAE8I,OAAQ9I,GAAWA,EACvE3K,SAAU,CACNjG,YAAawL,GAAQ5O,EAAmB4O,EAAKkO,QAC7CvT,OAAQ1J,GAAyB,kBAATA,EAAqB,GAAGA,IAASC,EAASD,IAEtEmT,cAAe,CACX8J,OAAQ,CAACzf,EAAGC,IAAM2T,GAASG,KAAK,SAAU/T,EAAGC,MC5BxCyf,GAAW,CAAE3Z,YAAa,GC4FjC4Z,GAAyB,CAAC3f,EAAGC,EAAGW,KAElC,GAAIgK,GAAW5K,EAAG,SAAWA,EAAEgQ,QAAQ,gBACnC,OAAO2P,GAAuB3f,EAAEsQ,MAAOrQ,EAAGW,GAC9C,GAAIgK,GAAW3K,EAAG,SAAWA,EAAE+P,QAAQ,gBACnC,OAAO2P,GAAuB3f,EAAGC,EAAEqQ,MAAO1P,GAC9C,MAAMsW,EAAY9W,EAAcJ,GvCjEHF,EuCiEaG,EAAGyf,IvCjEK,GuCiEO,GACnDE,EAAS5f,EAAE+b,OAAS/b,EAAEyf,OACtBI,EAAS5f,EAAE8b,OAAS9b,EAAEwf,OACtBK,EAAcF,EAChBC,EACI1K,GAAeyK,EAAQC,EAAQjf,GAC7Bgf,EACJC,EACN,OAAIC,aAAuBlM,GAChBkM,GACPA,IACA5I,EAAU4I,EAAY3e,MAAQ2e,GAC3BhJ,GAAqB,CACxB3V,KAAM,eACN+V,YACAlX,EAAGwX,GAAmBxX,GACtBC,EAAGuX,GAAmBvX,GACtBoX,MAAO,GACPzW,QACF,EAEOmf,GAA6BnU,GAAc,CACpDzK,KAAM,eACN4K,oBAAoB,EACpB8L,UAAWmI,IACP,GAAInV,GAAOmV,GACP,OAAOA,EACX,MAAMC,UAAEA,KAActJ,GAAWqJ,EAC3BE,IAAwBD,EACxBE,EAAsBF,GAAa,GACnCG,EAAa/hB,EAAUsY,EAAQ,CAACtX,EAAG+K,IACjChL,EAAQC,EAAGgM,KACP6U,GACA9hB,EAAgB,2BAA2BiB,2DAE/C8gB,EAAoB9gB,GAAK+K,EAClB,IAEJ,CAAC/K,EAAG+K,IAIf,OAFKhK,EAAc+f,KACfC,EAAWH,UAAYE,GACpBC,CAAU,EAErBC,aAAc,EAAGJ,eAAcK,KAAW/d,EAAU0d,EAAW,UAAY,IAAKA,KAAcK,GAASA,EACvGngB,KAAM,CACFsf,OAAQ,CACJpP,OAAO,EACPiE,MAAO,CAACqC,EAAQ/V,IAAQA,EAAIgP,EAAE2B,KAAK,SAAUoF,IAEjDoF,MAAO,CACH1L,OAAO,EACPiE,MAAO,CAACqC,EAAQ/V,IAAQA,EAAIgP,EAAE2B,KAAK,QAASoF,IAEhDsJ,UAAW,CACP5P,OAAO,EACPiE,MAAO,CAACqC,EAAQ/V,IAAQA,EAAIgP,EAAE2B,KAAK,YAAaoF,GAChDuD,UAAW3I,IACP,IAAKA,EAAKyK,UAAUzC,UAChB,OAAOhI,EAAKgP,gBAChB,MAAMvE,SAAEA,KAAawE,GAAkBjP,EAAKgP,iBACtCE,kBAAEA,KAAsBC,GAAiB1E,EAI/C,MAAO,IAAKwE,EAAexE,SAHK0E,EAAaC,UAAiD,IAArCjiB,OAAOyB,KAAKugB,GAAc3hB,OAC/E2hB,EAAaC,SACXD,EACwD,GAGtE1I,QAAS,CACL3H,OAAO,EACPiE,MAAOoC,GAAoB,YAE/BmD,IAAK,CACDxJ,OAAO,EACPiE,MAAOoC,GAAoB,QAE/B4C,IAAK,CACDjJ,OAAO,EACPiE,MAAOoC,GAAoB,QAE/BoD,UAAW,CACPzJ,OAAO,EACPiE,MAAOoC,GAAoB,cAE/B6C,UAAW,CACPlJ,OAAO,EACPiE,MAAOoC,GAAoB,cAE/B6D,YAAa,CACTlK,OAAO,EACPiE,MAAOoC,GAAoB,gBAE/BqD,OAAQ,CACJ1J,OAAO,EACPiE,MAAOoC,GAAoB,WAE/B8C,MAAO,CACHnJ,OAAO,EACPiE,MAAOoC,GAAoB,UAE/BsE,MAAO,CACH3K,OAAO,EACPiE,MAAOoC,GAAoB,UAE/BnG,UAAW,CACPF,OAAO,EACPiE,MAAOoC,GAAoB,eAKnCpO,OAAQ,CAACgI,EAAOV,IAGhB+P,GAAuB,CAAE,EAAErP,EAAO,CAC9BV,IACA4E,QAAQ,EACRrM,MAAM,IAEV6D,SAAU,CACNjG,YAAawL,GAAiC,IAAzBA,EAAKpB,SAASpR,OAC/B,UACEwS,EAAK0O,WAAWla,aACdwL,EAAKpB,SAAS5P,IAAI8P,GAASA,EAAMtK,aAAaiI,KAAK,SAC3D/B,SAAU8I,GAAU,OAAOA,EAAOjI,OAAOvM,IAAIuB,GAAKA,EAAEmK,UAAU+B,KAAK,YACnE7B,QAASvL,GAAO,eAAeA,EAAIqL,YAEvC0J,cAAe,CACXsG,aAAc,CAACjc,EAAGC,EAAGW,IAAQ+e,GAAuB3f,EAAGC,EAAGW,MACvDic,GAA6B,eAAgB,CAAC7c,EAAGC,EAAGW,KAEnD,GAA0B,IAAtBZ,EAAEmQ,SAASpR,OACX,OAAOkB,EACX,MAAM2gB,EAAQ5gB,EAAE4gB,MAAQzL,GAAenV,EAAE4gB,MAAO3gB,EAAGW,GAAOX,EAC1D,OAAQ2gB,aAAiBhN,GAAWgN,EAC9B5gB,GAAG4gB,OAAOlP,OAAOkP,GAEf5gB,EAGEA,EAAE4P,EAAE2B,KAAK,eAAgB7S,OAAOe,OAAOS,EAAKF,EAAEsQ,MAAOoP,IAAW,CAC9D,CAACkB,EAAMzf,MAAOyf,IACd,CAAExJ,YAAY,GAAS,MCzOzCyJ,GAAkB,CACpB,eACA,OACA,SACA,SAESC,GAAsBlV,GAAc,CAC7CzK,KAAM,QACN4K,oBAAoB,EACpB5L,KAAM,CACFoT,GAAI,CACAlD,OAAO,EACPiE,MAAO,CAACqC,EAAQ/V,IAAQA,EAAIgP,EAAE2B,KAAKsP,GAAiBlK,IAExDpI,OAAQ,CACJ+F,M3CNc9R,GAAU1F,MAAMS,QAAQiF,GAAQA,EAAO,CAACA,G2COtD0X,UAAW3L,GAAUA,EAAOhO,IAAIwgB,GAAKnW,GAAWmW,EAAG,QAAUA,EAAEtP,KAAOjM,EAAoBub,MAGlGlJ,UAAWlB,GAAUA,EACrB3K,SAAU,CACNjG,YAAawL,GAAQ,gBAAgBA,EAAKgC,GAAGxN,kBAAkBwL,EAAKhJ,KAAKxC,aAAe,aAE5F4P,cAAe,CACX/G,MAAO,CAAC5O,EAAGC,EAAGW,KACV,GAAIZ,EAAEuO,OAAO6B,KAAK,CAACxB,EAAO/P,IAAM+P,IAAU3O,EAAEsO,OAAO1P,IAE/C,OAAOT,EAAgB,kCAC3B,MAAM4iB,EAAe7L,GAAenV,EAAEuT,GAAItT,EAAEsT,GAAI3S,GAChD,OAAIogB,aAAwBpN,GACjBoN,EAGJpgB,EAAIgP,EAAE+G,OAAOqK,EAAa5S,SAAS7N,IAAI0gB,GAAYrgB,EAAIgP,EAAE2B,KAAK,QAAS,CAC1EhD,OAAQvO,EAAEuO,OACVgF,GAAI0N,KACJ,KAELpE,GAA6B,QAAS,CAAC7c,EAAGC,EAAGW,KAC5C,MAAMogB,EAAe7L,GAAenV,EAAEuT,GAAItT,EAAGW,GAC7C,OAAQogB,aAAwBpN,GAAWoN,EACf,UAAtBA,EAAa7f,KACXP,EAAIgP,EAAE2B,KAAK,QAASyP,EAAa5S,SAAS7N,IAAIqb,IAAW,IAClD5b,EAAEsQ,MACLiD,GAAIqI,MAENhb,EAAIgP,EAAE2B,KAAK,QAAS,IACfvR,EAAEsQ,MACLiD,GAAIyN,GACJ,MCpDXE,GAAsBtV,GAAc,CAC7CzK,KAAM,QACN4K,oBAAoB,EACpB6L,eAAgB,QAChBzX,KAAM,CACF4b,MAAO,CACH7B,UAAWjc,GAAQiG,EAA+BjG,IAASyN,GAAuBzN,KAG1F4Z,UAAWlB,GAA4B,iBAAXA,EAAsB,CAAEoF,MAAO5Y,EAAoBwT,IACvD,mBAAXA,EAAwB,CAAEoF,MAAOpF,GACZ,iBAAjBA,EAAOoF,MACZ,IAAKpF,EAAQoF,MAAO5Y,EAAoBwT,EAAOoF,QAC7CpF,EACd3K,SAAU,CACNjG,YAAawL,GAAQA,EAAK4P,YACtBld,EAAuBsN,EAAK4P,aAC1B,kBAAkB5P,EAAKwK,MAAM5d,OACnC+N,OAAQ1J,GAAQwB,EAAqBxB,IAEzCmT,cAAe,CACXoG,MAAO,CAAC/b,EAAGC,IAAMuE,EAAmBxE,EAAE+b,MAAO9b,EAAE8b,OAAS/b,EAClDwE,EAAmBvE,EAAE8b,MAAO/b,EAAE+b,OAAS9b,EACnC2T,GAASG,KAAK,QAAS/T,EAAGC,GACpCwf,OAAQ,CAAC1D,EAAO0D,EAAQ7e,IAA0B,WAAlB6e,EAAOA,OACnC1D,EACEnI,GAASG,KAAK,SAAUnT,EAAIgP,EAAE4D,SAAS1Q,OAAOmU,IAAKwI,MCU3D2B,GAAkB,IACjB3V,GAAmB,SACtB,SAES4V,GAAsBzV,GAAc,CAC7CzK,KAAM,QACN4K,oBAAoB,EACpB6L,eAAgB,WAChBzX,KAAM,CACFmhB,QAAS,CAAE,EACXlT,SAAU,CACNiC,OAAO,EACPiE,MAAO,CAACqC,EAAQ/V,KACZ,MAAMwN,EAAWuI,EAAOpW,IAAIqb,GAAUhb,EAAIgP,EAAE2B,KAAK6P,GAAiBxF,IAGlE,OAFKhb,EAAI+V,OAAO2K,SACZlT,EAASwI,KAAK,CAAC5W,EAAGC,IAAOD,EAAE6W,UAAY5W,EAAE4W,WAAa,EAAI,GACvDzI,CAAQ,IAI3ByJ,UAAWlB,GAAWpZ,EAAQoZ,GAAU,CAAEvI,SAAUuI,GAAWA,EAC/DrO,OAAQ,CAACgI,EAAOV,KACZ,MAAM2R,EAAkBC,GAAelR,GACvC,OAA+B,IAA3BiR,EAAgBxiB,OACTwiB,EAAgB,GACvBA,EAAgBxiB,SAAWuR,EAAMlC,SAASrP,OAEvC6Q,EAAE2B,KAAK,QAAS,IAChBjB,EACHlC,SAAUmT,GACX,CAAEnK,YAAY,SALjB,CAKwB,EAE5BpL,SAAU,CACNjG,YAAawL,GAAQkQ,GAAiBlQ,EAAKnD,SAAS7N,IAAIqb,GAAUA,EAAO7V,cACzEkG,SAAUrL,IACN,MAAM0M,EAAiB1M,EAAIkM,O7CYexE,OAAO,CAACxJ,EAAQ0L,KAClE,MAAMjE,EAAMiE,EAAiB,WAG7B,OAFA1L,EAAOyH,KAAS,GAChBzH,EAAOyH,GAAK7I,KAAK8M,GACV1L,CAAM,EACd,I6ChBe4iB,EAAmBhjB,OAAOD,QAAQ6O,GAAQ/M,IAAI,EAAE6L,EAAMU,MACxD,MAAM6U,EAAiB,GACvB7U,EAAO6H,QAAQiN,GAGfjkB,EAAagkB,EAAgBC,EAAY3V,WACzC,MAAMA,EAAWwV,GAAiBE,GAG5BzV,EAASY,EAAO+U,MAAM/f,GAAKA,EAAEoK,SAAWY,EAAO,GAAGZ,QACpDY,EAAO,GAAGZ,OACRpC,GAAUgD,EAAO,GAAGtK,MAC1B,MAAO,GAAG4J,GAAQ,GAAGA,eAAkBH,IAAWC,GAAU,SAASA,MAAW,GAEpF,OAAOuV,GAAiBC,EAAiB,EAE7CvV,QAASvL,GAAOA,EAAIqL,SACpBlO,QAAS6C,GAAOA,EAAIuL,SAExBwJ,cAAe,CACXmM,MAAO,CAAC9hB,EAAGC,EAAGW,KACV,GAAIZ,EAAE+hB,UAAY9hB,EAAE8hB,QAEhB,OAAOnO,GAASG,KAAK,WAAY/T,EAAGC,GAExC,IAAI+hB,EACJ,GAAIhiB,EAAEshB,QAAS,CACX,GAAIrhB,EAAEqhB,QACF,OAAO1N,GAASG,KAAK,wBAAyB/T,EAAGC,GACrD+hB,EAAiBC,GAAkBhiB,EAAEmO,SAAUpO,EAAEoO,SAAUxN,GACvDohB,aAA0BpO,IAC1BoO,EAAexN,QACtB,MAEGwN,EAAiBC,GAAkBjiB,EAAEoO,SAAUnO,EAAEmO,SAAUxN,GAC/D,OAAIohB,aAA0BpO,GACnBoO,EACJphB,EAAIgP,EAAE+G,OAAO3W,EAAEshB,SAAWrhB,EAAEqhB,QAC/B,CACIlT,SAAU4T,EACVV,SAAS,GAEX,CAAElT,SAAU4T,GAAiB,KAEpCnF,GAA6B,QAAS,CAAC7c,EAAGC,EAAGW,KAC5C,MAAMwN,EAAW6T,GAAkBjiB,EAAEoO,SAAU,CAACnO,GAAIW,GACpD,OAAIwN,aAAoBwF,GACbxF,EACa,IAApBA,EAASrP,OACFqP,EAAS,GACbxN,EAAIgP,EAAE+G,OAAO3W,EAAEshB,QAAU,CAAElT,WAAUkT,SAAS,GAAS,CAAElT,YAAW,MAIvF,IAAI8T,GAAY,MACZ,IAEIC,EAFAnF,EAAc/B,GACdgC,EAA6B,GAEjC,OAAO,cAAwBD,SAEvB,MAAME,EAA8B,mBAAXzc,QAAyBA,OAAO0c,SAAWze,OAAO4T,OAAO0K,EAAYvc,OAAO0c,WAAa,WAAQ,EAC1HgF,EAA2B,CAACphB,GAlIU,SAAU9C,EAAMmf,EAAcC,EAAYC,EAAWC,EAAcC,GACjH,SAASC,EAAOzb,GAAK,QAAU,IAANA,GAA6B,mBAANA,EAAkB,MAAM,IAAI0b,UAAU,qBAAsB,OAAO1b,CAAI,CAKvH,IAJA,IAGI6J,EAHA1K,EAAOmc,EAAUnc,KAAMoF,EAAe,WAATpF,EAAoB,MAAiB,WAATA,EAAoB,MAAQ,QACrFR,EAA0B1C,EAAOqf,EAAkB,OAAIrf,EAAOA,EAAKiE,UAAY,KAC/Eyb,EAA8Bhd,EAASjC,OAAOkf,yBAAyBjd,EAAQ2c,EAAUnf,MAAQ,CAAA,EAC9F0f,GAAO,EACLhf,EAAIwe,EAAWte,OAAS,EAAGF,GAAK,EAAGA,IAAK,CAC7C,IAAImC,EAAU,CAAA,EACd,IAAK,IAAI8c,KAAKR,EAAWtc,EAAQ8c,GAAW,WAANA,EAAiB,CAAA,EAAKR,EAAUQ,GACtE,IAAK,IAAIA,KAAKR,EAAUS,OAAQ/c,EAAQ+c,OAAOD,GAAKR,EAAUS,OAAOD,GACrE9c,EAAQH,eAAiB,SAAUmB,GAAK,GAAI6b,EAAM,MAAM,IAAIH,UAAU,0DAA2DF,EAAkB9f,KAAK+f,EAAOzb,GAAK,QACpK,IAAIlD,GAAS,EAAIue,EAAWxe,IAAa,aAATsC,EAAsB,CAAEkE,IAAKsY,EAAWtY,IAAKE,IAAKoY,EAAWpY,KAAQoY,EAAWpX,GAAMvF,GACtH,GAAa,aAATG,EAAqB,CACrB,QAAe,IAAXrC,EAAmB,SACvB,GAAe,OAAXA,GAAqC,iBAAXA,EAAqB,MAAM,IAAI4e,UAAU,oBACnE7R,EAAI4R,EAAO3e,EAAOuG,QAAMsY,EAAWtY,IAAMwG,IACzCA,EAAI4R,EAAO3e,EAAOyG,QAAMoY,EAAWpY,IAAMsG,IACzCA,EAAI4R,EAAO3e,EAAOkf,QAkHwM,KAlHpLvgB,QAAQoO,EACrD,MACQA,EAAI4R,EAAO3e,MACH,UAATqC,EA+G0N,KA/G3L1D,QAAQoO,GACtC8R,EAAWpX,GAAOsF,EAE9B,CACGlL,GAAQjC,OAAOwC,eAAeP,EAAQ2c,EAAUnf,KAAMwf,GAC1DE,GAAO,CACX,CAyGYI,CAAave,KAAM,EAAMyiB,EAA0B,CAAEhhB,KAAM,SAAUhD,KAAM,eAAgB+f,QAAQ,EAAOC,SAAS,EAAOJ,OAAQ,CAAEK,IAAKC,GAAO,iBAAkBA,EAAKhZ,IAAKgZ,GAAOA,EAAI+D,cAAgBjF,SAAUD,GAAa,EAAMD,GAChOC,GAAWxe,OAAOwC,eAAexB,KAAMe,OAAO0c,SAAU,CAAE/b,YAAY,EAAMmd,cAAc,EAAMC,UAAU,EAAMphB,MAAO8f,GAC9H,CACD6E,SA7IoD,SAAUtD,EAASlB,EAAcngB,GAEzF,IADA,IAAIshB,EAAWC,UAAU5f,OAAS,EACzBF,EAAI,EAAGA,EAAI0e,EAAaxe,OAAQF,IACrCzB,EAAQshB,EAAWnB,EAAa1e,GAAGoC,KAAKwd,EAASrhB,GAASmgB,EAAa1e,GAAGoC,KAAKwd,EAGvF,CAuImBG,CAAkBlf,KAAMud,GAAsD,IAAzBvd,KAAK0O,SAASrP,QAC9EsjB,UAAqC,IAAzB3iB,KAAK0O,SAASrP,QACtBW,KAAK0O,SAAS,GAAG6D,SAAQ,IACzBvS,KAAK0O,SAAS,GAAG6D,SAAQ,GAC7BqQ,aAAe5iB,KAAK0O,SAASoE,OAAQE,GAAMA,EAAE1C,QAAQ,SACrDuS,aAAe7iB,KAAK0iB,eACpBI,iBAAmB9iB,KAAK6iB,aAAeE,GAAmB/iB,KAAK6iB,cAAgB,KAC/Evb,WAAatH,KAAKqiB,QAAU,QACtBriB,KAAK2iB,UAAY,UACb3iB,KAAK0O,SAAS7N,IAAIqb,GAAUA,EAAOxJ,oBAAoBpE,KAAK,OACtE4C,eAAiB,CAACpO,EAAM5B,IAAQlB,KAAK0O,SAASgC,KAAKsS,GAAKA,EAAE9R,eAAepO,EAAM5B,IAC/E+O,cAAgB,CAACnN,EAAM5B,KACnB,MAAMkM,EAAS,GACf,IAAK,IAAIjO,EAAI,EAAGA,EAAIa,KAAK0O,SAASrP,OAAQF,IAAK,CAG3C,GAFA+B,EAAIsO,aACJxP,KAAK0O,SAASvP,GAAG8Q,cAAcnN,EAAM5B,IAChCA,EAAI6N,WACL,OAAO7N,EAAIuN,aAAazQ,QAAQkD,EAAIuO,YAAYhB,cACpDrB,EAAOpP,KAAKkD,EAAIuO,YAAYzB,MAC/B,CACD9M,EAAI8M,MAAM,CAAEb,KAAM,QAASC,UAAS,EAExC,OAAApF,CAAQyO,GACJ,IAAKzW,KAAK6iB,cAGL7iB,KAAK4iB,aAAavjB,SAAWW,KAAK0O,SAASrP,QACf,IAAzBW,KAAK0O,SAASrP,OAClB,OAAOW,KAAKijB,uBAAuBxM,GAEvC,MAAMlP,EAAYvH,KAAK6iB,aAAanW,KAAK9D,OAAO,CAAC+T,EAAKrN,IAAYqN,EAAM5V,EAAyBuI,GAAS,GAAkC,WAA3BtP,KAAK6iB,aAAaphB,KAAoB,cAAgB,QACjKyhB,EAAQljB,KAAK6iB,aAAaK,MAC1BC,EAAWnkB,OAAOyB,KAAKyiB,GAS7B,GARAzM,EAAGhP,MAAM,UAAUF,KAAc,KAC7B,IAAK,MAAM5H,KAAKujB,EAAO,CACnB,MAAMxY,EAAIwY,EAAMvjB,GAEhB8W,EAAGvP,KAAK,GADoB,YAANvH,EAAkB,UAAY,QAAQA,gBAClB,IAAN+K,EAAaA,EAAI+L,EAAG6I,OAAO5U,KAClE,CACD,OAAO+L,CAAE,GAEY,WAArBA,EAAGC,cAEH,YADAD,EAAGE,QAAO,GAGd,MAAMpK,EAAWwV,GAA4C,WAA3B/hB,KAAK6iB,aAAaphB,KAChD0hB,EAAStiB,IAAIlB,GAAKsD,EAAmBtD,EAAEqC,MAAM,GAAI,KAC/CmhB,GACN1M,EAAGvP,KAAK,4BACPhC,KAAKC,UAAUoH,kBACjBhF,uBACMrC,KAAKC,UAAUnF,KAAK6iB,aAAanW,YAEzC,CACD,sBAAAuW,CAAuBxM,GACM,UAArBA,EAAGC,eACHD,EAAG2M,MAAM,SAAU,MACnBpjB,KAAK0O,SAASuG,QAAQiH,GAAUzF,EAC3BvP,KAAK,oBACLA,KAAKuP,EAAG6I,OAAOpD,IACfrF,GAAG,kBAAmB,IAAMJ,EAAGE,OAAO,2DACtCzP,KAAK,uCACVuP,EAAGvP,KAAK,0CAGRlH,KAAK0O,SAASuG,QAAQiH,GAAUzF,EAAGI,GAAG,GAAGJ,EAAG6I,OAAOpD,KAAW,IAAMzF,EAAGE,QAAO,KAC9EF,EAAGE,QAAO,GAEjB,CACD,QAAA+E,GACI,OAAO1b,KAAK0O,SAAS9F,OAAO,CAACxJ,EAAQ8c,IAAW9c,EAAOyc,IAAIK,EAAOR,YAAa1b,KAAKkQ,EAAE4D,SAASC,QAAQwD,IAC1G,CACD,sBAAI7E,GAGA,OAAO1S,KAAK2iB,UAAY,UAAYxgB,MAAMuQ,kBAC7C,CACD,YAAAgQ,GACI,GAAI1iB,KAAK0O,SAASrP,OAAS,EACvB,OAAO,KACX,GAAIW,KAAK4iB,aAAavjB,SAAWW,KAAK0O,SAASrP,OAK3C,MAAO,CACHqN,KAAM,GACNjL,KAAM,OACNyhB,MAPUvkB,EAAUqB,KAAK4iB,aAAc,CAACzjB,EAAGwb,IAAS,CACpD,GAAGA,EAAK0I,mBACR,KAQR,MAAMC,EAAmB,CAAA,EACzB,IAAK,IAAIC,EAAS,EAAGA,EAASvjB,KAAK0O,SAASrP,OAAS,EAAGkkB,IAAU,CAC9D,MAAMjjB,EAAIN,KAAK0O,SAAS6U,GACxB,IAAK,IAAIC,EAASD,EAAS,EAAGC,EAASxjB,KAAK0O,SAASrP,OAAQmkB,IAAU,CACnE,MAAMjjB,EAAIP,KAAK0O,SAAS8U,GAClBpkB,EAASoW,GAAmBlV,EAAGC,EAAGD,EAAE4P,GAC1C,GAAM9Q,aAAkB8U,GAExB,IAAK,MAAMxH,KAAEA,EAAIjL,KAAEA,EAAI+S,SAAEA,KAAcpV,EAAOkV,KAAM,CAChD,IAAK5U,EAAQ+B,EAAMgiB,IACf,SACJ,MAAMC,EAAwB,GAAGhX,IAAOjL,IACxC,IAAIkiB,EACAC,EACJ,GAAa,WAATniB,EACAkiB,EAAc,IAAInP,EAASlU,EAAEyf,UAC7B6D,EAAc,IAAIpP,EAASjU,EAAEwf,cAE5B,IAAa,SAATte,EAKL,OAAOrD,EAAmB,qDAAqDqD,MAJ/EkiB,EAAcnP,EAASlU,EAAE+iB,gBACzBO,EAAcpP,EAASjU,EAAE8iB,eAI5B,CACD,IAAKC,EAAiBI,GAAwB,CAC1CJ,EAAiBI,GAAyB,CACtCC,CAACA,GAAc,CAACrjB,GAChBsjB,CAACA,GAAc,CAACrjB,IAEpB,QACH,CACD,MAAM2iB,EAAQI,EAAiBI,GAC1BhkB,EAAQikB,EAAaT,GAEhBA,EAAMS,GAAatmB,SAASiD,IAClC4iB,EAAMS,GAAa3lB,KAAKsC,GAFxB4iB,EAAMS,GAAe,CAACrjB,GAGrBZ,EAAQkkB,EAAaV,GAEhBA,EAAMU,GAAavmB,SAASkD,IAClC2iB,EAAMU,GAAa5lB,KAAKuC,GAFxB2iB,EAAMU,GAAe,CAACrjB,EAG7B,CACJ,CACJ,CACD,MAAMsjB,EAAwBpkB,EAAU6jB,GACnCpM,KAAK,CAAC4M,EAAGd,IAAMhkB,OAAOyB,KAAKqjB,EAAE,IAAIzkB,OAASL,OAAOyB,KAAKuiB,EAAE,IAAI3jB,QAC5D6C,IAAI,GACT,IAAK2hB,EACD,OAAO,KACX,MAAOE,EAAWC,GAAaH,GACxBnX,EAAMjL,GAAQwiB,GAAqBF,GAC1C,IAAIG,EAAkB,IAAIlkB,KAAK0O,UAC/B,MAAMwU,EAAQvkB,EAAUqlB,EAAW,CAACrkB,EAAGwkB,KACnC,MAAMC,EAAiB,GACvBF,EAAkBA,EAAgBpR,OAAOE,IAAMmR,EAAa9mB,SAAS2V,IACrE,IAAK,MAAMkJ,KAAUiI,EAAc,CAC/B,MAAME,EAASC,GAAkB7iB,EAAMiL,EAAMwP,GAG7C,GAAe,OAAXmI,EACA,MAAO,CAAC1kB,GAAG,GACfykB,EAAepmB,KAAKqmB,EACvB,CACD,MAAME,EAAqC,IAA1BH,EAAe/kB,OAC5B+kB,EAAe,GACbpkB,KAAKkQ,EAAE2B,KAAK,QAASuS,GAE3B,OADAplB,OAAOe,OAAOC,KAAK8Q,eAAgByT,EAASzT,gBACrC,CAACnR,EAAG4kB,EAAS,GAQxB,OANIL,EAAgB7kB,SAChB6jB,EAAMsB,QAAUxkB,KAAKkQ,EAAE2B,KAAK,QAASqS,EAAiB,CAClDxM,YAAY,IAEhB1Y,OAAOe,OAAOC,KAAK8Q,eAAgBoS,EAAMsB,QAAQ1T,iBAE9C,CACHrP,OACAiL,OACAwW,QAEP,EAER,EAxLe,GA0LhB,MAAMH,GAAsBF,IAAkB,CAC1CphB,KAAMohB,EAAaphB,KACnBiL,KAAMmW,EAAanW,KACnBwW,MAAOvkB,EAAUkkB,EAAaK,MAAO,CAACvjB,EAAGkS,IAAS,CAC9ClS,GACS,IAATkS,EAAgBA,EACVA,EAAKvB,QAAQ,UAAYuB,EAAKiR,iBAAmBjR,EAAKiR,iBAClDjR,EAAKE,SAGjBgQ,GAAoB0C,IACtB,GAA4B,IAAxBA,EAAaplB,OACb,MAAO,QACX,GAA4B,IAAxBolB,EAAaplB,OACb,OAAOolB,EAAa,GACxB,GAA6B,IAAxBA,EAAaplB,QACM,UAApBolB,EAAa,IACO,SAApBA,EAAa,IACQ,SAApBA,EAAa,IAAqC,UAApBA,EAAa,GAC5C,MAAO,UACX,IAAIpe,EAAc,GAClB,IAAK,IAAIlH,EAAI,EAAGA,EAAIslB,EAAaplB,OAAS,EAAGF,IACzCkH,GAAeoe,EAAatlB,GACxBA,EAAIslB,EAAaplB,OAAS,IAC1BgH,GAAe,MAGvB,OADAA,GAAe,OAAOoe,EAAaA,EAAaplB,OAAS,KAClDgH,CAAW,EAETkc,GAAoB,CAACjiB,EAAGC,EAAGW,KAIpC,MAAMwjB,EAAankB,EAAEM,IAAI,IAAM,IAC/B,IAAK,IAAI0iB,EAAS,EAAGA,EAASjjB,EAAEjB,OAAQkkB,IAAU,CAC9C,IAAIoB,EAAgB,CAAA,EACpB,IAAK,IAAInB,EAAS,EAAGA,EAASjjB,EAAElB,OAAQmkB,IAAU,CAC9C,GAA2B,OAAvBkB,EAAWlB,GAGX,SAEJ,GAAIljB,EAAEijB,GAAQvR,OAAOzR,EAAEijB,IAAU,CAE7BkB,EAAWlB,GAAU,KACrBmB,EAAgB,CAAA,EAChB,KACH,CACD,MAAMC,EAAqBnP,GAAenV,EAAEijB,GAAShjB,EAAEijB,GAAStiB,GAChE,KAAI0jB,aAA8B1Q,IAAlC,CAKA,GAAI0Q,EAAmB5S,OAAO1R,EAAEijB,IAAU,CAItCmB,EAAWlB,GAAQxlB,KAAKsC,EAAEijB,IAC1BoB,EAAgB,CAAA,EAChB,KACH,CACGC,EAAmB5S,OAAOzR,EAAEijB,IAI5BkB,EAAWlB,GAAU,KAMrBmB,EAAcnB,GAAUoB,CAnB3B,CAqBJ,CACD,IAAK,MAAMpB,KAAUmB,EAEjBD,EAAWlB,GAAQD,GAAUoB,EAAcnB,EAElD,CAID,MAAMlB,EAAiBoC,EAAWzlB,QAElC,CAAC4lB,EAAO1lB,IAAM0lB,GAAO5lB,QAAQid,GAAUA,EAAOxN,WAAanO,EAAEpB,IAC7D,OAAiC,IAA1BmjB,EAAejjB,OAClB6U,GAASG,KAAK,QAAS/T,EAAGC,GACxB+hB,CAAc,EAEXR,GAAiB,EAAGpT,WAAUkT,cACvC,GAAIlT,EAASrP,OAAS,EAClB,OAAOqP,EACX,MAAMoW,EAAoBpW,EAAS7N,IAAI,KAAM,GAC7C,IAAK,IAAI1B,EAAI,EAAGA,EAAIuP,EAASrP,OAAQF,IACjC,IAAK,IAAI4lB,EAAI5lB,EAAI,EAAG4lB,EAAIrW,EAASrP,QAAUylB,EAAkB3lB,IAAM2lB,EAAkBC,GAAIA,IAAK,CAC1F,GAAIrW,EAASvP,GAAG6S,OAAOtD,EAASqW,IAAK,CAIjCD,EAAkBC,IAAK,EACvB,QACH,CACD,MAAMxI,EAAe/G,GAAmB9G,EAASvP,GAAIuP,EAASqW,GAAIrW,EAAS,GAAGwB,GAC1EqM,aAAwBrI,KAExBqI,EAAavK,OAAOtD,EAASvP,IACxByiB,IAEDkD,EAAkB3lB,IAAK,GAGtBod,EAAavK,OAAOtD,EAASqW,MAClCD,EAAkBC,IAAK,GAC9B,CAEL,OAAOrW,EAASoE,OAAO,CAAC3G,EAAGhN,IAAM2lB,EAAkB3lB,GAAG,EAEpDskB,GAAoB,CACtB1D,OAAQ,EACRpF,KAAM,GAEJsJ,GAAwBpd,IAC1B,MAAMme,EAAgBne,EAAIoe,YAAY,KAGtC,MAAO,CAFY/f,KAAK0P,MAAM/N,EAAI7E,MAAM,EAAGgjB,EAAgB,IACxCne,EAAI7E,MAAMgjB,EAAgB,GACd,EAEtBV,GAAoB,CAACY,EAAkBxY,EAAMwP,IAAWA,EAAO9I,UAAU,CAAC+R,EAAUvU,EAAO1P,IAGnF,WAAbikB,GACiB,WAAjBvU,EAAMmP,QACNrT,EAAKrN,OAAS6B,EAAIwL,KAAKrN,SAItB6lB,IAAqBC,GACR,WAAbA,GAAyBjkB,EAAIwL,KAAKrN,SAAWqN,EAAKrN,SACnD6B,EAAIwL,KAAKrN,SAAWqN,EAAKrN,QACzB6B,EAAIwL,KAAKyV,MAAM,CAAC7S,EAASnQ,IAAMmQ,IAAY5C,EAAKvN,IANzC,KAQJyR,EACR,CACC2C,gBAAiB1B,GAAiC,IAAzBA,EAAKpB,SAASpR,QACrB,WAAdwS,EAAKpQ,MACS,SAAdoQ,EAAKpQ,OCzcA2jB,GAAqBlZ,GAAc,CAC5CzK,KAAM,OACN4K,oBAAoB,EACpB5L,KAAM,CACFka,KAAM,CACF0K,mBAAmB,EACnB7K,UAAWvD,GAAUA,aAAkBvT,KACnCuT,EAAOwD,cACLzO,GAAuBiL,KAGrCkB,UAAWlB,GAAUA,EACrB3K,SAAU,CACNjG,YAAawL,GAAQzH,GAAUyH,EAAK8I,MACpClO,QAAS,EAAGF,WAAUC,YAAgBD,IAAaC,EAAS,8BAA8BD,mCAA4C,WAAWA,UAAiBC,MAEtKyJ,cAAe,CACX0E,KAAM,CAACra,EAAGC,IAAM2T,GAASG,KAAK,OAAQ/T,EAAGC,MACtC4c,GAA6B,OAAQ,CAAC7c,EAAGC,IAAMA,EAAEyP,OAAO1P,EAAEqa,MAAQra,EAAK4T,GAASG,KAAK,gBAAiB/T,EAAGC,EAAE+P,QAAQ,gBAClH/P,EAAEkQ,SAASsC,KAAKuS,IAAgBA,EAAYtV,OAAO1P,EAAEqa,OACnDpa,OAiBRglB,GAAuB,CAAC5K,EAAM0I,EAAiBmC,KACjD,GAAI7K,aAAgBjX,KAAM,CACtB,MAAM6D,EAAY,kDAAkD8b,IACpE,OAAOmC,EAAU,KAAKje,KAAeA,CACxC,CACD,MAAO,QAAQie,EAAU,IAAM,SAASnC,GAAiB,EC1ChDoC,GAAsBvZ,GAAc,CAC7CzK,KAAM,QACN4K,oBAAoB,EACpBoG,oBAAoB,EACpBhS,KAAM,CACFilB,UAAW,CACP/U,OAAO,EACPiE,MAAO,CAACqC,EAAQ/V,KACZ,MAAM2F,EAAM3F,EAAIgP,EAAE+G,OAAOA,GACzB,IAAKpQ,EAAIsV,QAAQjb,EAAIgP,EAAE4D,SAAS6R,aAC5B,OAAOjnB,EAAgBknB,GAA+B/e,EAAIS,aAE9D,MAAMue,EAAqBhf,EAAI6H,SAASoE,OAAQkQ,GAAMA,EAAE1S,QAAQ,SAChE,OAAIuV,EAAmBxmB,OACZX,EAAgBonB,GAA6BD,EAAmBhlB,IAAImiB,GAAK5Y,GAAU4Y,EAAErI,SAEzF9T,CAAG,GAGlBnJ,MAAO,CACHiT,OAAO,EACPiE,MAAO,CAACqC,EAAQ/V,IAAQA,EAAIgP,EAAE+G,OAAOA,KAG7CkB,UAAWlB,GAAUA,EACrB3K,SAAU,CACNjG,YAAawL,GAAQ,IAAIA,EAAK6T,UAAUpe,gBAAgBuK,EAAKnU,MAAM2I,eAEvE4P,cAAe,CACXjP,MAAO,CAAC1G,EAAGC,EAAGW,KACV,GAAIZ,EAAEolB,UAAU1T,OAAOzR,EAAEmlB,WAAY,CACjC,MAAMK,EAAoBtQ,GAAenV,EAAE5C,MAAO6C,EAAE7C,MAAOwD,GAI3D,OAAOA,EAAIgP,EAAE2B,KAAK,QAAS,CAAE6T,UAAWplB,EAAEolB,UAAWhoB,MAHvCqoB,aAA6B7R,GACvChT,EAAIgP,EAAE4D,SAAS4L,MAAMnI,IACnBwO,GAET,CAED,OAAIzlB,EAAEolB,UAAUvJ,QAAQ5b,EAAEmlB,YAAcplB,EAAE5C,MAAM8e,SAASjc,EAAE7C,OAChD6C,EAEPA,EAAEmlB,UAAUvJ,QAAQ7b,EAAEolB,YAAcnlB,EAAE7C,MAAM8e,SAASlc,EAAE5C,OAChD4C,EAEJ,IAAI,KAkCVwlB,GAAgCrlB,GAAS,cAAcA,EAAK6N,KAAK,4CACjEsX,GAAkCI,GAAgB,2BAA2BA,wCChF7EC,GAAiB,CAAC3lB,EAAGC,EAAGW,KACjC,GAAIZ,EAAEuG,MAAQtG,EAAEsG,IACZ,OAAO,KACX,MAAMA,EAAMvG,EAAEuG,IACd,IAAInJ,EAAQ+X,GAAenV,EAAE5C,MAAO6C,EAAE7C,MAAOwD,GAC7C,MAAMO,EAAOnB,EAAE4lB,UAAY3lB,EAAE2lB,SAAW,WAAa,WACrD,GAAIxoB,aAAiBwW,GAAU,CAC3B,GAAa,aAATzS,EAGA,OAAO/D,EAAMwX,cAAc5U,EAAE6lB,aAF7BzoB,EAAQwD,EAAIgP,EAAE4D,SAAS4L,MAAMnI,GAGpC,CACD,GAAa,aAAT9V,EACA,OAAOP,EAAIgP,EAAE2B,KAAK,WAAY,CAC1BhL,MACAnJ,UAGR,MAAM0oB,EAAsB9lB,EAAEiQ,aAC1BhQ,EAAEgQ,aACEjQ,EAAEkkB,UAAYjkB,EAAEikB,QACZlkB,EAAEkkB,QACA9lB,EAAgB,0CAA0C0L,GAAU9J,EAAEkkB,cAAcpa,GAAU7J,EAAEikB,YACpGlkB,EAAEkkB,QACNjkB,EAAEgQ,aAAehQ,EAAEikB,QACf1jB,EACV,OAAOI,EAAIgP,EAAE2B,KAAK,WAAY,CAC1BhL,MACAnJ,QAEA8mB,QAAS4B,GACX,EAEC,MAAMC,WAAiBjQ,GAC1B8P,SAAyB,aAAdlmB,KAAKyB,KAChByZ,aAAelb,KAAKkQ,EAAE4D,SAAS1Q,OAAOmU,IACtC+O,cAAgBpgB,EAAuBlG,KAAK6G,KAC5Csf,YAAkC,iBAAbnmB,KAAK6G,IAAmB7G,KAAK6G,IAAM7G,KAAKsmB,cAC7D,UAAAhT,CAAWD,EAAQnS,GACfA,EAAIwL,KAAK1O,KAAKgC,KAAK6G,KACnB,MAAMzH,EAAS+C,MAAMmR,WAAWD,EAAQnS,GAExC,OADAA,EAAIwL,KAAKgD,MACFtQ,CACV,CACDmnB,mBAAqB,CACjBzjB,IACIA,EAAK9C,KAAK6G,KAAO7G,KAAKwkB,QACf1hB,IAGf0jB,4BAA8B1gB,EAAoB9F,KAAKumB,oBACvD,UAAAhW,GACI,MAAO,YAAavQ,IACvB,CACDkR,eAAiB,CAACpO,EAAM5B,KACpB,GAAIlB,KAAK6G,OAAO/D,EAAM,CAElB5B,GAAKwL,KAAK1O,KAAKgC,KAAK6G,KACpB,MAAM4f,EAAUzmB,KAAKtC,MAAMwT,eAAepO,EAAK9C,KAAK6G,KAAM3F,GAE1D,OADAA,GAAKwL,KAAKgD,MACH+W,CACV,CACD,OAAQzmB,KAAKkmB,QAAQ,EAEzBjW,cAAgB,CAACnN,EAAM5B,KACflB,KAAK6G,OAAO/D,GACZ5B,EAAIwL,KAAK1O,KAAKgC,KAAK6G,KACnB7G,KAAKtC,MAAMuS,cAAcnN,EAAK9C,KAAK6G,KAAM3F,GACzCA,EAAIwL,KAAKgD,OAEJ1P,KAAKsQ,QAAQ,YAClBpP,EAAI8M,MAAMhO,KAAKwW,cACVxW,KAAKsQ,QAAQ,aAAetQ,KAAKuQ,cACtCrP,EAAI0N,YAAY5O,KAAKumB,mBAAmB,EAEhD,OAAAve,CAAQyO,GACJA,EAAGI,GAAG,GAAG7W,KAAKsmB,wBAAyB,IAAM7P,EAAGiQ,YAAY1mB,KAAKsmB,cAAe,OAAO7P,EAAG7P,KAAK5G,KAAK6G,OAAQ7G,KAAKtC,QAC7GsC,KAAKsQ,QAAQ,YACbmG,EAAGkQ,KAAK,IACqB,UAArBlQ,EAAGC,cACID,EAAGvP,KAAK,aAAalH,KAAK+W,yBAE1BN,EAAGE,QAAO,IAGC,UAArBF,EAAGC,eAA6B,YAAa1W,MAClDyW,EAAGkQ,KAAK,IAAMlQ,EAAGvP,KAAK,mBAAmBlH,KAAKwmB,iCAEzB,WAArB/P,EAAGC,eACHD,EAAGE,QAAO,EACjB,EC5FE,MAAMiQ,GAAyB1a,GAAc,CAChDzK,KAAM,WACN4K,oBAAoB,EACpBoG,oBAAoB,EACpBhS,KAAM,CACFoG,IAAK,CAAE,EACPnJ,MAAO,CACHiT,OAAO,EACPiE,MAAO,CAACqC,EAAQ/V,IAAQA,EAAIgP,EAAE+G,OAAOA,IAEzCuN,QAAS,CACLa,mBAAmB,IAG3BlN,UAAWlB,GAAUA,EACrB3K,SAAU,CACNjG,YAAawL,GAAQ,GAAGA,EAAKsU,iBAAiBtU,EAAKnU,MAAM2I,eAE7D4P,cAAe,CACXnP,SAAUmf,MCVLY,GAAyB3a,GAAc,CAChDzK,KAAM,WACN4K,oBAAoB,EACpBoG,oBAAoB,EACpBhS,KAAM,CACFoG,IAAK,CAAE,EACPnJ,MAAO,CACHiT,OAAO,EACPiE,MAAO,CAACqC,EAAQ/V,IAAQA,EAAIgP,EAAE+G,OAAOA,KAG7CkB,UAAWlB,GAAUA,EACrB3K,SAAU,CACNjG,YAAawL,GAAQ,GAAGA,EAAKsU,gBAAgBtU,EAAKnU,MAAM2I,cACxDkG,SAAUrL,GAAOA,EAAI4lB,wBACrBta,OAAQ,IAAM,WAElByJ,cAAe,CACXiQ,SAAUD,GACVnf,SAAUmf,MCzBZc,GAAmC,CACrCpW,OAAO,EACPiE,MAAO,CAACqC,EAAQ/V,IAA0B,IAAlB+V,EAAO5X,YAG3BzB,EACEqZ,EAAOpW,IAAItD,GAAW2D,EAAIgP,EAAE+G,OAAO1Z,KAEhCypB,GAAyB9a,GAAc,CAChDzK,KAAM,WACN4K,oBAAoB,EACpB6L,eAAgB,WAChBzX,KAAM,CACF0F,OAAQ4gB,GACRE,UAAWF,GACX9F,SAAU,CACNtQ,OAAO,EACPiE,MAAO,CAACqC,EAAQ/V,IAAQA,EAAIgP,EAAE+G,OAAOA,EAAQ/V,IAEjD6f,kBAAmB,CAIfnM,MAAOgF,GAAgB,IAARA,OAAYhc,EAAYgc,GAE3CsN,QAASH,IAEb5O,UAAWlB,IACP,GAAsB,iBAAXA,EACP,MAAO,CAAEgK,SAAUhK,GACvB,GAAI,aAAcA,GACd,WAAYA,GACZ,cAAeA,GACf,YAAaA,GACb,sBAAuBA,EAAQ,CAC/B,GAAIA,EAAOiQ,SAAS7nB,OAAQ,CACxB,IAAK4X,EAAOgK,SACR,OAAOviB,EAAgByoB,IAC3B,GAAIlQ,EAAOgQ,WAAW5nB,OAClB,OAAOX,EAAgB0oB,GAC9B,CACD,OAAInQ,EAAO8J,oBAAsB9J,EAAOgK,SAC7BviB,EAAgB,qEAEpBuY,CACV,CACD,MAAO,CAAEgK,SAAUhK,EAAQ,EAE/BrO,OAAQ,CAAC2O,EAAKrH,KACV,IAAI6Q,EAAoBxJ,EAAIwJ,mBAAqB,EACjD,MAAM5a,EAASoR,EAAIpR,QAAQnE,SAAW,GAChC8E,EAAWyQ,EAAI0P,WAAWjlB,SAAW,GACrCklB,EAAU3P,EAAI2P,SAASllB,SAAW,GACxC,GAAIuV,EAAI0J,SAAU,CAEd,KAAOna,EAAS5E,IAAI,IAAI8P,OAAOuF,EAAI0J,WAC/Bna,EAAS4I,MACb,GAAwB,IAApB5I,EAASzH,OAMT,KAAO8G,EAAOjE,IAAI,IAAI8P,OAAOuF,EAAI0J,WAC7B9a,EAAOuJ,MACPqR,IAOR,KAAOmG,EAAQ,IAAIlV,OAAOuF,EAAI0J,WAC1BiG,EAAQ5P,QACRyJ,GAEP,MAC4B,IAApBja,EAASzH,QAGd8G,EAAOnI,QAAQkpB,EAAQrP,OAAO,IAElC,GAEAkJ,IAAsBxJ,EAAIwJ,mBAErBxJ,EAAIpR,QAAUoR,EAAIpR,OAAO9G,SAAW8G,EAAO9G,OAE5C,OAAO6Q,EAAE2B,KAAK,WAAY,IACnB0F,EAEHpR,SACA+gB,UACAD,UAAWngB,EACXia,qBACD,CAAErJ,YAAY,GACpB,EAELpL,SAAU,CACNjG,YAAawL,GACLA,EAAKwV,eACE,GAAGxV,EAAKoP,SAASvO,uBAOrB,IANkBb,EAAKyV,MACzBzmB,IAAItD,GAA4B,cAAjBA,EAAQkE,KAAuB,GAAGlE,EAAQsU,KAAKa,sBAC5C,aAAjBnV,EAAQkE,KACN,MAAMlE,EAAQsU,KAAKa,uBACjBnV,EAAQsU,KAAKvK,YAClBgH,KAAK,UAIlB2H,cAAe,CACXqG,SAAU,CAAChc,EAAGC,EAAGW,KACb,MAAMqmB,EAAYC,GAAoB,CAClClnB,EAAGA,EAAEgnB,MACL/mB,EAAGA,EAAE+mB,MACL9S,SAAU,IAAIN,GAAS,IACvB9U,OAAQ,GACRqoB,cAAe,GACfvmB,QAEEwmB,EAAiBH,EAAU/S,SAASK,UACtC,CAAC0S,KAAcA,EAAUE,eACvBF,EAAUE,cAChB,OAAkC,IAA1BC,EAAeroB,OAAekoB,EAAU/S,SAChB,IAA1BkT,EAAeroB,OACb6B,EAAIgP,EAAE2B,KAAK,WAAY8V,GAAqBD,EAAe,GAAGtoB,SAC5D8B,EAAIgP,EAAE2B,KAAK,QAAS6V,EAAe7mB,IAAI+mB,IAAU,CAC/CvL,MAAOjf,MACPkf,SAAUqL,GAAqBC,EAAMxoB,WACnC,KAyFpBuoB,GAAwBL,GAAUA,EAAM1e,OAAO,CAACxJ,EAAQyS,KACxC,aAAdA,EAAKpQ,KACLrC,EAAO6hB,SAAWpP,EAAKA,KAEvBzS,EAAOyS,EAAKpQ,MAAQjE,EAAO4B,EAAOyS,EAAKpQ,MAAOoQ,EAAKA,MAChDzS,GACR,CAAE,GACQgoB,GAAkC,+DAClCD,GAAgC,gDACvCK,GAAuBzd,IACzB,MAAO8d,KAAUC,GAAS/d,EAAEzJ,GACrBynB,KAAUC,GAASje,EAAExJ,EAC5B,IAAKsnB,IAAUE,EACX,OAAOhe,EACX,MAAMke,EAAqC,YAAvBH,EAAM5lB,IAAI,IAAIT,KAC5BymB,EAAqC,YAAvBF,EAAM9lB,IAAI,IAAIT,KAC5BA,EAAsB,WAAfomB,EAAMpmB,MAAoC,WAAfsmB,EAAMtmB,KAAoB,SAC7C,cAAfomB,EAAMpmB,MAAuC,cAAfsmB,EAAMtmB,KAIlCwmB,GAAeC,EACX,SACE,YACW,YAAfL,EAAMpmB,MAAqC,YAAfsmB,EAAMtmB,KAAqB,UACnD,WACd,GAAmB,WAAfomB,EAAMpmB,MAAoC,aAAfsmB,EAAMtmB,MAAuBymB,EAAa,CACrE,MAAMC,EAAsBX,GAAoB,IACzCzd,EACH0d,cAAe,GACflnB,EAAGynB,EAAMnnB,IAAItD,IAAO,IAAUA,EAASkE,KAAM,cAE7C0mB,EAAoB3T,SAASK,WAC7B9K,EAAE0d,cAAczpB,KAAKmqB,EAC5B,MACI,GAAmB,WAAfJ,EAAMtmB,MACI,aAAfomB,EAAMpmB,MACNwmB,EAAa,CACb,MAAME,EAAsBX,GAAoB,IACzCzd,EACH0d,cAAe,GACfnnB,EAAGwnB,EAAMjnB,IAAItD,IAAO,IAAUA,EAASkE,KAAM,cAE7C0mB,EAAoB3T,SAASK,WAC7B9K,EAAE0d,cAAczpB,KAAKmqB,EAC5B,CACD,MAAM/oB,EAASqW,GAAeoS,EAAMhW,KAAMkW,EAAMlW,KAAM9H,EAAE7I,KACxD,GAAI9B,aAAkB8U,GAAU,CAC5B,GAAa,WAATzS,GAA8B,YAATA,EAMpB,MAAa,cAATA,EAIEsI,EAMAyd,GAAoB,IACpBzd,EACH0d,cAAe,GAGfnnB,EAAGwnB,EAAMjnB,IAAItD,IAAO,IAAUA,EAASkE,KAAM,YAC7ClB,EAAGunB,EAAMjnB,IAAItD,IAAO,IAAUA,EAASkE,KAAM,cArBjDsI,EAAEyK,SAASzG,IAAI3O,EAAO8V,cAEb,WAATzT,EAAoB,GAAGsI,EAAE3K,OAAOC,SAAW,IAAIyoB,EAAMzoB,OAAS,MAC9D0K,EAAE3K,OAAS,IAAI2K,EAAE3K,OAAQ,CAAEqC,OAAMoQ,KAAM9H,EAAE7I,IAAIgP,EAAE4D,SAAS4L,MAAMnI,KAqBrE,MAEGxN,EAAE3K,OAAS,IAAI2K,EAAE3K,OAAQ,CAAEqC,OAAMoQ,KAAMzS,IAC3C,MAAMgpB,EAAare,EAAEzJ,EAAEjB,OACjBgpB,EAAate,EAAExJ,EAAElB,OASvB,OARmB,aAAfwoB,EAAMpmB,MACL2mB,GAAcC,IACK,aAAfN,EAAMtmB,MAAsC,IAAf4mB,MAClCte,EAAEzJ,EAAIwnB,IACS,aAAfC,EAAMtmB,MACL4mB,GAAcD,IACK,aAAfP,EAAMpmB,MAAsC,IAAf2mB,MAClCre,EAAExJ,EAAIynB,GACHR,GAAoBzd,EAAE,ECrTpBue,GAAoB,uBACpBC,GAA6BziB,EAAoBwiB,ICuC9D,IAAIE,GAAgB,MAChB,IAEIC,EAFAnL,EAAclH,GACdmH,EAA6B,GAEjC,OAAO,cAA4BD,SAE3B,MAAME,EAA8B,mBAAXzc,QAAyBA,OAAO0c,SAAWze,OAAO4T,OAAO0K,EAAYvc,OAAO0c,WAAa,WAAQ,EAC1HgL,EAAoB,CAACpnB,GAzCiB,SAAU9C,EAAMmf,EAAcC,EAAYC,EAAWC,EAAcC,GACjH,SAASC,EAAOzb,GAAK,QAAU,IAANA,GAA6B,mBAANA,EAAkB,MAAM,IAAI0b,UAAU,qBAAsB,OAAO1b,CAAI,CAKvH,IAJA,IAGI6J,EAHA1K,EAAOmc,EAAUnc,KAAMoF,EAAe,WAATpF,EAAoB,MAAiB,WAATA,EAAoB,MAAQ,QACrFR,EAA0B1C,EAAOqf,EAAkB,OAAIrf,EAAOA,EAAKiE,UAAY,KAC/Eyb,EAA8Bhd,EAASjC,OAAOkf,yBAAyBjd,EAAQ2c,EAAUnf,MAAQ,CAAA,EAC9F0f,GAAO,EACLhf,EAAIwe,EAAWte,OAAS,EAAGF,GAAK,EAAGA,IAAK,CAC7C,IAAImC,EAAU,CAAA,EACd,IAAK,IAAI8c,KAAKR,EAAWtc,EAAQ8c,GAAW,WAANA,EAAiB,CAAA,EAAKR,EAAUQ,GACtE,IAAK,IAAIA,KAAKR,EAAUS,OAAQ/c,EAAQ+c,OAAOD,GAAKR,EAAUS,OAAOD,GACrE9c,EAAQH,eAAiB,SAAUmB,GAAK,GAAI6b,EAAM,MAAM,IAAIH,UAAU,0DAA2DF,EAAkB9f,KAAK+f,EAAOzb,GAAK,QACpK,IAAIlD,GAAS,EAAIue,EAAWxe,IAAa,aAATsC,EAAsB,CAAEkE,IAAKsY,EAAWtY,IAAKE,IAAKoY,EAAWpY,KAAQoY,EAAWpX,GAAMvF,GACtH,GAAa,aAATG,EAAqB,CACrB,QAAe,IAAXrC,EAAmB,SACvB,GAAe,OAAXA,GAAqC,iBAAXA,EAAqB,MAAM,IAAI4e,UAAU,oBACnE7R,EAAI4R,EAAO3e,EAAOuG,QAAMsY,EAAWtY,IAAMwG,IACzCA,EAAI4R,EAAO3e,EAAOyG,QAAMoY,EAAWpY,IAAMsG,IACzCA,EAAI4R,EAAO3e,EAAOkf,QAyB4K,KAzBxJvgB,QAAQoO,EACrD,MACQA,EAAI4R,EAAO3e,MACH,UAATqC,EAsB8L,KAtB/J1D,QAAQoO,GACtC8R,EAAWpX,GAAOsF,EAE9B,CACGlL,GAAQjC,OAAOwC,eAAeP,EAAQ2c,EAAUnf,KAAMwf,GAC1DE,GAAO,CACX,CAgBYI,CAAave,KAAM,EAAMyoB,EAAmB,CAAEhnB,KAAM,SAAUhD,KAAM,QAAS+f,QAAQ,EAAOC,SAAS,EAAOJ,OAAQ,CAAEK,IAAKC,GAAO,UAAWA,EAAKhZ,IAAKgZ,GAAOA,EAAIlD,OAASgC,SAAUD,GAAa,EAAMD,GACpMC,GAAWxe,OAAOwC,eAAexB,KAAMe,OAAO0c,SAAU,CAAE/b,YAAY,EAAMmd,cAAc,EAAMC,UAAU,EAAMphB,MAAO8f,GAC9H,CACDtC,cApDoD,SAAU6D,EAASlB,EAAcngB,GAEzF,IADA,IAAIshB,EAAWC,UAAU5f,OAAS,EACzBF,EAAI,EAAGA,EAAI0e,EAAaxe,OAAQF,IACrCzB,EAAQshB,EAAWnB,EAAa1e,GAAGoC,KAAKwd,EAASrhB,GAASmgB,EAAa1e,GAAGoC,KAAKwd,EAGvF,CA8CwBG,CAAkBlf,KAAMud,GAA6Bvd,KAAKkQ,EAAE4D,SAAS1Q,OAAOmU,KAC5FlB,gBAAkBrW,KAAKyQ,SAASxR,QAAQ+T,GAAKA,EAAEqD,iBAAmB,IAClEqS,MAAQ1oB,KAAKkmB,SACTlmB,KAAK8G,SACD,IAAI9G,KAAKkmB,YAAalmB,KAAK8G,UACzB9G,KAAKkmB,SACTlmB,KAAK8G,UAAY,GACvB6hB,WAAahqB,EAAUqB,KAAK0oB,MAAO,CAACvpB,EAAG0S,IAAS,CAACA,EAAKhL,IAAKgL,IAC3D+W,oBAAsB9iB,EAAoB9F,KAAK2oB,YAC/CrhB,WAAauhB,GAAqB7oB,MAClC8oB,oBAAsB9oB,KAAKkmB,UAAUrlB,IAAIgR,GAAQA,EAAKhL,MAAQ,GAC9DkiB,oBAAsB/oB,KAAK8G,UAAUjG,IAAIgR,GAAQA,EAAKhL,MAAQ,GAC9DgZ,YAAc,IACP7f,KAAK8oB,uBACL9oB,KAAK+oB,qBAEZ,KAAAtN,GACI,IAAI/M,EAAW1O,KAAKkQ,EAAE0P,MAAM5f,KAAK6f,aAAanR,SAI9C,OAHA1O,KAAKgH,OAAOiO,QAAQ,EAAGyQ,UAAW1e,MAC9B0H,EAAWA,EAASsa,OAAOhiB,EAAM0H,SAAS,GAEvC1O,KAAKkQ,EAAE2B,KAAK,QAASnD,EAC/B,CACDua,gBAAiCrrB,IAApBoC,KAAKwQ,iBAA2C5S,IAAfoC,KAAKgH,MACnD,IAAAxG,IAAQC,GACJ,OAAOT,KAAKkQ,EAAE2B,KAAK,YAAaqX,GAAclpB,KAAK4Q,MAAOnQ,GAC7D,CACD,KAAA0oB,CAAM5oB,GACF,MAAMqQ,EAAQ5F,GAAkCke,GAAclpB,KAAK4Q,MAAO,CAACrQ,EAAEkb,WAa7E,OAZIlb,EAAE2lB,WACFtV,EAAMsV,SAAW1oB,EAAOoT,EAAMsV,SAAU3lB,EAAE2lB,WAC1C3lB,EAAEuG,WACF8J,EAAM9J,SAAWtJ,EAAOoT,EAAM9J,SAAUvG,EAAEuG,WAC1CvG,EAAEyG,QACF4J,EAAM5J,MAAQxJ,EAAOoT,EAAM5J,MAAOzG,EAAEyG,QACpCzG,EAAE+b,WACF1L,EAAM0L,SAAW/b,EAAE+b,UACnB/b,EAAEiQ,WACFI,EAAMJ,WAAajQ,EAAEiQ,kBAEdI,EAAMJ,WACVxQ,KAAKkQ,EAAE2B,KAAK,YAAajB,EACnC,CACDM,eAAiB,CAACpO,EAAM5B,IAAQlB,KAAKopB,UAAU,SAAUtmB,EAAM5B,GAC/D+O,cAAgB,CAACnN,EAAM5B,IAAQlB,KAAKopB,UAAU,QAAStmB,EAAM5B,GAC7DkoB,UAAY,CAAC1S,EAAe5T,EAAM5B,KAC9B,MAAMmoB,EAAanoB,GAAKiO,mBAAqB,EAC7C,IAAK,IAAIhQ,EAAI,EAAGA,EAAIa,KAAK0oB,MAAMrpB,OAAQF,IACnC,GAAsB,WAAlBuX,GACA,IAAK1W,KAAK0oB,MAAMvpB,GAAG+R,eAAepO,EAAM5B,GACpC,OAAO,OAIX,GADAlB,KAAK0oB,MAAMvpB,GAAG8Q,cAAcnN,EAAM5B,GAC9BA,EAAIkO,UAAYlO,EAAIiO,kBAAoBka,EACxC,OAAO,EAGnB,GAAIrpB,KAAKsc,SACL,GAAsB,WAAlB5F,GACA,IAAK1W,KAAKsc,SAASpL,eAAepO,EAAM5B,GACpC,OAAO,OAIX,GADAlB,KAAKsc,SAASrM,cAAcnN,EAAM5B,GAC9BA,EAAIkO,UAAYlO,EAAIiO,kBAAoBka,EACxC,OAAO,EAGnB,IAAKrpB,KAAKipB,WACN,OAAO,EACX,MAAMxoB,EAAOzB,OAAOyB,KAAKqC,GACzBrC,EAAKzC,QAAQgB,OAAO4B,sBAAsBkC,IAC1C,IAAK,IAAI3D,EAAI,EAAGA,EAAIsB,EAAKpB,OAAQF,IAAK,CAClC,MAAMQ,EAAIc,EAAKtB,GACf,IAAIyY,GAAU,EACd,GAAI5X,KAAKgH,MACL,IAAK,MAAM6K,KAAQ7R,KAAKgH,MACpB,GAAI6K,EAAK6T,UAAUxU,eAAevR,EAAGuB,GAAM,CACvC,GAAsB,WAAlBwV,EAA4B,CAC5BxV,GAAKwL,KAAK1O,KAAK2B,GACf,MAAMP,EAASyS,EAAKnU,MAAMwT,eAAepO,EAAKnD,GAAIuB,GAElD,GADAA,GAAKwL,KAAKgD,OACLtQ,EACD,OAAO,CACd,MAKG,GAHA8B,EAAIwL,KAAK1O,KAAK2B,GACdkS,EAAKnU,MAAMuS,cAAcnN,EAAKnD,GAAIuB,GAClCA,EAAIwL,KAAKgD,MACLxO,EAAIkO,UAAYlO,EAAIiO,kBAAoBka,EACxC,OAAO,EAEfzR,GAAU,CACb,CAGT,GAAI5X,KAAKwQ,aACLoH,IAAYjY,KAAKK,KAAK2oB,WACtB/Q,SACsBha,IAAlBoC,KAAKsc,UACY,iBAAN3c,GACP2oB,GAAkBriB,KAAKtG,IAC1BiY,GAAS,CACV,GAAsB,WAAlBlB,EACA,OAAO,EAWX,GAVwB,WAApB1W,KAAKwQ,WACLtP,EAAI8M,MAAM,CAAEzB,SAAU,UAAWC,OAAQ,KAAMe,aAAc,CAAC5N,KAE9DuB,EAAI0N,YAAY,CACZ9L,WACWA,EAAKnD,GACLmD,KAIf5B,EAAIkO,SACJ,OAAO,CACd,CAELlO,GAAKwL,KAAKgD,KACb,CACD,OAAO,CAAI,EAEf,OAAA1H,CAAQyO,GACqB,UAArBA,EAAGC,eACHD,EAAG6S,uBACPtpB,KAAK0oB,MAAMzT,QAAQrO,IACf6P,EAAG8S,MAAM3iB,GACgB,UAArB6P,EAAGC,eACHD,EAAG+S,kBAAkB,GAEzBxpB,KAAKsc,WACL7F,EAAG8S,MAAMvpB,KAAKsc,UACW,UAArB7F,EAAGC,eACHD,EAAG+S,oBAEPxpB,KAAKipB,aACLxS,EAAG2M,MAAM,OAAQ,qBACjB3M,EAAGvP,KAAK,oDACRuP,EAAGgT,IAAI,kBAAmB,IAAMzpB,KAAK0pB,uBAAuBjT,KAEvC,WAArBA,EAAGC,eACHD,EAAGE,QAAO,EACjB,CACD,sBAAA+S,CAAuBjT,GA4BnB,OA3BAA,EAAG2M,MAAM,IAAK,WACVpjB,KAAKwQ,YACLiG,EAAGkT,IAAI,WAAW,GACtB3pB,KAAKgH,OAAOiO,QAAQpD,IAChB4E,EAAGI,GAAG,GAAGJ,EAAG6I,OAAOzN,EAAK6T,UAAW,CAAElf,IAAK,IAAK/E,KAAM,aAAe,KAChEgV,EAAGiQ,YAAY,IAAK,UAAW7U,EAAKnU,OAChCsC,KAAKwQ,YACLiG,EAAG5Q,IAAI,WAAW,GACf4Q,GACT,GAEFzW,KAAKwQ,aACsB,IAAvBxQ,KAAK0oB,OAAOrpB,QACZoX,EAAGvP,KAAK,oBAAoBlH,KAAK4oB,uBACjC5oB,KAAKsc,UACL7F,EAAGvP,KAAK,wCAAwCqhB,cAEpD9R,EAAGI,GAAG,WAAY,IACW,WAArBJ,EAAGC,cACID,EAAGE,QAAO,GACM,WAApB3W,KAAKwQ,WACRiG,EACKvP,KAAK,uEACL2P,GAAG,eAAgB,IAAMJ,EAAGE,UAC/BF,EAAGvP,KAAK,gEAGfuP,CACV,EAER,EA3LmB,GA6LpB,MAAMyS,GAAgB,CAACtY,EAAOnQ,KAC1B,MAAMrB,EAAS,IAAKwR,GAcpB,OAbAnQ,EAAKwU,QAAQtV,IACLP,EAAO8mB,WACP9mB,EAAO8mB,SAAW9mB,EAAO8mB,SAASpT,OAAOkQ,GAAkB,mBAANrjB,GAAoBA,EAAEqQ,OAAOgT,EAAEnc,KAAOlH,IAAMqjB,EAAEnc,MAEnGzH,EAAO0H,WACP1H,EAAO0H,SAAW1H,EAAO0H,SAASgM,OAAOkQ,GAAkB,mBAANrjB,GAAoBA,EAAEqQ,OAAOgT,EAAEnc,KAAOlH,IAAMqjB,EAAEnc,MAEnGzH,EAAO4H,OAAsB,mBAANrH,IAGvBP,EAAO4H,MAAQ5H,EAAO4H,MAAM8L,OAAOE,IAAMA,EAAE0S,UAAUvJ,QAAQxc,IAChE,GAEEP,CAAM,EAEXwqB,GAA0BC,GAAqBhY,IACjD,GAAIA,EAAK6W,MAAMrpB,QAAUwS,EAAK7K,MAAO,CACjC,MAAM8iB,EAAQjY,EAAK7K,OAAOnG,IAAIiD,SAAW,GACzC+N,EAAK6W,MAAMzT,QAAQpD,GAAQiY,EAAM9rB,KAAK6T,EAAKgY,KACvChY,EAAKrB,YACLsZ,EAAM9rB,KAAK,mBAAmB6T,EAAKrB,cACvC,MAAMuZ,EAA2B,KAAKD,EAAMxb,KAAK,UACjD,OAAOuD,EAAKyK,SACR,GAAGyN,OAA8BlY,EAAKyK,SAASjW,cAC7C0jB,CACT,CACD,OAAOlY,EAAKyK,UAAUjW,aAAe,IAAI,EAEvC2jB,GAAwBJ,GAAuB,eAC/Cf,GAAuBe,GAAuB,cACvCK,GAA0B/d,GAAc,CACjDzK,KAAM,YACN4K,oBAAoB,EACpB8L,UAAWlB,GAAUA,EACrBxW,KAAM,CACFylB,SAAU,CACNvV,OAAO,EACPiE,MAAOoC,GAAoB,aAE/BlQ,SAAU,CACN6J,OAAO,EACPiE,MAAOoC,GAAoB,aAE/BhQ,MAAO,CACH2J,OAAO,EACPiE,MAAOoC,GAAoB,UAE/BsF,SAAU,CACN3L,OAAO,EACPiE,MAAOoC,GAAoB,aAE/BxG,WAAY,CACRoE,MAAOsV,GAA0B,WAAbA,OAAwBtsB,EAAYssB,IAGhE5d,SAAU,CACNjG,YAAa2jB,IAEjB/T,cAAe,CACXsK,UAAW,CAACjgB,EAAGC,EAAGW,KACd,MAAMipB,EAAS,IAAK7pB,EAAEsQ,OAChBwZ,EAAS,IAAK7pB,EAAEqQ,OACtB,GAAItQ,EAAEkQ,WAAY,CACd,MAAM6Z,EAAO/pB,EAAEmb,QACT6O,EAAgB/pB,EAAEuoB,oBAAoBhW,OAAOnT,IAAM0qB,EAAKra,OAAOrQ,IACrE,GAAI2qB,EAAcjrB,OACd,OAAO6U,GAASG,KAAK,WAAYnT,EAAIgP,EAAE4D,SAAS4L,MAAMnI,IAAKhX,EAAEooB,WAAW2B,EAAc,IAAI5sB,OAAOwX,cAAcoV,EAAc,IAE7HF,EAAOtjB,WACPsjB,EAAOtjB,SAAWsjB,EAAOtjB,SAASgM,OAAOE,GAAKqX,EAAKra,OAAOgD,EAAEnM,OAC5DujB,EAAOpjB,QACPojB,EAAOpjB,MAAQojB,EAAOpjB,MAAM/H,QAAQ+T,IAChC,GAAIA,EAAE0S,UAAUvJ,QAAQkO,GACpB,OAAOrX,EACX,MAAMuX,EAAe/U,GAAmB6U,EAAMrX,EAAE0S,UAAWxkB,EAAIgP,GAC/D,GAAIqa,aAAwBrW,GACxB,MAAO,GACX,MAAMwM,EAAa8J,GAAeD,EAAcvX,EAAEtV,MAAOwD,EAAIgP,GAO7D,OANIwQ,EAAWwF,WACXkE,EAAOlE,SACHkE,EAAOlE,SACH,IAAIkE,EAAOlE,YAAaxF,EAAWwF,UACjCxF,EAAWwF,UAElBxF,EAAW1Z,OAAS,EAAE,GAGxC,CACD,GAAIzG,EAAEiQ,WAAY,CACd,MAAMia,EAAOlqB,EAAEkb,QACTiP,EAAgBpqB,EAAEwoB,oBAAoBhW,OAAOnT,IAAM8qB,EAAKza,OAAOrQ,IACrE,GAAI+qB,EAAcrrB,OACd,OAAO6U,GAASG,KAAK,WAAY/T,EAAEqoB,WAAW+B,EAAc,IAAIhtB,MAAOwD,EAAIgP,EAAE4D,SAAS4L,MAAMnI,KAAKrC,cAAcwV,EAAc,IAE7HP,EAAOrjB,WACPqjB,EAAOrjB,SAAWqjB,EAAOrjB,SAASgM,OAAOE,GAAKyX,EAAKza,OAAOgD,EAAEnM,OAC5DsjB,EAAOnjB,QACPmjB,EAAOnjB,MAAQmjB,EAAOnjB,MAAM/H,QAAQ+T,IAChC,GAAIA,EAAE0S,UAAUvJ,QAAQsO,GACpB,OAAOzX,EACX,MAAMuX,EAAe/U,GAAmBiV,EAAMzX,EAAE0S,UAAWxkB,EAAIgP,GAC/D,GAAIqa,aAAwBrW,GACxB,MAAO,GACX,MAAMwM,EAAa8J,GAAeD,EAAcvX,EAAEtV,MAAOwD,EAAIgP,GAO7D,OANIwQ,EAAWwF,WACXiE,EAAOjE,SACHiE,EAAOjE,SACH,IAAIiE,EAAOjE,YAAaxF,EAAWwF,UACjCxF,EAAWwF,UAElBxF,EAAW1Z,OAAS,EAAE,GAGxC,CACD,MAAMwQ,EAAY,CAAA,EAOlB,OANIlX,EAAEkQ,YAAcjQ,EAAEiQ,cAClBgH,EAAUhH,WACW,WAAjBlQ,EAAEkQ,YAA4C,WAAjBjQ,EAAEiQ,WAC3B,SACE,UAEP4G,GAAqB,CACxB3V,KAAM,YACN+V,YACAlX,EAAGwX,GAAmBqS,GACtB5pB,EAAGuX,GAAmBsS,GACtBzS,MAAO,GACPzW,OACF,KAKDspB,GAAiB,CAAC9E,EAAWhoB,EAAOwS,KAC7C,MAAO2V,EAAoB8E,GrD7VL,EAACC,EAAMC,KAC7B,MAAMzrB,EAAS,CAAC,GAAI,IACpB,IAAK,MAAM0L,KAAQ8f,EACR9f,EqD0ViFwF,QAAQ,QrDzV5FlR,EAAO,GAAGpB,KAAK8M,GAEf1L,EAAO,GAAGpB,KAAK8M,GAEvB,OAAO1L,CAAM,EqDqVuC0rB,CAAWpF,EAAUhX,UACzE,IAAKmX,EAAmBxmB,OACpB,MAAO,CAAE2H,MAAOkJ,EAAE2B,KAAK,QAAS,CAAE6T,YAAWhoB,WACjD,MAAMgjB,EAAa,CAAA,EAQnB,OAPAA,EAAWwF,SAAWL,EAAmBhlB,IAAImS,GAAK9C,EAAE2B,KAAK,WAAY,CAAEhL,IAAKmM,EAAE2H,KAAMjd,WAChFitB,EAAsBtrB,SACtBqhB,EAAW1Z,MAAQkJ,EAAE2B,KAAK,QAAS,CAC/B6T,UAAWiF,EACXjtB,WAGDgjB,CAAU,ECzWRqK,GAA4B,IAClC/P,GACHmE,MAAOK,GACPO,OAAQD,GACRnF,KAAMyK,GACN/I,MAAOmF,GACPY,MAAOT,GACPzS,MAAOkS,GACP7E,aAAc8D,GACd/H,QAASF,GACTkD,MAAOF,GACPvK,UAAWoH,GACXiO,SAAUW,GACV/f,SAAU8f,GACV5f,MAAOye,GACPnJ,SAAU0K,GACVzG,UAAW0J,IAEFe,GAAoB,IAC1B/P,GACHkE,MAAO/B,GACP2C,OdjCG,cAAyBJ,GAC5BzO,eAAiBpO,GAAQC,EAASD,KAAU9C,KAAK+f,OACjDnJ,kBAAoC,WAAhB5W,KAAK+f,OACrB,8EACE,oBAAoB/f,KAAK+f,UAC/BjJ,iBAAmC,WAAhB9W,KAAK+f,OACpB,8EACE,oBAAoB/f,KAAK+f,UAC/BzY,WAAatH,KAAK+f,OAClBF,YlCyF6B,CAACE,GAAW,IAAIlb,EkCzFb7E,KAAK+f,SAAvBkL,IcyBdtQ,KRVG,cAAuBgF,GAC1BuL,cAAgBlrB,KAAK+R,KAAK4I,KAC1B0I,gBAAuC,iBAAdrjB,KAAK2a,MAAqB3a,KAAK2a,gBAAgBjX,KACpEwB,KAAKC,UAAUnF,KAAKkrB,eAClBlrB,KAAKkrB,cACXrL,YAAcnb,EAAgB1E,KAAK2a,MACnC/D,kBAAoB2O,GAAqBvlB,KAAK2a,KAAM3a,KAAKqjB,iBACzDvM,iBAAmByO,GAAqBvlB,KAAK2a,KAAM3a,KAAKqjB,gBAAiB,WACzE/b,WAAa8C,GAAUpK,KAAK2a,MAC5BoF,OAAShd,EAAS/C,KAAK2a,MACvBzJ,eAAiBlR,KAAK2a,gBAAgBjX,KAClCZ,GAAQA,aAAgBY,MAAQZ,EAAK2X,gBAAkBza,KAAKkrB,cAC1DpoB,GAAQA,IAAS9C,KAAK2a,MQD5B0B,MVNG,cAAwBsD,GAC3B8B,YAAcjd,EAA+BxE,KAAKqc,OAClD8O,sBAAwBnrB,KAAK+R,KAAKsK,MAClCzF,kBAAoB,mBAAmB5W,KAAKmrB,wBAC5CrU,iBAAmB,KAAK9W,KAAK4W,qBAC7BiJ,YAAcnb,EAAgB1E,KAAKqc,MAAM7Z,WACzC0O,eAAiBpO,GAAQA,aAAgB9C,KAAKqc,MAC9C/U,WAAatH,KAAKqc,MAAM5d,KACxBshB,OAAS,UUDTqC,MAAOI,GACPtT,MXmBG,cAAwBqM,GAC3B6P,iBAAmBprB,KAAK6O,OAAOhO,IAAIiF,GACnCulB,eAAiB,IAAIrrB,KAAKorB,oBAC1Bla,eAAiB,CAACpO,EAAM5B,IAAQlB,KAAK6T,GAAG3C,eAAepO,EAAM5B,GAC7D+O,cAAgB,CAACnN,EAAM5B,KACnBA,EAAI0N,YAAY5O,KAAK6O,QACrB7O,KAAK6T,GAAG5D,cAAcnN,EAAM5B,EAAI,EAEpCoG,WAAa,QAAQtH,KAAK6T,GAAGvM,sBAAsBtH,KAAK6I,KAAKvB,YAAc,aAC3E,OAAAU,CAAQyO,GACqB,WAArBA,EAAGC,eAIPD,EAAGvP,KAAK,mBAAmBlH,KAAKqrB,mBAChC5U,EAAGvP,KAAKuP,EAAG6I,OAAOtf,KAAK6T,MAJnB4C,EAAGE,OAAOF,EAAG6I,OAAOtf,KAAK6T,IAKhC,CACD,MAAI,GACA,OAAO7T,KAAK4Q,MAAMiD,EACrB,CACD,gBAAIqC,GACA,MAAMoV,EAAYtrB,KAAK4Q,MAAM/B,OAAO3M,IAAI,GACxC,OAAOgJ,GAAWogB,EAAW,QACzBA,GAAWziB,SACTjL,CACT,CACD,OAAIiL,GACA,OAAO7I,KAAKkW,cAAgBlW,KAAKkQ,EAAE4D,SAASC,QAAQwD,GACvD,CACD,QAAAmE,GACI,OAAO1b,KAAK6T,GAAG6H,UAClB,GWjDDa,aZjCG,cAA+BhB,GAClC2F,MAAQlhB,KAAK+f,QAAU/f,KAAKqc,OAAS,KACrCkP,YAAcvrB,KAAKyQ,SAASqC,OAAQjB,GAASA,EAAKQ,gBAClD/K,WAAatH,KAAKugB,WAAWjZ,YACzBtH,KAAKyQ,SAAS5P,IAAIgR,GAAQA,EAAKa,oBAAoBpE,KAAK,QACxD,UACJ4C,eAAiB,CAACpO,EAAM5B,IAAQlB,KAAKyQ,SAAS0R,MAAMxR,GAASA,EAAMO,eAAepO,EAAM5B,IACxF+O,cAAgB,CAACnN,EAAM5B,KACnB,MAAMmoB,EAAanoB,EAAIiO,kBACvB,KAAInP,KAAKkhB,QACLlhB,KAAKkhB,MAAMjR,cAAcnN,EAAM5B,GAC3BA,EAAIiO,kBAAoBka,IAFhC,CAKA,GAAIrpB,KAAKurB,YAAYlsB,OAAQ,CACzB,IAAK,IAAIF,EAAI,EAAGA,EAAIa,KAAKurB,YAAYlsB,OAAS,EAAGF,IAE7C,GADAa,KAAKurB,YAAYpsB,GAAG8Q,cAAcnN,EAAM5B,GACpCA,EAAIkO,UAAYlO,EAAIiO,kBAAoBka,EACxC,OAGR,GADArpB,KAAKurB,YAAYrpB,IAAI,GAAG+N,cAAcnN,EAAM5B,GACxCA,EAAIiO,kBAAoBka,EACxB,MACP,CACD,KAAIrpB,KAAKugB,YACLvgB,KAAKugB,UAAUtQ,cAAcnN,EAAM5B,GAC/BA,EAAIiO,kBAAoBka,KAG5BrpB,KAAK6Q,UAAW,CAChB,IAAK,IAAI1R,EAAI,EAAGA,EAAIa,KAAK6Q,UAAUxR,OAAS,EAAGF,IAE3C,GADAa,KAAK6Q,UAAU1R,GAAG8Q,cAAcnN,EAAM5B,GAClCA,EAAIkO,UAAYlO,EAAIiO,kBAAoBka,EACxC,OAERrpB,KAAK6Q,UAAU3O,IAAI,GAAG+N,cAAcnN,EAAM5B,EAC7C,CAvBA,CAuBA,EAEL,OAAA8G,CAAQyO,GACJ,GAAyB,WAArBA,EAAGC,cAGH,OAFA1W,KAAKyQ,SAASwE,QAAQtE,GAAS8F,EAAG8S,MAAM5Y,SACxC8F,EAAGE,QAAO,GAUd,GAPAF,EAAG6S,uBACCtpB,KAAKkhB,QACLzK,EAAG8S,MAAMvpB,KAAKkhB,OAEVlhB,KAAKyQ,SAASpR,OAAS,GACvBoX,EAAG+U,gBAEPxrB,KAAKurB,YAAYlsB,OAAQ,CACzB,IAAK,IAAIF,EAAI,EAAGA,EAAIa,KAAKurB,YAAYlsB,OAAS,EAAGF,IAC7CsX,EAAG8S,MAAMvpB,KAAKurB,YAAYpsB,IAC1BsX,EAAG+S,mBAEP/S,EAAG8S,MAAMvpB,KAAKurB,YAAYrpB,IAAI,KAC1BlC,KAAKugB,WAAavgB,KAAK6Q,YACvB4F,EAAG+U,cACV,CAMD,GALIxrB,KAAKugB,YACL9J,EAAG8S,MAAMvpB,KAAKugB,WACVvgB,KAAK6Q,WACL4F,EAAG+U,gBAEPxrB,KAAK6Q,UAAW,CAChB,IAAK,IAAI1R,EAAI,EAAGA,EAAIa,KAAK6Q,UAAUxR,OAAS,EAAGF,IAC3CsX,EAAG8S,MAAMvpB,KAAK6Q,UAAU1R,IAGxBsX,EAAG+U,eAEP/U,EAAG8S,MAAMvpB,KAAK6Q,UAAU3O,IAAI,GAC/B,CACJ,CACD,QAAAwZ,GACI,OAAQ1b,KAAKkhB,MACTlhB,KAAKugB,UACDvgB,KAAKkhB,MAAMxF,WAAWK,GAAG/b,KAAKugB,UAAU9E,SACtCzb,KAAKkhB,MAAMxF,WACf1b,KAAKugB,WAAW9E,SAAWzb,KAAKkQ,EAAE4D,SAAS4L,MAAMnI,GAC1D,GY/CDe,Q9BxBG,cAA0B/B,GAC7BrF,eAAiBpO,GAAQA,EAAO9C,KAAKqY,MAAS,EAC9CzB,kBAAoB,UAAU5W,KAAKqY,aACnCvB,iBAAmB,UAAU9W,KAAKqY,aAClC6C,aAAelb,KAAKkQ,EAAE4D,SAAS3Q,OAAOoU,IACtCjQ,WAAa,KAAKtH,KAAKqY,Q8BoBvBiD,MpBlBG,cAAwB/E,GAC3BkV,SAAW,IAAI7nB,OAAO5D,KAAKqY,KAAMrY,KAAKqb,OACtC/T,WAAa,GAAGtH,KAAKyrB,WACrBva,eAAiBlR,KAAKyrB,SAASxlB,KAAK7E,KAAKpB,KAAKyrB,UAC9C7U,kBAAoB,GAAG5W,KAAKsH,wBAC5BwP,iBAAmB,IAAI9W,KAAK4W,oBAC5BsE,aAAelb,KAAKkQ,EAAE4D,SAASzQ,OAAOkU,KoBatC1G,U/BtBG,cAA4BuF,GAC/BsV,oBAAsB5lB,EAAoB9F,KAAK6Q,WAC/C+F,kBAAoB,GAAG5W,KAAK0rB,iCAC5B5U,iBAAmB,IAAI9W,KAAK4W,oBAC5BsE,aAAe,KACf5T,WAAatH,KAAK0rB,oBAClBxa,eAAiBlR,KAAK6Q,UACtB2F,aAAe,CACXrJ,KAAM,YACN9G,YAAarG,KAAKqG,aAEtB0Q,qBAAuB,sCAAsC/W,KAAKqG,iBAClE4J,cAAgB,CAACnN,EAAM5B,KACdlB,KAAK6Q,UAAU/N,EAAM5B,IAASA,EAAI6N,YACnC7N,EAAI8M,MAAMhO,KAAKwW,aAAa,EAEpC,OAAAxO,CAAQyO,GACqB,WAArBA,EAAGC,cAIPD,EAAGI,GAAG,GAAG7W,KAAK8W,sCAAuC,IAAML,EAAGvP,KAAK,aAAalH,KAAK+W,0BAHjFN,EAAGE,OAAO3W,KAAK4W,kBAItB,G+BCDsP,SJ5CG,cAA2BG,GAC9B/e,WAAa,GAAGtH,KAAKmmB,gBAAgBnmB,KAAKtC,MAAM4J,aAChDkP,aAAexX,OAAO2sB,OAAO,CACzBxe,KAAM,WACN2Z,wBAAyB9mB,KAAKtC,MAAM2I,YACpCkH,aAAc,CAACvN,KAAK6G,OAExBkQ,qBAAuB9K,GAAoBjM,KAAKwW,eIsChD1P,SLvBG,cAA2Buf,GAC9B/e,WAAa,GAAGtH,KAAKmmB,iBAAiBnmB,KAAKtC,MAAM4J,cKuBjDN,MPKG,cAAwBoP,GAC3B8E,aAAelb,KAAKkQ,EAAE4D,SAAS1Q,OAAOmU,IACtCjQ,WAAa,IAAItH,KAAK0lB,UAAUpe,gBAAgBtH,KAAKtC,MAAM4J,aAC3D4J,eAAiB,CAACpO,EAAM5B,IAAQP,EAA2BmC,GAAMqf,MAAMjjB,IACnE,GAAIc,KAAK0lB,UAAUxU,eAAehS,EAAM,GAAIgC,GAAM,CAE9CA,GAAKwL,KAAK1O,KAAKkB,EAAM,IACrB,MAAMunB,EAAUzmB,KAAKtC,MAAMwT,eAAehS,EAAM,GAAIgC,GAEpD,OADAA,GAAKwL,KAAKgD,MACH+W,CACV,CACD,OAAO,CAAI,GAEfxW,cAAgB,CAACnN,EAAM5B,IAAQP,EAA2BmC,GAAMmS,QAAQ/V,IAChEc,KAAK0lB,UAAUxU,eAAehS,EAAM,GAAIgC,KACxCA,EAAIwL,KAAK1O,KAAKkB,EAAM,IACpBc,KAAKtC,MAAMuS,cAAc/Q,EAAM,GAAIgC,GACnCA,EAAIwL,KAAKgD,MACZ,GAEL,UAAA4D,CAAWD,EAAQnS,GACfA,EAAIwL,KAAK1O,KAAKgC,KAAK0lB,WACnB,MAAMtmB,EAAS+C,MAAMmR,WAAWD,EAAQnS,GAExC,OADAA,EAAIwL,KAAKgD,MACFtQ,CACV,CACD,OAAA4I,GAEC,GOhCDsU,SH8FG,cAA2BlG,GAC9B8E,aAAelb,KAAKkQ,EAAE4D,SAAS1W,MAAMma,IACrCpR,OAASnG,KAAK4Q,MAAMzK,QAAU,GAC9B8gB,UAAYjnB,KAAK4Q,MAAMqW,WAAa,GACpC2E,YAAc,IAAI5rB,KAAKmG,UAAWnG,KAAKinB,WACvCC,QAAUlnB,KAAK4Q,MAAMsW,SAAW,GAChCG,eAAiBrnB,KAAK4rB,YAAYvsB,OAASW,KAAKknB,QAAQ7nB,SAAW,EACnE0hB,kBAAoB/gB,KAAK4Q,MAAMmQ,mBAAqB,EACpDlH,UAAY7Z,KAAKmG,OAAO9G,OAASW,KAAK+gB,kBAAoB/gB,KAAKknB,QAAQ7nB,OACvEwsB,cAAmC,IAAnB7rB,KAAK6Z,UAAkB,KAAO7Z,KAAKkQ,EAAE2B,KAAK,YAAa7R,KAAK6Z,WAC5EO,UAAYpa,KAAKihB,SAAW,KAAOjhB,KAAK6Z,UAAY7Z,KAAKinB,UAAU5nB,OACnEysB,cAAmC,OAAnB9rB,KAAKoa,UAAqB,KAAOpa,KAAKkQ,EAAE2B,KAAK,YAAa7R,KAAKoa,WAC/E/D,gBAAkBrW,KAAK6rB,cACnB7rB,KAAK8rB,cACD,CAAC9rB,KAAK6rB,cAAe7rB,KAAK8rB,eACxB,CAAC9rB,KAAK6rB,eACV7rB,KAAK8rB,cAAgB,CAAC9rB,KAAK8rB,eACvB,GACV,YAAAC,CAAajpB,EAAMkE,GACf,GAAIA,EAAQhH,KAAK4rB,YAAYvsB,OACzB,OAAOW,KAAK4rB,YAAY5kB,GAC5B,MAAMglB,EAAoBlpB,EAAKzD,OAASW,KAAKknB,QAAQ7nB,OACrD,OAAI2H,GAASglB,EACFhsB,KAAKknB,QAAQlgB,EAAQglB,GACxBhsB,KAAKihB,UACT7iB,EAAmB,sCAAsC4I,QAAYhH,OAC5E,CAEDkR,eAAiB,CAACpO,EAAM5B,KACpB,IAAK,IAAI/B,EAAI,EAAGA,EAAI2D,EAAKzD,OAAQF,IAC7B,IAAKa,KAAK+rB,aAAajpB,EAAM3D,GAAG+R,eAAepO,EAAK3D,GAAI+B,GACpD,OAAO,EACf,OAAO,CAAI,EAEf+O,cAAgB,CAACnN,EAAM5B,KACnB,IAAK,IAAI/B,EAAI,EAAGA,EAAI2D,EAAKzD,OAAQF,IAC7B+B,EAAIwL,KAAK1O,KAAKmB,GACda,KAAK+rB,aAAajpB,EAAM3D,GAAG8Q,cAAcnN,EAAK3D,GAAI+B,GAClDA,EAAIwL,KAAKgD,KACZ,EAGL,OAAA1H,CAAQyO,GACJzW,KAAKmG,OAAO8O,QAAQ,CAACpD,EAAM1S,IAAMsX,EAAGiQ,YAAY,GAAGvnB,IAAK,QAAQA,KAAM0S,IACtE7R,KAAKinB,UAAUhS,QAAQ,CAACpD,EAAM1S,KAC1B,MAAM8sB,EAAY,GAAG9sB,EAAIa,KAAKmG,OAAO9G,SACrCoX,EAAGI,GAAG,GAAGoV,QAAgBxV,EAAG3T,cAAe,IAA2B,WAArB2T,EAAGC,cAA6BD,EAAGE,QAAO,GAAQF,EAAGE,UACtGF,EAAGiQ,YAAYuF,EAAW,QAAQA,KAAcpa,EAAK,GAErD7R,KAAKihB,WACDjhB,KAAKknB,QAAQ7nB,QACboX,EAAG2M,MAAM,oBAAqB,GAAG3M,EAAG3T,cAAc9C,KAAKknB,QAAQ7nB,OAAS,KAAKW,KAAKknB,QAAQ7nB,SAAW,MAEzGoX,EAAGgT,IAAI,QAAOzpB,KAAKknB,QAAQ7nB,OAAS,oBAAsB,eAAiB,IAAMoX,EAAGiQ,YAAY,IAAK,UAAW1mB,KAAKihB,UAAWjhB,KAAK4rB,YAAYvsB,QACjJW,KAAKknB,QAAQjS,QAAQ,CAACpD,EAAM1S,KACxB,MAAM+sB,EAAgB,uBAAuB/sB,IAC7CsX,EAAGiQ,YAAYwF,EAAe,QAAQA,KAAkBra,EAAK,IAG5C,WAArB4E,EAAGC,eACHD,EAAGE,QAAO,EACjB,CACD,UAAArD,CAAWD,EAAQnS,GACfA,EAAIwL,KAAK1O,KAAKgC,KAAKkQ,EAAE4D,SAASqY,yBAAyB5U,KACvD,MAAMnY,EAAS+C,MAAMmR,WAAWD,EAAQnS,GAExC,OADAA,EAAIwL,KAAKgD,MACFtQ,CACV,CACDkoB,MAIyB,CAAC1W,IAC1B,MAAM0W,EAAQ,GAMd,OALA1W,EAAMzK,QAAQ8O,QAAQpD,GAAQyV,EAAMtpB,KAAK,CAAEyD,KAAM,SAAUoQ,UAC3DjB,EAAMqW,WAAWhS,QAAQpD,GAAQyV,EAAMtpB,KAAK,CAAEyD,KAAM,YAAaoQ,UAC7DjB,EAAMqQ,UACNqG,EAAMtpB,KAAK,CAAEyD,KAAM,WAAYoQ,KAAMjB,EAAMqQ,WAC/CrQ,EAAMsW,SAASjS,QAAQpD,GAAQyV,EAAMtpB,KAAK,CAAEyD,KAAM,UAAWoQ,UACtDyV,CAAK,EAXJ8E,CAAqBpsB,KAAK4Q,OAElCtJ,WAAatH,KAAKqG,aGnKlBka,UAAWiI,IChDR,MAAM6D,WAAmBpsB,EAE5B,IAAKgL,MACD,MAAO,QACV,ECDL,MAAMqhB,GAAW,CACbjmB,YAAa,CAAEsL,MAAM,IAEZ4a,GAAe,CAACtV,EAAQuV,KACjC,MAAM/qB,EAAOgrB,GAAqBxV,GAClC,OAAIuV,IAAiBA,EAAanvB,SAASoE,GAChC/C,EAAgB,gBAAgB+C,sBAAyB+qB,KAE7D/qB,CAAI,EAETgrB,GAAwBxV,IAC1B,cAAeA,GACX,IAAK,SACD,MAAqB,MAAdA,EAAO,GAAa,QAAU,SACzC,IAAK,WACD,OAAO/L,GAAW+L,EAAQ,QAAUA,EAAOxV,KAAO,QACtD,IAAK,SAAU,CAEX,GAAe,OAAXwV,EACA,MACJ,GAAI,WAAYA,EACZ,MAAO,QACX,GAAI,aAAcA,GAAUpZ,EAAQoZ,GAChC,MAAO,QACX,GAAI,SAAUA,EACV,MAAO,OACX,GAAI,UAAWA,EACX,MAAO,QACX,MAAMyV,EAAa1tB,OAAOyB,KAAKwW,GAC/B,GAA0B,IAAtByV,EAAWrtB,QAAgBqtB,EAAWhc,KAAK/Q,GAAKA,KAAK+L,IACrD,MAAO,eACX,GAAI,UAAWuL,EACX,MAAO,QACX,GAAI,WAAYA,EACZ,MAAO,QACd,EAEL,OAAOvY,EAAgB,GAAG0L,GAAU6M,gCAAqC,EAEvE0V,GAAY,CAAA,EACZC,GAA0BC,GAAiBhvB,EAAQgvB,GACrDA,EAAahsB,IAAIgR,GAAQA,EAAKgP,iBAC5BgM,EAAahM,gBC9CZ,MAAMiM,WAAqBxmB,EAC9BoQ,cACAhK,KAAO,GACPqgB,cAAgB,GAChB,WAAAltB,CAAY6W,GACRvU,MAAM,OAAQ,OACdnC,KAAK0W,cAAgBA,CACxB,CACD,MAAA4I,CAAOzN,EAAMlU,GACT,MAAM6I,EAAM7I,GAAM6I,KAAOxG,KAAK8C,KAC9B,OAAI9C,KAAKgtB,mBAAmBnb,GACjB,GAAG7R,KAAKitB,UAAUpb,EAAMlU,MAAS6I,MAAQxG,KAAKkB,OAClD,GAAGlB,KAAKitB,UAAUpb,EAAMlU,MAAS6I,IAC3C,CACD,SAAAymB,CAAUpb,EAAMlU,GACZ,MACMoH,EAAO,QAAQ8M,EAAKxB,KADN1S,GAAM8D,MAAQzB,KAAK0W,gBAEvC,OAAO/Y,GAAMyD,KAAO,GAAG2D,UAAapH,GAAMyD,QAAU2D,CACvD,CACD,kBAAAioB,CAAmBnb,GACf,MAA8B,UAAvB7R,KAAK0W,eAA6B7E,EAAK9B,qBACjD,CACD,oBAAAuZ,GACI,OAAOtpB,KAAKojB,MAAM,aAAc,wBACnC,CACD,YAAAoI,GACI,OAAOxrB,KAAK6W,GAAG,qCAAsC,IAAM7W,KAAK2W,SACnE,CACD,gBAAA6S,GACI,OAAOxpB,KAAK6W,GAAG,qDAAsD,IAAM7W,KAAK2W,SACnF,CACD,WAAA+P,CAAYwF,EAAegB,EAAkBrb,GACzC,MAAMsb,EAAkBntB,KAAKgtB,mBAAmBnb,GAQhD,OAPIsb,GACAntB,KAAKkH,KAAK,GAAGlH,KAAKkB,iBAAiBgrB,MACvClsB,KAAKupB,MAAM1X,EAAM,CACbrL,IAAK0mB,IAELC,GACAntB,KAAKkH,KAAK,GAAGlH,KAAKkB,kBACflB,IACV,CACD,KAAAupB,CAAM1X,EAAMlU,GACR,MAA8B,WAAvBqC,KAAK0W,cACR1W,KAAK6W,GAAG,IAAI7W,KAAKsf,OAAOzN,EAAMlU,KAAS,IAAMqC,KAAK2W,QAAO,IACvD3W,KAAKkH,KAAKlH,KAAKsf,OAAOzN,EAAMlU,GACrC,CACD,WAAAyvB,CAAY3uB,GACR,MAAO,GAAGA,KAAQuB,KAAKuG,SAAS+H,KAAK,YAAYtO,KAAKiC,aACzD,EClDL,IAOIsc,GAA8C,SAAUhgB,EAAMmf,EAAcC,EAAYC,EAAWC,EAAcC,GACjH,SAASC,EAAOzb,GAAK,QAAU,IAANA,GAA6B,mBAANA,EAAkB,MAAM,IAAI0b,UAAU,qBAAsB,OAAO1b,CAAI,CAKvH,IAJA,IAGI6J,EAHA1K,EAAOmc,EAAUnc,KAAMoF,EAAe,WAATpF,EAAoB,MAAiB,WAATA,EAAoB,MAAQ,QACrFR,GAAUyc,GAAgBnf,EAAOqf,EAAkB,OAAIrf,EAAOA,EAAKiE,UAAY,KAC/Eyb,EAAaP,IAAiBzc,EAASjC,OAAOkf,yBAAyBjd,EAAQ2c,EAAUnf,MAAQ,CAAA,GAC9F0f,GAAO,EACLhf,EAAIwe,EAAWte,OAAS,EAAGF,GAAK,EAAGA,IAAK,CAC7C,IAAImC,EAAU,CAAA,EACd,IAAK,IAAI8c,KAAKR,EAAWtc,EAAQ8c,GAAW,WAANA,EAAiB,CAAA,EAAKR,EAAUQ,GACtE,IAAK,IAAIA,KAAKR,EAAUS,OAAQ/c,EAAQ+c,OAAOD,GAAKR,EAAUS,OAAOD,GACrE9c,EAAQH,eAAiB,SAAUmB,GAAK,GAAI6b,EAAM,MAAM,IAAIH,UAAU,0DAA2DF,EAAkB9f,KAAK+f,EAAOzb,GAAK,QACpK,IAAIlD,GAAS,EAAIue,EAAWxe,IAAa,aAATsC,EAAsB,CAAEkE,IAAKsY,EAAWtY,IAAKE,IAAKoY,EAAWpY,KAAQoY,EAAWpX,GAAMvF,GACtH,GAAa,aAATG,EAAqB,CACrB,QAAe,IAAXrC,EAAmB,SACvB,GAAe,OAAXA,GAAqC,iBAAXA,EAAqB,MAAM,IAAI4e,UAAU,oBACnE7R,EAAI4R,EAAO3e,EAAOuG,QAAMsY,EAAWtY,IAAMwG,IACzCA,EAAI4R,EAAO3e,EAAOyG,QAAMoY,EAAWpY,IAAMsG,IACzCA,EAAI4R,EAAO3e,EAAOkf,QAAOT,EAAa9f,QAAQoO,EACrD,MACQA,EAAI4R,EAAO3e,MACH,UAATqC,EAAkBoc,EAAa9f,QAAQoO,GACtC8R,EAAWpX,GAAOsF,EAE9B,CACGlL,GAAQjC,OAAOwC,eAAeP,EAAQ2c,EAAUnf,KAAMwf,GAC1DE,GAAO,CACX,EAUO,MAAMkP,GAAgBruB,OAAOe,OAAOpB,EAAUosB,GAA2B,CAACtpB,EAAM2K,IAAmB,CACtG3K,EACA2K,EAAeE,WACf,CACAghB,QAAS5qB,IACT6qB,kBAAkB,EAClBC,mBAAmB,IAEjBC,GAAmB,CACrB,mBACA,qBAESC,GAAe,CAAC3oB,EAAM4oB,KAC/B,IAAKA,EACD,OAAO5oB,EACX,MAAM3F,E3CxDkB,EAAC2F,EAAM6oB,KAC/B,MAAMxuB,EAAS,IAAK2F,GACpB,IAAIpF,EACJ,IAAKA,KAAKiuB,EACNxuB,EAAOO,GACHkM,GAAWlM,GACP,IACOoF,EAAKpF,MACLiuB,EAAWjuB,IAEhBiuB,EAAWjuB,GAEzB,OAAOP,CAAM,E2C4CEyuB,CAAa9oB,EAAM4oB,GAKlC,OAJAF,GAAiBxY,QAAQtV,IACfA,KAAKguB,UACAvuB,EAAOO,EAAE,GAEjBP,CAAM,EAOJ0uB,GAA4B3O,GAAU,IAAIA,6BAAiCA,IAClF4O,GAAqB,CAAA,EAE3B,IAAIC,GAAa,EAEbC,GAAe,MACf,IACIC,EACAC,EACAC,EAHA7Q,EAA6B,GAIjC,OAAO,MAAM0Q,SAEL,MAAMzQ,EAA8B,mBAAXzc,QAAyBA,OAAO0c,SAAWze,OAAO4T,OAAO,WAAQ,EAC1Fsb,EAAqB,CAACltB,GACtBmtB,EAAyB,CAACntB,GAC1BotB,EAAoB,CAACptB,GACrBud,GAAave,KAAM,KAAMkuB,EAAoB,CAAEzsB,KAAM,SAAUhD,KAAM,SAAU+f,QAAQ,EAAOC,SAAS,EAAOJ,OAAQ,CAAEK,IAAKC,GAAO,WAAYA,EAAKhZ,IAAKgZ,GAAOA,EAAI1H,QAAUwG,SAAUD,GAAa,KAAMD,GAC5MgB,GAAave,KAAM,KAAMmuB,EAAwB,CAAE1sB,KAAM,SAAUhD,KAAM,aAAc+f,QAAQ,EAAOC,SAAS,EAAOJ,OAAQ,CAAEK,IAAKC,GAAO,eAAgBA,EAAKhZ,IAAKgZ,GAAOA,EAAI0P,YAAc5Q,SAAUD,GAAa,KAAMD,GAC5NgB,GAAave,KAAM,KAAMouB,EAAmB,CAAE3sB,KAAM,SAAUhD,KAAM,QAAS+f,QAAQ,EAAOC,SAAS,EAAOJ,OAAQ,CAAEK,IAAKC,GAAO,UAAWA,EAAKhZ,IAAKgZ,GAAOA,EAAIiB,OAASnC,SAAUD,GAAa,KAAMD,GACpMC,GAAWxe,OAAOwC,eAAexB,KAAMe,OAAO0c,SAAU,CAAE/b,YAAY,EAAMmd,cAAc,EAAMC,UAAU,EAAMphB,MAAO8f,GAC9H,CACDlQ,OA3FoD,SAAUyR,EAASlB,EAAcngB,GAEzF,IADA,IAAIshB,EAAWC,UAAU5f,OAAS,EACzBF,EAAI,EAAGA,EAAI0e,EAAaxe,OAAQF,IACrCzB,EAAQshB,EAAWnB,EAAa1e,GAAGoC,KAAKwd,EAASrhB,GAASmgB,EAAa1e,GAAGoC,KAAKwd,GAEnF,OAAOC,EAAWthB,OAAQ,CAC9B,CAqFiBwhB,CAAkBlf,KAAMud,GACjCpN,eACAE,GAAK,OAAM2d,GACX/iB,CAACA,IAAW,QACZ6F,eAAiB,CAAA,EACjBC,WAAa,GACbud,YAAc,CAAA,EACdvc,KAAO,CAAA,EACPwc,cACAC,QAAU,CAAA,EACVC,UAAW,EAIXjQ,gBAAkB,CAAA,EAElB,YAAI1K,GACA,OAAOma,EAAana,QACvB,CACD0K,eACA,WAAIkQ,GACA,OAAO1uB,KAAKH,YAAY6uB,OAC3B,CACD,WAAA7uB,CAGAyI,EAAKgF,GACDtN,KAAKsN,OAASA,GAAU,GACxBtN,KAAKmQ,eAtDY,CAAC7C,GAAWogB,GAAaA,GAAaL,GAAexgB,IAAeS,GAsD/DqhB,CAAcrhB,GACpCtN,KAAKuuB,cAAgBvvB,OAAOyB,KAAK6H,GAAKwK,OAAOnT,IACzC,GAAa,MAATA,EAAE,GAAY,CACd,MAAMlB,EAAOkB,EAAEqC,MAAM,GAIrB,OAHIvD,KAAQuB,KAAKwuB,SACb9vB,EAAgBovB,GAAyBrvB,IAC7CuB,KAAKwuB,QAAQ/vB,GAAQ6J,EAAI3I,IAClB,CACV,CAID,OAHIA,KAAKK,KAAKwuB,SACV9vB,EAAgBovB,GAAyBnuB,IAC7CK,KAAKwuB,QAAQ7uB,GAAK2I,EAAI3I,IACf,CAAI,GAEXK,KAAK0uB,UAEL1uB,KAAK0uB,QAAQE,SAEb5uB,KAAKsuB,YAAc3vB,EAAUqB,KAAK0uB,QAAQJ,YAAa,CAACnP,EAAOP,IAAe,CAC1EO,EACAjU,GAAW0T,EAAY,QACnBA,EAAWjM,UAAU3S,MACnB4e,IAIjB,CACD,OAAIrH,GACA,OAAOvX,IACV,CACD,MAAAiX,CAAO3O,EAAK3K,GACR,OAAOqC,KAAK6R,KAAK0a,GAAajkB,GAAMA,EAAK3K,EAC5C,CACD,UAAA0wB,CAAW/lB,GACP,OAAOA,CACV,CACD,KAAAsX,CAAMpgB,EAAQ7B,GACV,MAAMkxB,EAAe,GACrB,IAAK,MAAMnxB,KAAS8B,EACXqvB,EAAaxxB,SAASK,IACvBmxB,EAAa7wB,KAAKN,GAC1B,MAAMgR,EAAWmgB,EAAahuB,IAAI8Z,GAAQ3a,KAAK6R,KAAK,OAAQ,CAAE8I,QAAQhd,IACtE,OAAOqC,KAAK6R,KAAK,QAASnD,EAAU,IAC7B/Q,EACH+Z,YAAY,GAEnB,CACDoX,gBAAkB,GAClB,aAAAtb,CAAc4L,EAAS2P,GACdA,IACDhB,GAAmBiB,YAAc,EACjCD,EAAiB,eAAchB,GAAmBiB,WAEtD,MAAMnd,EAAO7R,KAAK6R,KAAK,QAAS,CAC5BsN,MAAO4P,EACP3P,WACD,CAAE1H,YAAY,IAEjB,OADA1X,KAAK8uB,gBAAgB9wB,KAAK6T,GACnBA,CACV,CACDA,MAAO,CAAGnJ,EAAOumB,EAAYtxB,KACzB,IAAI8D,EAAwB,iBAAViH,EAAqBA,EAAQ6jB,GAAa0C,EAAYvmB,GACpEuO,EAASgY,EACb,GAAI9jB,GAAO8L,IAAWA,EAAOxV,OAASA,EAClC,OAAOwV,EAAOtE,UAAU3S,MAC5B,GAAa,UAATyB,GAAqB9D,GAAM+Z,YAK1B,GAAa,UAATjW,GAAoBoB,EAAUoU,EAAQ,UAAW,CACtD,MAAMvI,EA5HG,CAACuI,GAAWpZ,EAAQoZ,GAAUA,EACjD,aAAcA,GAAUpZ,EAAQoZ,EAAOvI,UAAYuI,EAAOvI,cACtD9Q,EA0HuBsxB,CAAiBjY,GACT,IAArBvI,GAAUrP,SACV4X,EAASvI,EAAS,GAClBjN,EAAO8qB,GAAatV,GAE3B,MAX0C,CACvC,MAAM2H,EAAa5e,KAAKqf,YAAYE,GAAqBtI,GAAQkI,OACjElI,EAAS2H,EACTnd,EAAOmd,EAAWnd,IACrB,CAQD,MAAMiQ,EAAOqZ,GAA0BtpB,GACjC0tB,EAAmBzd,EAAKyG,YAAYlB,IAAWA,EAGrD,GAAI9L,GAAOgkB,GACP,OAAOA,EAAiB1tB,OAASA,EAC7B0tB,EAAiBxc,UAAU3S,MArIYtB,EAAgB,gBAsIlBywB,EAAiB1tB,0BAAvBA,gBAEvC,MAAM0E,EAASxI,GAAMwhB,OAAS1d,EAC9BssB,GAAmB5nB,KAAY,EAC/B,MAAMkK,EAAK,GAAGlK,MAAW4nB,GAAmB5nB,KACtC0L,EFhKO,EAACpQ,EAAMP,KAC5B,MAAMwQ,EAAOqZ,GAA0BtpB,GACjCmP,EAAQ,CAAA,EAGRwe,EAAgB3vB,EAAUyB,EAAI+V,QAAQC,KAAK,EAAEmT,IAAQI,KAAU5e,GAAWwe,GAC5Exe,GAAW4e,GAAQ3e,GAAiBue,GAAQve,GAAiB2e,GACvD,EACJ5e,GAAW4e,IACPJ,EAAOI,GADS,EAEZ,GACRha,EAAW,GACjB,IAAK,MAAMvR,KAASkwB,EAAe,CAC/B,MAAMzvB,EAAIT,EAAM,GACVmwB,EAAU3d,EAAKjR,KAAKd,IAAM2sB,GAAS3sB,GACzC,IAAK0vB,EACD,OAAO3wB,EAAgB,OAAOiB,qBAAqB8B,YACvD,MAAMiJ,EAAI2kB,EAAQza,MAAQya,EAAQza,MAAM1V,EAAM,GAAIgC,GAAOhC,EAAM,GAC3DwL,IAAM5J,QAAgBlD,IAAN8M,IAAmB2kB,EAAQhK,oBAC3CzU,EAAMjR,GAAK+K,EAClB,CACD,MAAM3L,EAAUU,EAAUmR,GAC1B,IAAImB,EAAO,CAAA,EACPud,EAAW,CAAA,EACfvwB,EAAQkW,QAAQ,EAAEtV,EAAG+K,MACjB,MAAMmiB,EAAeniB,EACf2kB,EAAU3d,EAAKjR,KAAKd,IAAM2sB,GAAS3sB,GAGzCoS,EAAKpS,IAFa0vB,EAAQ7U,YACrB6U,EAAQ1e,MAAQic,GAAyB5gB,KAC1B6gB,GAChBwC,EAAQ1e,QACJ9S,EAAQgvB,GACRpc,EAASzS,QAAQ6uB,GAEjBpc,EAASzS,KAAK6uB,IAEjBwC,EAAQ1d,OACT2d,EAAS3vB,GAAKoS,EAAKpS,GAAE,GAEzB+R,EAAKiP,eACL5O,EAAOL,EAAKiP,aAAa5O,GACzBud,EAAW5d,EAAKiP,aAAa2O,IAEjC,IAAIzO,EAAkB9O,EACtB,MAAMwd,EAAkBvwB,OAAOyB,KAAKogB,GACL,IAA3B0O,EAAgBlwB,QAChBkwB,EAAgB,KAAO7d,EAAKwG,iBAC5B2I,EAAkBA,EAAgBnP,EAAKwG,gBAGvCrV,EAAUge,EAAiB,WAEM,IAA7B7hB,OAAOyB,KAAKsR,GAAM1S,SAElB0S,EAAO8O,EACPyO,EAAWzO,IAGnB,MAAM1J,EAAYjS,KAAKC,UAAU,CAAE1D,UAASsQ,IAC5C,GAAI7Q,EAAIsuB,SAEJ,OADA7C,GAAUxV,GAAajW,EAAIsuB,SACpBtuB,EAAIsuB,SAEf,MAAMtd,EAAWhN,KAAKC,UAAU,CAAE1D,UAAS6tB,IAC3C,GAAI5d,EAAK9I,SAAW1H,EAAIwW,WAAY,CAChC,MAAM+X,EAAU/d,EAAK9I,OAAOgI,EAAO1P,EAAIgP,GACvC,GAAIuf,EACA,OAAIA,aAAmBvb,GACZub,EAAQ3T,SAIf5a,EAAIie,QACJsQ,EAAQtQ,QAAUje,EAAIie,OAGnBsQ,EAEd,CAGD,GAAI9C,GAAUxV,GACV,OAAOwV,GAAUxV,GACrB,MAAMvH,EAAc,CAChBS,GAAInP,EAAImP,GACR5O,OACAiQ,OACAd,QACA7R,UACAgT,KAAMA,EACNud,SAAUA,EACVzO,gBAAiBA,EACjBpQ,WACA0G,YACAjF,WACAhC,EAAGhP,EAAIgP,GAEPhP,EAAIie,QACJvP,EAAYuP,MAAQje,EAAIie,OAC5B,IAAK,MAAMxf,KAAKiR,EACF,gBAANjR,GAA6B,OAANA,GAAoB,QAANA,IACrCiQ,EAAYjQ,GAAKiR,EAAMjR,IAE/B,MAAMkS,EAAO,IAAImZ,GAAkBvpB,GAAMmO,GAEzC,OADA+c,GAAUxV,GAAatF,EAChBA,CAAI,EEuDU6d,CAAUjuB,EAAM,IACtB9D,EACH0S,KACAH,EAAGlQ,KACHiX,OAAQkY,IACTxc,UAAU3S,MAab,OAXIA,KAAKyuB,SAGAzuB,KAAKmQ,eAAemd,SACrBqC,GAAkB9d,EAAKd,YAK3B/R,OAAOe,OAAOC,KAAK8Q,eAAgBe,EAAKf,gBAErCe,CACP,GAAAzQ,KAAKpB,MACT,SAAA4b,CAAUtT,EAAK3K,GACX,OAAOqC,KAAKiX,OAAO3O,EAAK3K,EAC3B,CACD,WAAA0hB,CAAY5gB,GACR,OAAQuB,KAAK4vB,iBAAiBnxB,IAC1BC,EAAgBmxB,GAAyBpxB,GAChD,CACD,gBAAAmxB,CAAiBnxB,GACb,MAAMW,EAASY,KAAK8vB,0BAA0BrxB,GAC9C,IAAIyM,GAAW9L,EAAQ,WAEvB,OAAOA,CACV,CACD,yBAAA0wB,CAA0BrxB,GACtB,MAAMmgB,EAAa5e,KAAK+vB,aAAatxB,GACrC,OAAIyM,GAAW0T,EAAY,UAChBlgB,EAAgBsxB,GAAmCvxB,IACvDmgB,CACV,CACD,YAAAqR,CAAa3nB,GACT,OAAOA,CACV,CACD,YAAAynB,CAAatxB,GACT,MAAMmgB,EAAa5e,KAAKkwB,oBAAoBzxB,GAC5C,MAA6B,iBAAfmgB,EACV5e,KAAK6R,KAAK,QAAS,CAAEsN,MAAOP,GAAc,CAAElH,YAAY,IACtDkH,CACT,CACD,mBAAAsR,CAAoBzxB,GAChB,MAAM4C,EAASrB,KAAKsuB,YAAY7vB,GAChC,GAAI4C,EACA,OAAOA,EACX,IAAIiH,EAAMtI,KAAKwuB,QAAQ/vB,GACvB,OAAK6J,GAELA,EAAMtI,KAAKiwB,aAAa3nB,GACpB4C,GAAW5C,EAAK,WACRtI,KAAKsuB,YAAY7vB,KCvQS0xB,EDuQiC7nB,GCtQ7E4H,EAAE+G,OAAOkZ,EAAE7nB,IAAK,CAGtB,GACW6nB,GDmQKjlB,GAAW5C,EAAK,UACRtI,KAAKsuB,YAAY7vB,GAAQ6J,GACrCtI,KAAKsuB,YAAY7vB,GAAQA,EACjBuB,KAAKsuB,YAAY7vB,GAAQuB,KAAK4b,UAAUtT,KAPrCtI,KAAKowB,qBAAqB3xB,GCpQA,IAAC0xB,CD4QzC,CAED,oBAAAC,CAAqB3xB,GACjB,OAAO4xB,GAAgBrwB,KAAKwuB,QAAS/vB,EACxC,CACD,MAAA6xB,IAAUC,GACN,OAAO,IAAIlE,GAAW1tB,EAAUqB,KAAK4uB,UAAU2B,GAAQ,CAACpR,EAAOzhB,IAAU,CACrE,IAAIyhB,IACJzhB,IAEP,CACD8yB,qBACAC,SACA,UAAUF,GACN,IAAKvwB,KAAKywB,SAAU,CAChBzwB,KAAKywB,SAAW,GAChB,IAAK,MAAMhyB,KAAQuB,KAAKuuB,cACpBvuB,KAAKywB,SAAShyB,GAAQuB,KAAK+vB,aAAatxB,GAC5CuB,KAAK8uB,gBAAgB7Z,QAAQpD,GAAQA,EAAK+M,YAC1C5e,KAAKwwB,qBAAuBE,GAAoB1wB,KAAMA,KAAKywB,UAE3DzxB,OAAOe,OAAOC,KAAK+R,KAAMpT,EAAUqB,KAAKwwB,qBAAsB,CAAC7wB,EAAG+K,IAAMQ,GAAWR,EAAG,QAAU,CAAC/K,EAAG+K,EAAEqH,MAAQ,KAC9G/S,OAAOe,OAAOC,KAAKsuB,YAAatuB,KAAKwwB,sBACjCxwB,KAAKsN,OAAOigB,kBACZvuB,OAAOe,OAAOkuB,EAAana,SAAU9T,KAAKwwB,sBAC9CxwB,KAAK+Q,WAAa/R,OAAOQ,OAAOQ,KAAK8Q,gBAChC9Q,KAAKmQ,eAAemd,SACrBqC,GAAkB3vB,KAAK+Q,YAC3B/Q,KAAKyuB,UAAW,CACnB,CAED,OAAO,IAAIpC,GAAW1tB,EADA4xB,EAAMlxB,OAASkxB,EAAQvwB,KAAKuuB,cACH,CAACpiB,EAAG1N,IAAS,CACxDA,EACAuB,KAAKywB,SAAShyB,KAErB,CACD,OAAA2gB,CAAQ3gB,GACJ,OAAOuB,KAAK4uB,SAASnwB,EACxB,EAER,EA3OkB,GA6OnB,MAAM4xB,GAAkB,CAACtrB,EAAMtG,KAC3B,MAAMkyB,EAAWlyB,EAAK2P,QAAQ,KAC9B,IAAkB,IAAduiB,EACA,OACJ,MAAMC,EAAYnyB,EAAKuD,MAAM,EAAG2uB,GAC1BE,EAAe9rB,EAAK6rB,GAG1B,QAAqBhzB,IAAjBizB,EACA,OACJ,IAAK3lB,GAAW2lB,EAAc,UAC1B,OAAOnyB,EAAgBoyB,GAA4BF,IACvD,MAAMG,EAAWtyB,EAAKuD,MAAM2uB,EAAW,GACjC/R,EAAaiS,EAAaE,GAGhC,YAAmBnzB,IAAfghB,EACI1T,GAAW0T,EAAY,UAChByR,GAAgBzR,EAAYmS,GAChCryB,EAAgBmxB,GAAyBpxB,IAEhDyM,GAAW0T,EAAY,SAAW1T,GAAW0T,EAAY,WAClDA,OACXxgB,EAAmB,oCAAoCK,OAAU2L,GAAUwU,KAAc,EAEhFoS,GAAc,CAACxC,EAASlhB,IAAW,IAAI2jB,GAAUzC,EAASlhB,GAC1D2jB,GAAYhD,GACZzf,GAAO,IAAIyiB,GAAU,CAAA,GAW5BP,GAAsB,CAACxgB,EAAGghB,KAC5B,MAAM9xB,EAAS,CAAA,EACf,IAAK,MAAMO,KAAKuxB,EAAS,CACrB,MAAMxmB,EAAIwmB,EAAQvxB,GAClB,GAAIuL,GAAWR,EAAG,UAAW,CACzB,MACMymB,EAAsBxyB,EADH+xB,GAAoBxgB,EAAGxF,GACQ,CAAC0mB,EAAQC,IAAW,CAAC,GAAG1xB,KAAKyxB,IAAUC,IAC/FryB,OAAOe,OAAOX,EAAQ+xB,EACzB,MACQjmB,GAAWR,EAAG,YAEdQ,GAAWR,EAAG,QADnBtL,EAAOO,GAAK+K,EAIZtM,EAAmB,+BAA+BgM,GAAUM,KACnE,CACD,OAAOtL,CAAM,EAEJywB,GAA4BpmB,GAAU,IAAIA,qBAC1CqnB,GAA+BryB,GAAS,IAAIA,6DAC5CuxB,GAAsCvxB,GAAS,2BAA2BA,2BAC1EkxB,GAAqB5e,IAC9B,MAAMugB,EAAqBC,GAAaxgB,GACxC,IAAK,MAAMc,KAAQd,EACXc,EAAKZ,MAITY,EAAKZ,KAAM,EACXY,EAAKX,eACDogB,EAAmB,GAAGzf,EAAKxB,YAAYjP,KAAKkwB,GAC5Czf,EAAKS,WAAaT,EAAK9B,wBAGvB8B,EAAK7B,OAAS6B,EAAKX,gBAEvBW,EAAK5B,cACDqhB,EAAmB,GAAGzf,EAAKxB,WAAWjP,KAAKkwB,GAClD,EAECC,GAAgBxgB,IAAe,IAAIzK,GACpCmB,MAAM,SAAUgP,IACjB1F,EAAWkE,QAAQpD,IACf,MAAM2f,EAAiB,IAAI1E,GAAa,UAAUpmB,SAClDmL,EAAK7J,QAAQwpB,GACb,MAAMC,EAAgB,IAAI3E,GAAa,SAASpmB,SAChDmL,EAAK7J,QAAQypB,GACbhb,EAAGvP,KAAK,GAAGsqB,EAAepE,YAAY,GAAGvb,EAAKxB,gBAAgBnJ,KAAK,GAAGuqB,EAAcrE,YAAY,GAAGvb,EAAKxB,cAAc,GAEnHoG,IAENzO,SAXgC,GErYxB0pB,GAAaV,GAAY,CAClCW,IAAK,CAAE,EACPzuB,OAAQ,SAERK,QAAS,CAAC,CAAEoX,MAAM,GAAS,CAAEA,MAAM,IACnCiX,MAAO,CAAEjX,MAAM,GACf+E,MAAO,GACPlc,KAAM,CAAEmX,KAAM,MACdxX,OAAQ,SACRC,OAAQ,SACRC,OAAQ,SACRC,OAAQ,SACRuuB,KAAM,CAAElX,MAAM,GACd5G,QAAS,CAAE,EACX+d,KAAM,CAAEnX,UAAM/c,GACdA,UAAW,CAAE+c,UAAM/c,IACpB,CAAE4vB,mBAAmB,EAAMD,kBAAkB,IAAQqB,SCb3CmD,GAAmBf,GAAY,CACxC7V,gBAAiB,CAAC,SAAU/d,OAC5BuoB,YAAa,CAAC,SAAU,UACxBwG,yBAA0B,CAAEpM,OAAQ,SAAUzE,MAAOgN,KACtD,CACCkF,mBAAmB,EACnBD,kBAAkB,IACnBqB,SAEHpgB,GAAKqD,KAAK,QAAS,CACfnD,SAAU,CACN,SACA,SACA,SACA,SACA,SACA,CAAEiM,MAAM,GACR,CAAEA,MAAM,GACR,CAAEA,KAAM,MACR,CAAEA,UAAM/c,KAEb,CAAE4xB,SAAUhhB,GAAKqD,KAAK,eAAgB,CAAE,EAAE,CAAE6F,YAAY,MCxBpD,MAAMsa,GAAYhB,GAAY,CACjC5zB,YACAyE,kBACA6B,UACAvF,YACAwF,QACAC,cACAC,QACAI,gBACAC,gBACAC,iBACD,CAAEqpB,mBAAmB,EAAMD,kBAAkB,IAAQqB,SCX3CqD,GAAc,CAAC3W,EAAOjV,IAAgBmI,GAAK6f,WAAW,CAC/DtO,OAAQ,SACRzE,MAAO,CACHjD,KAAMiD,EAAMjG,OACZgG,MAAOC,EAAMD,MACbhV,iBCFFlD,GAASqL,GAAK6f,WAAW,CAC3Bxa,GAAIoe,GAAYnpB,GAAyB,gCACzC+F,OAAS9E,GAAMhG,OAAOmuB,WAAWnoB,KAE/BT,GAAUkF,GAAK6f,WAAW,CAC5Bxa,GAAIoe,GAAYhpB,GAA0B,gCAC1C4F,OAAQ,CAAC9E,EAAG7I,KACR,IAAKgI,GAAoBa,GACrB,OAAO7I,EAAI8M,MAAM,gCACrB,MAAMmkB,EAASpuB,OAAO6F,SAASG,GAC/B,OAAOhG,OAAOquB,cAAcD,GAAUA,EAAUjxB,EAAI8M,MAAM,6EAA8E,IAG1IqkB,GAAM7jB,GAAK6f,WAAW,CACxBxa,GAAI,SACJhF,OAAQ,CAAC9E,EAAG7I,KACR,IACI,OAAO,IAAIoxB,IAAIvoB,EAClB,CACD,MACI,OAAO7I,EAAI8M,MAAM,cACpB,KAGH+D,GAAOvD,GAAK6f,WAAW,CACzBxa,GAAI,SACJhF,OAAQ,CAAC9E,EAAG7I,KACR,IACI,OAAOgE,KAAK0P,MAAM7K,EACrB,CACD,MACI,OAAO7I,EAAI8M,MAAM,sBACpB,KAUIukB,GAAUvB,GAAY,CACnCqB,IAAIA,GACAlvB,UACAmG,WACAkpB,KAXShkB,GAAK6f,WAAW,CACzBxa,GAAI,SACJhF,OAAQ,CAAC9E,EAAG7I,KACR,MAAM9B,ECnCqB,EAAC0D,EAAMnF,KACnB,CACf,MAAMyB,EAAS,IAAIsE,KAAKZ,GACxB,OAL+BiB,OAAO+F,OAKX1K,GAAmB,eAATA,CACxC,CAuByC,EDQvBqzB,CAAoB1oB,GACnC,MAAyB,iBAAX3K,EAAsB8B,EAAI8M,MAAM5O,GAAUA,CAAM,IAQlE2S,UACD6c,SEjDG8D,GAAc,uDACdC,GAAc,IAAID,YAAqBA,KAEhCE,GAAOX,GADA,IAAIruB,OAAO,IAAI+uB,OACU,wBACvCE,GAAc,uBAWPC,GAAOb,GAVA,IAAIruB,OACpB,QAAMivB,aAAsBA,YACtBA,aAAsBF,OAAgBE,YACtCA,cAAuBF,QAAiBE,kBACxCA,eAAwBA,YAAqBF,QAAiBE,kBAC9DA,eAAwBA,YAAqBF,QAAiBE,kBAC9DA,eAAwBA,YAAqBF,QAAiBE,kBAC9DA,eAAwBA,YAAqBF,QAAiBE,wBACxDA,YAAqBF,UAAmBE,wCAEX,wBAChCE,GAAKvkB,GAAK6f,WAAW,CAACuE,GAAME,KCdnCT,GAAM7jB,GAAK6f,WAAW,CACxBtO,OAAQ,SACRlP,UAAW,CACPA,UAAY9G,IACR,IACI,IAAIuoB,IAAIvoB,EACX,CACD,MACI,OAAO,CACV,CACD,OAAO,CAAI,EAEf1D,YAAa,iBAKf2sB,GAAQf,GADO,mDACmB,iBAGlCgB,GAAOhB,GAFO,gFAEkB,gBAGhCiB,GAASjB,GAFO,sLAEoB,sDACpCkB,GAAa3kB,GAAK6f,WAAW,CAC/BtO,OAAQ,SACRzE,MAAO,CACHjD,KCRyB,+PDQDhD,OACxBhP,YAAa,8BAEjBwK,UAAW,CACPA,UCnCoBuiB,IACxB,MAAMC,EAAYD,EAAgBE,QAAQ,SAAU,IACpD,IACIC,EACAC,EAFAC,EAAM,EAGNC,GAAe,EACnB,IAAK,IAAIv0B,EAAIk0B,EAAUh0B,OAAS,EAAGF,GAAK,EAAGA,IACvCo0B,EAAQF,EAAUM,UAAUx0B,EAAGA,EAAI,GACnCq0B,EAASzvB,OAAO6F,SAAS2pB,EAAO,IAC5BG,GACAF,GAAU,EAENC,GADAD,GAAU,GACFA,EAAS,GAAM,EAEhBA,GAGXC,GAAOD,EACXE,GAAgBA,EAEpB,QAAUD,EAAM,IAAO,IAAIJ,EAAkB,EDgBzChtB,YAAa,gCAGRutB,GAAa5C,GAAY,CAClC6C,MAAO5B,GAAY,cAAe,gBAClC6B,aAAc7B,GAAY,gBAAiB,2BAC3C8B,UAAW9B,GAAY,WAAY,0BACnC+B,UAAW/B,GAAY,WAAY,0BACnCkB,cACAH,SACAC,QACAZ,OACAa,UACAH,MACAzpB,QAAS,CACLyW,OAAQ,SACRzH,QAAS,IAEd,CAAEkV,mBAAmB,IAAQoB,SEhDnBqF,GAAmBjD,GAAY,IACrCU,MACAM,MACA4B,GACHhf,MAAO2d,KAGXtE,GAAaS,QAAUuF,GAAiB1c,IACjC,MAAM2c,GAAeD,GAAiBrF,SCbtC,MAAMuF,WAAgB9xB,EACzBN,OACAuG,IACA4H,EACAjF,CAACA,IAAW,UACZ,WAAApL,CAAYkC,EAAQuG,EAEpB4H,GACI/N,MAAM,IAAIL,IAOCoO,EAAE0L,UAAUtT,IAEvBtI,KAAK+B,OAASA,EACd/B,KAAKsI,IAAMA,EACXtI,KAAKkQ,EAAIA,CACZ,ECrBE,MAAMkkB,GACTC,MACAl1B,EACA,WAAAU,CAAYyI,GACRtI,KAAKq0B,MAAQ,IAAI/rB,GACjBtI,KAAKb,EAAI,CACZ,CAED,KAAAmY,GACI,OAAQtX,KAAKq0B,MAAMr0B,KAAKb,MAAQ,EACnC,CACD,aAAIm1B,GACA,OAAQt0B,KAAKq0B,MAAMr0B,KAAKb,IAAM,EACjC,CACD,iBAAIo1B,GACA,OAAOv0B,KAAKq0B,MAAMr0B,KAAKb,EAAI,IAAM,EACpC,CACD,UAAIE,GACA,OAAOW,KAAKq0B,MAAMh1B,MACrB,CACD,UAAAm1B,CAAWjtB,GACP,IAAIktB,EAAU,GACd,KAAOz0B,KAAKs0B,WAAW,CACnB,GAAI/sB,EAAUvH,KAAMy0B,GAAU,CAC1B,GAAIA,EAAQA,EAAQp1B,OAAS,KAAO+0B,GAAQM,YAGxC,MAFAD,EAAUA,EAAQzyB,MAAM,GAAI,EAGnC,CACDyyB,GAAWz0B,KAAKsX,OACnB,CACD,OAAOmd,CACV,CACD,wBAAAE,GAEI,OADA30B,KAAK40B,0BACE50B,KAAKw0B,WAAWJ,GAAQS,sBAClC,CACD,uBAAAD,GACI,OAAO50B,KAAKw0B,WAAWJ,GAAQU,yBAClC,CACD,WAAAC,CAAY51B,GACRa,KAAKb,EAAIA,EAAI,EAAIa,KAAKX,OAASF,EAAIA,CACtC,CACD,YAAI61B,GACA,OAAOh1B,KAAKb,CACf,CACD,aAAI81B,GACA,OAAOj1B,KAAKq0B,MAAMryB,MAAMhC,KAAKb,EAAGa,KAAKX,QAAQiP,KAAK,GACrD,CACD,WAAI4mB,GACA,OAAOl1B,KAAKq0B,MAAMryB,MAAM,EAAGhC,KAAKb,GAAGmP,KAAK,GAC3C,CACD,UAAA6mB,CAAWC,EAAOC,GACd,OAAOr1B,KAAKq0B,MAAMryB,MAAMozB,EAAOC,GAAK/mB,KAAK,GAC5C,CACD,WAAAgnB,CAAYC,GACR,OAAOv1B,KAAKs0B,YAAciB,CAC7B,CACD,aAAAC,CAAcC,GACV,OAAOz1B,KAAKs0B,aAAamB,CAC5B,GAEL,SAAWrB,GACPA,EAAQS,sBAAyBa,GAAYA,EAAQpB,aAAaF,EAAQuB,iBAC1EvB,EAAQU,yBAA4BY,KAAcA,EAAQpB,aAAaF,EAAQwB,kBAC/ExB,EAAQuB,iBAAmB,CACvB,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,EACL,KAAK,GAETvB,EAAQyB,qBAAuB,CAC3B,KAAK,EACL,KAAK,EACL,IAAI,GAERzB,EAAQM,YAAc,KACtBN,EAAQwB,iBAAmB,CACvB,KAAK,EACL,MAAM,EACN,MAAM,GAEVxB,EAAQ0B,sBAAwB,CAACxB,EAAWW,IAA4B,MAAdX,EACrC,MAAjBW,EAAU,GAGW,MAAjBA,EAAU,GAEkB,KAA1BA,EAAUc,aACRr2B,EAAQu1B,EAAUc,YAAY,GAAI3B,EAAQuB,kBAElC,MAAdrB,CACT,CApCD,CAoCGF,KAAYA,GAAU,CAAA,IChGlB,MA+DM4B,GAAa,EAAEnvB,EAAKnJ,MAC7B,MAAMu4B,EAAYC,GAASrvB,GAC3B,OAAIhJ,EAAQH,IAAuB,MAAbA,EAAM,IACD,aAAnBu4B,EAAUx0B,MACV/C,EAAgBy3B,IACb,CACH10B,KAAM,WACNoF,IAAKovB,EAAUpvB,IACfnJ,MAAOA,EAAM,GACb8mB,QAAS9mB,EAAM,KAGhB,CACH+D,KAAMw0B,EAAUx0B,KAChBoF,IAAKovB,EAAUpvB,IACfnJ,QACA8mB,QAAS1jB,EACZ,EAGQq1B,GAA+B,oFACtCD,GAAYrvB,GAAuB,iBAARA,EAAmB,CAAEpF,KAAM,WAAYoF,OACnD,MAAfA,EAAI3E,IAAI,GACN2E,EAAI3E,IAAI,KAAOkyB,GAAQM,YACnB,CAAEjzB,KAAM,WAAYoF,IAAK,GAAGA,EAAI7E,MAAM,GAAI,OACxC,CACEP,KAAM,WACNoF,IAAKA,EAAI7E,MAAM,GAAI,IAEd,MAAX6E,EAAI,IAA6B,MAAfA,EAAI3E,IAAI,GACxB,CAAET,KAAM,QAASoF,IAAKA,EAAI7E,MAAM,GAAI,IAClC6E,EAAI,KAAOutB,GAAQM,aAA0B,MAAX7tB,EAAI,IAA6B,MAAfA,EAAI3E,IAAI,GAC1D,CAAET,KAAM,WAAYoF,IAAKA,EAAI7E,MAAM,IACzB,QAAR6E,GAAyB,MAARA,EAAc,CAAEpF,KAAMoF,EAAKA,OACxC,CACEpF,KAAM,WACNoF,IAAa,UAARA,EAAkB,MACT,QAARA,EAAgB,IACZA,GCxGrBuvB,GAAiB,CAC1B,KAAK,EACL,MAAM,GAEGC,GAAiB,CAC1B,KAAK,EACL,MAAM,GASGC,GAAsB,CAC/B,IAAK,IACL,IAAK,IACL,KAAM,KACN,KAAM,KACN,KAAM,MAGGC,GAA6BC,GAAgB,WAAWA,IAExDC,GAAoC1d,GAAe,yEAAyEA,KCvBnI2d,GAAoB,CAACj4B,EAAMsD,EAAQgI,EAAG4sB,EAASC,KACjD,MAAMC,EAAW9sB,EAAE+sB,sBAInB,OAFAH,EAAQ34B,KAAK64B,EAASnB,QAAQR,QAAQlzB,MAAM,GAAI,IAChD40B,EAAS54B,KAAK64B,EAASroB,MACI,MAAvBqoB,EAASE,UACLH,EAASv3B,SAAW0C,EAAO1C,OACpB,CACHD,OAAQw3B,EACR3B,UAAW4B,EAASnB,QAAQT,WAG7B4B,EAAS7oB,MAAMgpB,GAA+Bv4B,EAAMsD,EAAQ40B,IAE5C,MAAvBE,EAASE,UACFL,GAAkBj4B,EAAMsD,EAAQgI,EAAG4sB,EAASC,GAChDC,EAAS7oB,MAAMuoB,GAA0B,KAAK,EAE5CS,GAAiC,CAACv4B,EAAMsD,EAAQ40B,IAAY,GAAGl4B,KAAQsD,EAAOuM,KAAK,2BAA2BvM,EAAO1C,oBAAoBs3B,EAAQt3B,SAA4B,IAAnBs3B,EAAQt3B,OAAe,GAAK,KAAKs3B,EAAQroB,KAAK,WC4BxM2oB,GAA8BltB,IACvC,MAAM2L,EAAW3L,EAAEmtB,mBACnB,OAAOxhB,EACHyhB,GAAgCzhB,EAAU3L,EAAE2rB,QAAQT,WAClDmC,GAA+BrtB,EAAE2rB,QAAQT,UAAU,EAEhDkC,GAAkC,CAAC1tB,EAAOwrB,EAAY,KAAO,UAAUxrB,8BAAkCwrB,EAAY,YAAYA,KAAe,KAChJmC,GAAkCnC,GAAc,0BAAyBA,EAAY,YAAYA,KAAe,ICdvHoC,GAAgB,CAACtyB,EAAMtD,EAAMlE,KAC/B,OAAQkE,GACJ,IAAK,WACD,OAAIsD,EAAKkiB,UAEEvoB,EAAgB44B,KACvBvyB,EAAKkc,SAELlc,EAAKmiB,QAAU1pB,EAAOuH,EAAKmiB,QAAS3pB,GAIpCwH,EAAKoB,OAAS3I,EAAOuH,EAAKoB,OAAQ5I,GAE/BwH,GACX,IAAK,WACD,OAAIA,EAAKkc,SAEEviB,EAAgB64B,KAE3BxyB,EAAKkiB,UAAYzpB,EAAOuH,EAAKkiB,UAAW1pB,GACjCwH,GACX,IAAK,WAgBD,OAdIA,EAAKmiB,SACLxoB,EAAgB84B,IAChBzyB,EAAKkc,SACAlc,EAAKkc,SAASjP,OAAOzU,IAEtBmB,EAAgB84B,IAOpBzyB,EAAKkc,SAAW1jB,EAAQga,IAErBxS,EACd,EAEC0yB,GAAqB,CAAC1yB,EAAMmX,KAC9B,MAAMwb,EAASxb,EAAOhJ,qBAAqB,YAC3C,OAAKwkB,GAILA,EAAOvxB,OAAO8O,QAAQpD,GAAQwlB,GAActyB,EAAM,WAAY8M,IAC9D6lB,EAAOzQ,UAAUhS,QAAQpD,GAAQwlB,GAActyB,EAAM,WAAY8M,IACjE6lB,EAAOzW,UAAYoW,GAActyB,EAAM,WAAY2yB,EAAOzW,UAC1DyW,EAAOxQ,QAAQjS,QAAQpD,GAAQwlB,GAActyB,EAAM,WAAY8M,IACxD9M,GANIsyB,GAActyB,EAAM,WAAY2sB,GAAW3d,QAM3C,EASFyjB,GAAyB,gDACzBF,GAA8B,wDAC9BC,GAA8B,wDAGrCI,GAAmB,CAACrvB,EAAKpH,KAC3B,QAAetD,IAAX0K,EAAI,GACJ,OAAO5J,EAAgBy4B,GAAgC7uB,EAAI,GAAI,KACnE,MAAMhI,EAAIY,EAAIgP,EAAE0E,MAAMtM,EAAI,GAAIpH,GACxBX,EAAIW,EAAIgP,EAAE0E,MAAMtM,EAAI,GAAIpH,GAC9B,MAAkB,MAAXoH,EAAI,GAAahI,EAAEub,IAAItb,GAAKD,EAAEyb,GAAGxb,EAAE,EAWjCq3B,GAA4C,CAACliB,EAAUhY,IAAU,GAAgB,MAAbgY,EAAmB,SAAW,qDAAqDA,kBAAyBhY,KAQvLm6B,GAAkB,CACpB,IAAKF,GACL,IAAKA,GACL,KApBoB,CAACrvB,EAAKpH,IAAQA,EAAIgP,EAAE0E,MAAMtM,EAAI,GAAIpH,GAAK5D,QAqB3D,IAX4B,CAACgL,EAAKpH,IACZ,mBAAXoH,EAAI,GACJ5J,EAAgBk5B,GAA0C,IAAKtvB,EAAI,KAEvEpH,EAAIgP,EAAE0E,MAAMtM,EAAI,GAAIpH,GAAK4b,UAAU,YAAaxU,EAAI,IAQ3D,KApB2B,CAACA,EAAKpH,IACX,mBAAXoH,EAAI,GACJ5J,EAAgBk5B,GAA0C,KAAMtvB,EAAI,KAGxEpH,EAAIgP,EAAE0E,MAAMtM,EAAI,GAAIpH,GAAKuH,KAAKH,EAAI,IAgBzC,IAPwB,CAACA,EAAKpH,IAAQA,EAAIgP,EAAE0E,MAAMtM,EAAI,GAAIpH,GAAK8S,4BAA4B1L,EAAI,KAS7FwvB,GAAgB,CAClBrc,MAlC2B,CAACnT,EAAKpH,IAAQA,EAAIgP,EAAE0E,MAAMtM,EAAI,GAAIpH,GAAKua,QAmClEsc,WAAY,CAACzvB,EAAKpH,KACd,GAAsB,mBAAXoH,EAAI,GACX,OAAO5J,EAAgBs5B,GAA+B1zB,EAAqBgE,EAAI,MAEnF,MAAMoG,EAAWpG,EACZtG,MAAM,GACNnB,IAAItC,GAAwB,mBAATA,EACpB2C,EAAIgP,EAAE2B,KAAK,QAAS,CAAEwK,MAAO9d,IAC3BG,EAAgBs5B,GAA+B1zB,EAAqB/F,MAC1E,OAA2B,IAApBmQ,EAASrP,OACZqP,EAAS,GACPxN,EAAIgP,EAAE2B,KAAK,QAAS,CAAEnD,YAAW,EAE3C,MAAO,CAACpG,EAAKpH,IAAQA,EAAIgP,EAAE0P,MAAMtX,EAAItG,MAAM,KAGlCg2B,GAAkCxrB,GAAW,+DAA+DA,KChI5GyrB,GAAiCzrB,GAAW,oDAAoDA,KCvBhG0rB,GAAeC,GAAuB,iBAAjBA,EAAEzqB,WAEvB0qB,GAA2B/iB,GAAW,IAAIA,iDCcjDgjB,GAAqB,CACvB,KAAK,EACL,KAAK,GAEIC,GAAuB,CAChC,IAAK,EACL,IAAK,EACL,IAAK,GAMIC,GAAgB,CAACxf,EAAYmB,EAAO1L,EAAMgqB,IAC/ChqB,EAAK2N,QAAQuV,GAAWvuB,QACH,iBAAV+W,EACAxb,EAAgB+5B,GAAyB1f,EAAYmB,EAAOse,IAEhD,OAAfzf,EAAsB,CAAC,MAAO,OACd,MAAlBA,EAAW,GAAa,CAAC,OACrB,CAAC,OAEXvK,EAAK2N,QAAQ4V,GAAiB5W,iBACT,iBAAVjB,EACAxb,EAAgB+5B,GAAyB1f,EAAYmB,EAAOse,IAEhD,OAAfzf,EAAsB,CAAC,YAAa,aACpB,MAAlBA,EAAW,GAAa,CAAC,aACrB,CAAC,aAEXvK,EAAK2N,QAAQ6V,GAAUtuB,MAEA,OAAfqV,EAAsB,CAAC,QAAS,UAChB,MAAlBA,EAAW,GAAa,CAAC,SACrB,CAAC,UAERra,EtDS4B,CAAC8P,GAAS,sBAAsBA,6CsDT5CkqB,CAAwBlqB,EAAKlH,aAqC3CmxB,GAA2B,CAAC1f,EAAYmB,EAAOse,IAAc,cAA4B,SAAdA,EAAuBlC,GAAoBvd,GAAcA,aAAoC,SAAdyf,EAAuB,WAAa,8CAA8Cte,KCpF5Oye,GAA8BrgB,GAAY,kEAAkEA,KCN5GsgB,GAAiB7uB,IAC1B,MAAMuqB,EAAYvqB,EAAE2rB,QAAQpe,QAC5B,MAAsB,KAAdgd,EAAmBvqB,EAAE+E,SAAS,IAClB,MAAdwlB,EACwB,MAAtBvqB,EAAE2rB,QAAQpe,QACNvN,EAAE8uB,QAAQ9uB,EAAEyE,KAAKlR,SACfyM,EAAEiE,MAAM8qB,IACE,MAAdxE,GAAmC,MAAdA,EAAoBvqB,EAAEgvB,iBAAiBzE,GAC1C,MAAdA,EAAoBvqB,EAAEivB,gBAClB5E,GAAQ0B,sBAAsBxB,EAAWvqB,EAAE2rB,QAAQT,WACjDlrB,EAAE+E,SAASwlB,GACT50B,EAAQ40B,EAAWgE,IFXnB,EAACvuB,EAAGqrB,KAC1B,MAAMrc,EAyBc,EAAChP,EAAGqrB,IAAUrrB,EAAE2rB,QAAQJ,YAAY,KAAO,GAAGF,IAAQrrB,EAAE2rB,QAAQpe,UAClF5X,EAAQ01B,EAAOiD,IAAsBjD,EACjCrrB,EAAEiE,MA2BuB,6DAtDZirB,CAAgBlvB,EAAGqrB,GACtC,GAAIrrB,EAAEyE,KAAK8B,QAAQ,QAAS,CACxB,GAA2B,iBAAhBvG,EAAEyE,KAAKmM,KAGd,OAFA5Q,EAAEmvB,gBAAgBnvB,EAAEyE,KAAKmM,KAAM5B,QAC/BhP,EAAEovB,YAGN,GAAIpvB,EAAEyE,KAAKmM,gBAAgBjX,KAAM,CAC7B,MAAM01B,EAAU,KAAKrvB,EAAEyE,KAAKnI,aAAe0D,EAAEyE,KAAKmM,KAAKF,iBAGvD,OAFA1Q,EAAEovB,iBACFpvB,EAAEmvB,gBAAgBE,EAASrgB,EAE9B,CACJ,CACD,MA+C2B,EAAChP,EAAGgP,KAE/B,MAAMsgB,EAAetvB,EAAEovB,YACjBG,EAAuBvvB,EAAE2rB,QAAQV,SACvCjrB,EAAEwvB,eACF,MAAMC,EAAYzvB,EAAEovB,YAGdM,EAAa1vB,EAAE2rB,QAAQP,WAAWmE,EAAsBvvB,EAAE2rB,QAAQV,UAExE,GADAjrB,EAAEyE,KAAO6qB,GACJG,EAAUlpB,QAAQ,SACQ,iBAAnBkpB,EAAU7e,QAAuB6e,EAAU7e,gBAAgBjX,MACnE,OAAOqG,EAAEiE,MAAMyqB,GAAyB1f,EAAY0gB,EAAY,UACpE,MAAMvf,EAAQsf,EAAU7e,KAElB1B,EAAkC,IAAtBF,EAAW1Z,OAE7B,IAAK,MAAMoC,KAAQ82B,GAAcxf,EAA6B,iBAAVmB,EAAqBA,EAAQuf,EAAYJ,EAAc,SACvGtvB,EAAE2vB,cAAcj4B,EAAM,CAAE4W,KAAM6B,EAAOjB,cACzC,IAAKlP,EAAE2E,SAASirB,UACZ,OAEJ,IAAKj6B,EAAQqZ,EAAYsd,IACrB,OAAOtsB,EAAEiE,MAAMyoB,GAAiC1d,IACpD,MAAM6gB,EAAiBrB,GAAcxuB,EAAE2E,SAASirB,UAAU5gB,WAAYhP,EAAE2E,SAASirB,UAAUzf,MAAOmf,EAAc,QA9BxF,IAACM,EDtDYP,EALX17B,EC0F1BqM,EAAE2vB,cAAcE,EAAe,GA/BS,CACxCvhB,MD5D0B3a,GC2DDi8B,EA+B8B5vB,EAAE2E,SAASirB,WA9BpCzf,MD5DuB,iBAAVxc,GAC9B,MAAbA,EAAM,IACQ,MAAbA,EAAM,IAA2B,MAAbA,EAAM,IAC3BA,EAAMwE,IAAI,KAAOxE,EAAM,GC2DjBi8B,EAAUzf,ODzDqBkf,ECwDRO,EAAUzf,MDxDUkf,EAAQp3B,MAAM,GAAI,KC0DnEiX,UAA2C,IAAhC0gB,EAAU5gB,WAAW1Z,SA4BhC0K,EAAE2E,SAASirB,UAAY,IAAI,EAzEpBE,CAAgB9vB,EAAGgP,EAAW,EEJ4B+gB,CAAW/vB,EAAGuqB,GACvC,MAAdA,EDfF,CAACvqB,IACzB,MAAMgwB,EAAehwB,EAAE2rB,QAAQf,2BACzBrc,GrEoCsB7O,EqEpCIswB,ErEoCGrwB,EqEpCW,CAC1CS,YAAawuB,GAA2BoB,IrEmCGpwB,GAAaF,EAAO,UAAWC,IAAnD,IAACD,EAAOC,EqEjCnB,IAAZ4O,GACAvO,EAAEiE,MAAM2qB,GAA2B,IACvC5uB,EAAEyE,KAAOzE,EAAEyE,KAAKsO,UAAU,UAAWxE,EAAQ,ECQC0hB,CAAajwB,GACf,MAAduqB,EAAoBsE,GAAc7uB,GAC9BA,EAAEiE,MAAMisB,GAAgC3F,GAAa,EAE9E2F,GAAkC,CAAC1E,EAAM2E,EAAW,KAAO,IAAI3E,yBAA4B2E,GAAY,eAAeA,OACtHpB,GAA8B,uBClB9BqB,GAAsB7xB,GAAQ8xB,GAAoB,IAAIhG,GAAQ9rB,IAErE8xB,GAAuB1E,IACzB,MAAM2E,EAAQ3E,EAAQf,2BACR,KAAV0F,GACA37B,EAJoC,yDAKxCg3B,EAAQd,0BACR,MAAM0F,EAAoB5E,EAAQpe,QAClC,MAA8B,KAAtBgjB,EAA2B,CAACD,GACR,MAAtBC,EAA4B,CAACD,KAAUD,GAAoB1E,IACvDh3B,EAAgBu7B,GAAgCK,EAAmB,KAAO,ECX3EC,GAAgB,CAACxwB,EAAGywB,KAC7B,MAAMC,EAAW1wB,EAAE2rB,QAAQlB,WAAWkG,GAAwBC,GAAgBH,KAC9E,GAA4B,KAAxBzwB,EAAE2rB,QAAQpB,UACV,OAAOvqB,EAAEiE,MAAM4sB,GAAiCH,EAAUD,IAG9D,GADAzwB,EAAE2rB,QAAQpe,QACQ,MAAdkjB,EAGAzwB,EAAEyE,KAAOzE,EAAE7I,IAAIgP,EAAE2B,KAAK,eAAgB,CAClCkO,OAAQ,SACRzE,MAAOmf,GACR,CAAE/iB,YAAY,SAEhB,GAAIhY,EAAQ86B,EAAWK,IACxB9wB,EAAEyE,KAAOzE,EAAE7I,IAAIgP,EAAE2B,KAAK,OAAQ,CAAE8I,KAAM8f,QACrC,CACD,MAAMjI,ELVS,EAACnd,EAAQlL,KAC5B,MAAM2wB,EAAmB,IAAIp3B,KAAK2R,GAClC,GAAI6iB,GAAY4C,GACZ,OAAOA,EACX,MAAMC,EAAcvxB,GAAe6L,GACnC,QAAoBzX,IAAhBm9B,EAA2B,CAC3B,MAAMC,EAAmB,IAAIt3B,KAAKq3B,GAClC,GAAI7C,GAAY8C,GACZ,OAAOA,CACd,CACD,OAAO7wB,EACHzL,GAAgC,IAAhByL,EAAuBiuB,GAAwB/iB,GAAUlL,QACvEvM,CAAS,EAbkCq9B,CKWnBR,EAAUrC,GAAwBqC,IAC5D1wB,EAAEyE,KAAOzE,EAAE7I,IAAIgP,EAAE2B,KAAK,OAAQ,CAAE8I,KAAM6X,EAAMnsB,YAAao0B,GAC5D,GAEQI,GAAiB,CAC1B,IAAK,EACL,IAAK,GAEIK,GAAgB,CACzB,IAAK,EACL,IAAK,EACL,IAAK,GAEIP,GAAkB,CAC3B,KAAM,IACN,KAAM,IACN,IAAK,IACL,IAAK,IACL,IAAK,KAEID,GAA0B,CACnC,IAAKhF,GAAiC,MAAtBA,EAAQpB,UACxB,IAAKoB,GAAiC,MAAtBA,EAAQpB,UACxB,IAAKoB,GAAiC,MAAtBA,EAAQpB,WAEtB6G,GAA4B,CAC9B,IAAK,eACL,IAAK,eACL,IAAK,iBAEIP,GAAmC,CAACQ,EAAUC,IAAmB,GAAGA,IAAiBD,wBAA+BD,GAA0BR,GAAgBU,MC9C9J9B,GAAgBxvB,GAA8B,KAAxBA,EAAE2rB,QAAQpB,UAAmBvqB,EAAEiE,MAAMipB,GAA2BltB,IACrE,MAAxBA,EAAE2rB,QAAQpB,UAAoBvqB,EAAEuxB,eAAeC,kBAC3CxxB,EAAE2rB,QAAQF,cAAc0F,IAAiBX,GAAcxwB,EAAGA,EAAE2rB,QAAQpe,SAChEvN,EAAE2rB,QAAQF,cAAcpB,GAAQwB,kBAC9B2D,GAAaxvB,EAAEuxB,gBACW,MAAxBvxB,EAAE2rB,QAAQpB,WACRvqB,EAAE2rB,QAAQnB,iBAAiBsG,GACvBN,GAAcxwB,EAAG,GAAGA,EAAE2rB,QAAQpe,UAAUvN,EAAE2rB,QAAQpe,WTN3C,CAACvN,IAC5B,MAAMN,EAAQM,EAAE2rB,QAAQf,2BACV,UAAVlrB,EACAM,EAAEyxB,UAAU,SAEZzxB,EAAEyE,KAae,EAACzE,EAAGN,IAMD,EAACM,EAAGN,KAC5B,GAAIM,EAAE7I,IAAIY,OAAO2H,GACb,OAAOM,EAAE7I,IAAIY,KAAK2H,GAAO8N,IAC7B,MAAMqH,EAAa7U,EAAE7I,IAAIgP,EAAE6f,aAAatmB,GACxC,OAAImV,aAAsBrD,GACfqD,OACQhhB,IAAfghB,EAEA1T,GAAW0T,EAAY,WAzBU,EAACngB,EAAM0xB,EAAGpmB,KAG/C,GAFAA,EAAE2rB,QAAQd,0BAEQ,MADA7qB,EAAE2rB,QAAQpe,QAExB,OAAOvN,EAAEiE,MAAMgpB,GAA+Bv4B,EAAM0xB,EAAEpuB,OAAQ,KAClE,MAAM05B,EDfsB,EAACh9B,EAAMsD,EAAQgI,IAAM2sB,GAAkBj4B,EAAMsD,EAAQgI,EAAG,GAAI,ICerE2xB,CAAiBj9B,EAAM0xB,EAAEpuB,OAAQgI,GAC9C4xB,EAAiBF,EAAWxG,UAAU51B,OAG5C,OADA0K,EAAE2rB,QAAQX,YAA+B,IAAnB4G,EAAuB5xB,EAAE2rB,QAAQr2B,QAAUs8B,GAC1DxL,KAAKsL,EAAWr8B,OAAO,EAiBnBw8B,CAA0BnyB,EAAOmV,EAAY7U,GACjDrL,EAAgB,yBAAyB0L,GAAUwU,WAJ1D,CAIwE,EAhBrCid,CAAoB9xB,EAAGN,IAkB1B,EAACM,EAAGN,KACpC,MAAMqyB,EAActyB,GAAeC,EAAO,CAAEQ,QAAQ,IACpD,QAAoBrM,IAAhBk+B,EACA,OAAO/xB,EAAE7I,IAAIgP,EAAE2B,KAAK,OAAQ,CAAE8I,KAAMmhB,IACxC,MAAMC,EhEY8B,CAACzzB,IACrC,GAA4B,MAAxBA,EAAIA,EAAIjJ,OAAS,GACjB,OACJ,MAAM28B,EAAsB1zB,EAAItG,MAAM,GAAI,GAC1C,IAAItE,EACJ,IACIA,EAAQu+B,OAAOD,EAClB,CACD,MACI,MACH,CACD,OAAI/yB,GAAyBhD,KAAK+1B,GACvBt+B,EACPyL,GAAmBlD,KAAK+1B,GAGjBt9B,EAAgB6K,GAAoCjB,EAAK,gBAHpE,CAIC,EgE7BmB4zB,CAAyBzyB,GAC7C,YAAoB7L,IAAhBm+B,EACOhyB,EAAE7I,IAAIgP,EAAE2B,KAAK,OAAQ,CAAE8I,KAAMohB,SADxC,CACsD,EAvBtDI,CAA4BpyB,EAAGN,IAC/BM,EAAEiE,MAAgB,KAAVvE,EAAewtB,GAA2BltB,GAC/B,MAAbN,EAAM,GUxB6C,wDVyBZA,EUzBwEzH,MAAM,eV0BjH6tB,GAAyBpmB,IAlBtB2yB,CAAiBryB,EAAGN,EAAM,ESGrB4yB,CAAgBtyB,GEGzB+sB,GAAuB/sB,IAChC,UAAuBnM,IAAhBmM,EAAEgtB,WACLuF,GAAKvyB,GACT,OAAOA,CAAC,EAENuyB,GAAQvyB,GAAMA,EAAEwyB,UAAYxyB,EAAE6uB,gBAAkB7uB,EAAEwvB,eCdjD,MAAMiD,GACTt7B,IACAw0B,QAEAlnB,KACAE,SAAW,CACP+tB,SAAU,GACV9C,UAAW,KACXpd,aAAc,KACd6F,MAAO,MAEX2U,UACA2F,OAAS,GACT,WAAA78B,CAAYyI,EAAKpH,GACblB,KAAKkB,IAAMA,EACXlB,KAAK01B,QAAU,IAAItB,GAAQ9rB,EAC9B,CACD,KAAA0F,CAAM3P,GACF,OAAOK,EAAgBL,EAC1B,CACD,OAAAk+B,GACI,YAAqB3+B,IAAdoC,KAAKwO,IACf,CACD,OAAAqqB,CAAQrqB,GACJxO,KAAKwO,KAAOA,CACf,CACD,SAAA2qB,GACI,MAAMz7B,EAAQsC,KAAKwO,KAEnB,OADAxO,KAAKwO,UAAO5Q,EACLF,CACV,CACD,aAAAg8B,IAAiB53B,GACb9B,KAAKwO,KAAOxO,KAAKwO,KAAKsO,UAAUhb,EAAK,GAAIA,EAAK,GACjD,CACD,QAAAgN,CAASioB,GACL,GAAI/2B,KAAK08B,OAAOr9B,OACZ,OAAOW,KAAKgO,MAAMuoB,GAA0B,MAChDv2B,KAAK28B,mBACL38B,KAAK+2B,UAAYA,CACpB,CACD,eAAAmC,CAAgBhf,EAAOnB,GACnB,MAAM6jB,EAAqBtG,GAAoBvd,GAC/C,OAAKrZ,EAAQk9B,EAAoBxG,IAE7Bp2B,KAAK0O,SAASirB,UACP35B,KAAKgO,MdzBsB,EAAC6uB,EAAWC,EAAgB5iB,EAAOnB,IAAe,yDcyBnC/Y,KAAK0O,SAASirB,UAAUzf,QdzBgFoc,GcyBzEt2B,KAAK0O,SAASirB,UAAU5gB,gBdzByFmB,IAAQoc,GAAoBvd,McyB3MgkB,CAA+B/8B,EAA+BA,EAAoCka,EAAO0iB,SAE/H58B,KAAK0O,SAASirB,UAAY,CACtB5gB,WAAY6jB,EACZ1iB,UANOla,KAAKgO,MAAMyoB,GAAiC1d,GAQ1D,CACD,gBAAA4jB,GACI38B,KAAKg9B,mBACDh9B,KAAK0O,SAAS0T,OACdpiB,KAAK+4B,iBAAiB,KACtB/4B,KAAKwO,KAAOxO,KAAK0O,SAAS0T,OAErBpiB,KAAK0O,SAAS6N,cACnBvc,KAAK+4B,iBAAiB,KACtB/4B,KAAKwO,KAAOxO,KAAK0O,SAAS6N,cAG1Bvc,KAAKi9B,eACZ,CACD,aAAAjE,GACIh5B,KAAK28B,mBACL,MAAMO,EAAiBl9B,KAAK08B,OAAOhtB,MACnC,IAAKwtB,EACD,OAAOl9B,KAAKgO,MdrDsC,eAA6B,MAA3CinB,EcqDcj1B,KAAK01B,QAAQT,WdrDqB,GAAK,WAAWA,MAAjE,IAACA,EcsDxCj1B,KAAK0O,SAAWwuB,CACnB,CACD,SAAA1B,CAAUr1B,GACNnG,KAAK0O,SAAS+tB,SAASz+B,KAAKmI,EAC/B,CACD,aAAA82B,GACI,KAAOj9B,KAAK0O,SAAS+tB,SAASp9B,QAAQ,CAClC,MAAM89B,EAAan9B,KAAK0O,SAAS+tB,SAAS/sB,MAC1C1P,KAAKwO,KACc,UAAf2uB,EACIn9B,KAAKwO,KAAKiN,QACRrd,EAAmB,sBAAsB++B,KACtD,CACJ,CACD,gBAAApE,CAAiBtvB,GACbzJ,KAAKg9B,mBACLh9B,KAAKi9B,gBACL,MAAMzuB,EAAOxO,KAAKwO,KAClBxO,KAAK0O,SAAS6N,aAAevc,KAAK0O,SAAS6N,cAAcV,IAAIrN,IAASA,EACxD,MAAV/E,IACAzJ,KAAK0O,SAAS0T,MACVpiB,KAAK0O,SAAS0T,OAAOrG,GAAG/b,KAAK0O,SAAS6N,eAClCvc,KAAK0O,SAAS6N,aACtBvc,KAAK0O,SAAS6N,aAAe,MAEjCvc,KAAKwO,UAAO5Q,CACf,CACD,mBAAAk5B,GACI,OAAOA,GAAoB,IAAI0F,GAAax8B,KAAK01B,QAAQT,UAAWj1B,KAAKkB,KAC5E,CACD,aAAA03B,GACI,OAAOA,GAAc54B,KACxB,CACD,YAAAu5B,GACI,OAAOA,GAAav5B,KACvB,CACD,gBAAAg9B,GACI,GAAIh9B,KAAK0O,SAASirB,UACd,OAAO35B,KAAKgO,Md1FkC,oEc0FyBhO,KAAK0O,SAASirB,UAAU5gB,aAAvD/Y,KAAK0O,SAASirB,UAAUzf,SAEvE,CACD,eAAAqhB,GACIv7B,KAAK08B,OAAO1+B,KAAKgC,KAAK0O,UACtB1O,KAAK0O,SAAW,CACZ+tB,SAAU,GACV9C,UAAW,KACXvX,MAAO,KACP7F,aAAc,KAErB,CACD,gBAAA2a,GACI,OAAQl3B,KAAK0O,SAASirB,WAAW5gB,YAC7B/Y,KAAK0O,SAAS+tB,SAASv6B,IAAI,KAC1BlC,KAAK0O,SAAS6N,aAAe,IACxBvc,KAAK0O,SAAS0T,MAAQ,SAClBxkB,EACjB,CACD,YAAA09B,GAEI,OADAt7B,KAAK01B,QAAQpe,QACNtX,IACV,ECpIL,MAAMo9B,GAAwBp+B,OAAO2sB,OAAO,CACxCve,OAAQO,KAEL,MAAM0vB,WAAsBh7B,EAC/B,WAAAxC,CAAYqQ,GACR/N,MAAM,IAAIL,KACN,GAAoB,IAAhBA,EAAKzC,OAEL,OAAO6Q,EAAE0L,UAAU9Z,EAAK,IAE5B,GAAoB,IAAhBA,EAAKzC,QACc,iBAAZyC,EAAK,IACG,MAAfA,EAAK,GAAG,IACW,MAAnBA,EAAK,GAAGI,IAAI,GAAY,CAGxB,MAAMH,EAASo4B,GAAmBr4B,EAAK,GAAGE,MAAM,GAAI,IAGpD,OAAO,IAAImyB,GAAQpyB,EAFPD,EAAK,GAEeoO,EACnC,CAID,OAAOA,EAAE0L,UAAU9Z,EAAK,EACzB,CAAEV,KAAM8O,EAAGzN,OAAQ26B,IACzB,ECpBE,MAAME,WAAiBrP,GAC1BsP,WAAa,CAAA,EACb,WAAA19B,CAAYyI,EAAKgF,GACb,MAAMkhB,EAAU,CAAA,EAChB,IAAK,MAAM7uB,KAAK2I,EAAK,CACjB,MAAM2tB,EAAYuH,GAAc79B,GAChC6uB,EAAQyH,EAAUx3B,MACdw3B,EAAUl0B,OAAO1C,OAEb,IAAI80B,GAAQ8B,EAAUl0B,OAAQuG,EAAI3I,GAAI,IACpC2I,EAAI3I,EACjB,CACDwC,MAAMqsB,EAASlhB,EAClB,CACDmwB,KAAO,IAAIJ,GAAcr9B,MACzB09B,MCzB6B,CAACxtB,IAAM,KAAU,GAAE9O,KDyBtBpB,MAAlB29B,GACRC,SAAU,KAAQ,CACdH,KAAMz9B,KAAKy9B,QACXr8B,KAAKpB,MACT69B,QAAWv1B,GAAQA,GAAKlH,KAAKpB,MAC7B,YAAAiwB,CAAa3nB,GACT,OAAI3G,EAAQ2G,KAAS4C,GAAW5C,EAAK,WAC1BA,IACJA,CACV,CACD,SAAAsT,CAAUtT,GAEN,OAAOtI,KAAK4U,MAAMtM,EAAK,CACnB4H,EAAGlQ,KACH8B,KAAM,CAAE,IAGT6Q,UAAU3S,KAChB,CACD,KAAA4U,CAAMtM,EAAKpH,GACP,MAAmB,iBAARoH,EACHpH,EAAIY,MAAQ9C,OAAOyB,KAAKS,EAAIY,MAAMqgB,MAAMxiB,IAAM2I,EAAIjL,SAASsC,IAGpDK,KAAK89B,YAAYx1B,EAAKpH,IAE5BlB,KAAKu9B,WAAWj1B,KACjBtI,KAAKu9B,WAAWj1B,GAAOtI,KAAK89B,YAAYx1B,EAAKpH,IAC1ClB,KAAKu9B,WAAWj1B,IAEpBzF,EAAUyF,EAAK,UZnDH,EAACA,EAAKpH,KAC7B,MAAM68B,EAAa35B,EAAakE,GAChC,OAAQy1B,GACJ,UAAKngC,EACD,OAAIsN,GAAW5C,EAAK,QACTA,ELNW,EAACA,EAAKpH,KACpC,IAAIw2B,EACJ,MAAMnX,EAAY,CAAA,EAKZyd,EAAgBr9B,EAA2B2H,GAAKzH,IAAIm1B,IAC1D,GAA+B,QAA3BgI,EAAc,IAAIv8B,KAAgB,CAGlC,MAAMw8B,EAAcD,EAAc1mB,QAC5B4mB,EAAah9B,EAAIgP,EAAE0E,MAAMqpB,EAAYvgC,MAAOwD,GAClD,IAAKg9B,EAAW5tB,QAAQ,kBAAoB4tB,EAAW3d,UACnD,OAAO7hB,EAyF0B,CAAC4J,GAAQ,8DAA8DA,KAzFjF61B,CAA2D,iBAAtBF,EAAYvgC,MACpEugC,EAAYvgC,MACV0M,GAAU6zB,EAAYvgC,SAEhCg6B,EAASwG,EAAW3d,SACvB,CACD,IAAK,MAAMrhB,KAAS8+B,EAAe,CAC/B,GAAmB,QAAf9+B,EAAMuC,KACN,OAAO/C,EAwCkB,kEAvC7B,GAAmB,MAAfQ,EAAMuC,KAQV,GAAmB,UAAfvC,EAAMuC,KAAkB,CAExB,MAAMoF,EAAM3F,EAAIgP,EAAE0E,MAAM1V,EAAM2H,IAAK3F,GAC7BxD,EAAQwD,EAAIgP,EAAE0E,MAAM1V,EAAMxB,MAAOwD,GACjCk9B,EAAsB5T,GAAe3jB,EAAKnJ,EAAOwD,EAAIgP,GACvDkuB,EAAoBlY,WACpB3F,EAAU2F,SAAW1oB,EAAO+iB,EAAU2F,SAAUkY,EAAoBlY,WAEpEkY,EAAoBp3B,QACpBuZ,EAAUvZ,MAAQxJ,EAAO+iB,EAAUvZ,MAAOo3B,EAAoBp3B,OACrE,KACI,CACD,MAAMtJ,EAAQwD,EAAIgP,EAAE0E,MAAM1V,EAAMxB,MAAOwD,GACjC0P,EAAQ,CAAE/J,IAAK3H,EAAM2H,IAAKnJ,SAChC,GAAIwB,EAAMslB,UAAY1jB,EAAO,CACzB,MAAM+H,EAAMnL,EAAMwB,EAAMslB,SACpB3b,aAAe8E,IACfjP,EAAgB,oBAAoB0L,GAAUlL,EAAM2H,QAAQgC,KAChEnL,EAAMse,OAAO9c,EAAMslB,SACnB5T,EAAM4T,QAAUtlB,EAAMslB,OACzB,CACDjE,EAAUrhB,EAAMuC,MAAQjE,EAAO+iB,EAAUrhB,EAAMuC,MAAOmP,EACzD,KA7BuB,WAAhB1R,EAAMxB,OACU,WAAhBwB,EAAMxB,OACU,WAAhBwB,EAAMxB,OACNgB,EAkCiD,iEAAiE0L,GAlC5DlL,EAAMxB,WAChE6iB,EAAU/P,WAAatR,EAAMxB,KA0BpC,CACD,MAAM2gC,EAAgBn9B,EAAIgP,EAAE2B,KAAK,YAAa0O,GAC9C,OAAOrf,EAAIgP,EAAE+G,OAAO,CAChB8I,OAAQ,SACRQ,UAAWmX,GAAQvO,MAAMkV,IAAkBA,GAC7C,EKpDaC,CAAmBh2B,EAAKpH,GACnC,IAAK,QACD,MDTc,EAACoH,EAAKpH,IA2FE,EAACoH,EAAKpH,IA6DV,CAACoH,QAAkC1K,IAA1Bk6B,GAAcxvB,EAAI,IA5DvBi2B,CAAsBj2B,GAAOwvB,GAAcxvB,EAAI,IAAIA,EAAKpH,GAmB7D,CAACoH,QAAoC1K,IAA5Bi6B,GAAgBvvB,EAAI,IAlBhDk2B,CAAqBl2B,GAAOuvB,GAAgBvvB,EAAI,IAAIA,EAAKpH,QACrDtD,EA9F0B6gC,CAA0Bn2B,EAAKpH,IACtC,EAACoH,EAAKpH,KACnC,IAAIw9B,EAAY,CAAC,CAAA,GACbv/B,EAAI,EACR,KAAOA,EAAImJ,EAAIjJ,QAAQ,CACnB,IAAIq4B,GAAS,EACT5wB,GAAW,EACA,QAAXwB,EAAInJ,IAAgBA,EAAImJ,EAAIjJ,OAAS,IACrCq4B,GAAS,EACTv4B,KAEJ,MAAM5B,EAAU2D,EAAIgP,EAAE0E,MAAMtM,EAAInJ,GAAI+B,GAEpC,GADA/B,IACe,MAAXmJ,EAAInJ,GAAY,CAChB,GAAIu4B,EACA,OAAOh5B,EAsFc,uCArFzBoI,GAAW,EACX3H,GACH,CACD,GAAIu4B,EAAQ,CACR,IAAKn6B,EAAQ4e,QAAQ6V,GAAU50B,OAC3B,OAAOsB,EA4EgC,wCA5EWnB,EAAQ+J,eAI9Do3B,EAAYA,EAAUz/B,QAAQ8F,GAE9BxH,EAAQmR,SAAS7N,IAAIqb,GAAUub,GAAmBzsB,GAAkCjG,GAAOmX,IAC9F,MAEGwiB,EAAYA,EAAU79B,IAAIkE,GAAQsyB,GAActyB,EAAM+B,EAAW,WAAa,WAAYvJ,GAEjG,CACD,OAAO2D,EAAIgP,EAAEqH,IAAIN,OAAOynB,EAAU79B,IAAIyb,IAAa,CAC/CD,MAAOjf,MACPkf,cACA,EApCuEqiB,CAAkBr2B,EAAKpH,GCSnF09B,CAAWt2B,EAAKpH,GAC3B,IAAK,SACD,OAAOA,EAAIgP,EAAE2B,KAAK,eAAgB,CAC9BkO,OAAQ,SACRzE,MAAOhT,GACR,CAAEoP,YAAY,IACrB,IAAK,WAAY,CACb,MAAMmnB,EAAcl9B,EAAQ2G,GAAOA,IAAQA,EAC3C,OAAI4C,GAAW2zB,EAAa,QACjBA,EACJngC,EAAgBu5B,GAA8B,YACxD,CACD,QACI,OAAOv5B,EAAgBu5B,GAA8B8F,GAAc3zB,GAAU9B,KACpF,EY8BOw2B,CAAYx2B,EAAKpH,GACfxC,EAAgBu5B,GAA8Bl1B,EAASuF,IAChE,CACD,WAAAw1B,CAAYx1B,EAAKpH,GACb,OAAQlB,KAAK4vB,iBAAiBtnB,KACxBA,EAAIy2B,SAAS,OACX/+B,KAAK4vB,iBAAiBtnB,EAAItG,MAAM,GAAI,KAAK1E,SH5D1B,CAACyM,IAC5BA,EAAEwvB,eACF,MAAMn6B,EAAS03B,GAAoB/sB,GAAGyE,KACtC,OAAKpP,GAGL2K,EAAE2rB,QAAQd,0BACN7qB,EAAE2rB,QAAQpB,WAEV51B,EAAgBu7B,GAAgClwB,EAAE2rB,QAAQpB,YAEvDl1B,GAPIhB,EAAmB,qDAAqD2L,EAAE2rB,QAAQR,WAOhF,EGkDD8J,CAAgB,IAAIxC,GAAal0B,EAAKpH,IACjD,EAGE,MAAMs8B,GAAiB79B,IAC1B,MAAMs/B,EAAkBt/B,EAAEyO,QAAQ,KAClC,OAAyB,IAArB6wB,EACO,CACHxgC,KAAMkB,EACNoC,OAAQ,KAGC,MAAbpC,EAAEuC,IAAI,IACNxD,EAAgB,sEAEb,CACHD,KAAMkB,EAAEqC,MAAM,EAAGi9B,GACjBl9B,OAAQo4B,GAAmBx6B,EAAEqC,MAAMi9B,EAAkB,GAAI,KAC5D,EE9EQvQ,GFMS,EAACpmB,EAAKgF,EAAS,CAAA,IAAO,IAAIgwB,GAASh1B,EAAKgF,GENvC4xB,CAAMhL,IAC7BoJ,GAAS5O,QAAUA,GAAQnX,IACRmX,GAAQE,2BCQzB,SAAC3X,EAAQkoB,EAAgBC,GACzB,YADyBA,IAAAA,IAAAA,EAAkB,CAAA,GAC3C,SAAC5/B,EAAQ2M,EAAGzC,GACV,IAVsBtH,EAUhByG,EAAMoO,EAAOzX,GAEnB,OAAIqJ,aAAe8E,GACV,CACLnO,OAAQ,CAAE,EACV4N,OAAQiyB,EAAYA,cAfFj9B,EAeoByG,EAb5CzG,EAAE6S,QAAQ,SAAC7S,UAAMpD,OAAOe,OAAOqC,EAAG,CAAEq7B,KAAMr7B,EAAE+K,MAAO,GAE5C/K,EAAEwL,QAWyClE,KAIhDA,EAAQ41B,2BAA6BC,EAAsBA,uBAAC,CAAE,EAAE71B,GAEzD,CACL0D,OAAQ,CAAiB,EACzB5N,OAAQ4/B,EAAgB7nB,IAAM/X,EAASqJ,GAE3C,CAAC"}