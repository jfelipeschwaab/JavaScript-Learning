var e=require("@hookform/resolvers");const t=Array,r=(e,t)=>e.includes(t),i=(e,t,r)=>void 0===t?e??[]:void 0===e?void 0===t?[]:Array.isArray(t)?t:[t]:(r?.prepend?Array.isArray(t)?e.unshift(...t):e.unshift(t):Array.isArray(t)?e.push(...t):e.push(t),e),n=(e,t)=>void 0===e?[t]:(e.includes(t)||e.push(t),e);class s extends Error{}const o=e=>a(e,s),a=(e,t=Error)=>{throw new t(e)};class l extends Error{name="ParseError"}const c=e=>a(e,l);function u(e,t){const r=Array.isArray(e),i=Object.entries(e).flatMap((e,i)=>{const n=r?t(i,e[1]):t(...e,i);return Array.isArray(n[0])||0===n.length?n:[n]}),n=Object.fromEntries(i);return"number"==typeof i[0]?.[0]?Object.values(n):n}const h=e=>Object.entries(e),d=e=>Object.fromEntries(e),p=(e,t)=>e in t,f=class{constructor(e){Object.assign(this,e)}};class m extends f{}const g=class{};class y extends g{}const b=(e,t)=>{const r={},i={};let n;for(n in e)n in t?r[n]=e[n]:i[n]=e[n];return[r,i]},v=(e,t)=>b(e,t)[1],$=e=>0===Object.keys(e).length,x=e=>[...Object.entries(e),...Object.getOwnPropertySymbols(e).map(t=>[t,e[t]])],k=Symbol("represents an uninitialized value"),w=(e,t)=>{t.addInitializer(function(){this[t.name]=this[t.name].bind(this)})},A=(e,t)=>function(){const r=e.call(this);return Object.defineProperty(this,t.name,"getter"===t.kind?{value:r}:{value:()=>r,enumerable:!1}),r},O=e=>"function"==typeof e&&0===e.length,j=class extends Function{constructor(...e){const t=e.slice(0,-1),r=e.at(-1);try{super(...t,r)}catch(t){return o(`Encountered an unexpected error while compiling your definition:\n                Message: ${t} \n                Source: (${e.slice(0,-1)}) => {\n                    ${e.at(-1)}\n                }`)}}};class q extends g{constructor(e,t){return super(),Object.assign(Object.setPrototypeOf(e.bind(t?.bind??this),this.constructor.prototype),t?.attach)}}const E=(e=>{let t=k;return()=>t===k?t=(()=>{try{return new Function("return false")()}catch(e){return!0}})():t})(),K=(e,t)=>S(e)===t,S=e=>{const t=typeof e;return"object"===t?null===e?"null":"object":"function"===t?"object":t},R={bigint:"a bigint",number:"a number",object:"an object",string:"a string",symbol:"a symbol",boolean:"boolean",null:"null",undefined:"undefined"},z={Array:Array,Date:Date,Error:Error,Function:Function,Map:Map,RegExp:RegExp,Set:Set,String:String,Number:Number,Boolean:Boolean,WeakMap:WeakMap,WeakSet:WeakSet,Promise:Promise},L=e=>{let t=Object.getPrototypeOf(e);for(;t?.constructor&&(!p(t.constructor.name,z)||!(e instanceof z[t.constructor.name]));)t=Object.getPrototypeOf(t);const r=t?.constructor?.name;if(void 0!==r&&"Object"!==r)return r},C=e=>"object"==typeof e&&null!==e?L(e)??"object":S(e),I=e=>Array.isArray(e),B={Array:"an array",Function:"a function",Date:"a Date",RegExp:"a RegExp",Error:"an Error",Map:"a Map",Set:"a Set",String:"a String object",Number:"a Number object",Boolean:"a Boolean object",Promise:"a Promise",WeakMap:"a WeakMap",WeakSet:"a WeakSet"},N=e=>{const t=Object(e).name??null;return t&&p(t,z)&&z[t]===e?t:null},M=e=>{const t=[];let r=e;for(;r!==Object.prototype&&null!=r;){for(const e of Object.getOwnPropertyNames(r))"constructor"===e||t.includes(e)||t.push(e);for(const e of Object.getOwnPropertySymbols(r))t.includes(e)||t.push(e);r=Object.getPrototypeOf(r)}return t},P={bigint:M(0n),boolean:M(!1),null:[],number:M(0),object:[],string:M(""),symbol:M(Symbol()),undefined:[]},F=(e,t)=>{let r=e.prototype;for(;null!==r;){if(r===t.prototype)return!0;r=Object.getPrototypeOf(r)}return!1},T=e=>"string"==typeof e?JSON.stringify(e):"bigint"==typeof e?`${e}n`:`${e}`,U={};globalThis.$ark=U;const D=new WeakMap,_={},V=e=>{const t=D.get(e);if(t)return t;let r=H(e);return _[r]?r=`${r}${_[r]++}`:_[r]=1,U[r]=e,D.set(e,r),r},J=e=>`$ark.${V(e)}`,W=e=>/^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(e),Z=e=>K(e,"object")||"symbol"==typeof e?J(e):T(e),H=e=>{switch(typeof e){case"object":{if(null===e)break;const t=L(e)??"object";return t[0].toLowerCase()+t.slice(1)}case"function":return W(e.name)?e.name:"fn";case"symbol":return e.description&&W(e.description)?e.description:"symbol"}return o(`Unexpected attempt to register serializable value of type ${S(e)}`)};class G extends y{argNames;body="";constructor(...e){super(),this.argNames=e;for(const t of e){if(t in this)throw new Error(`Arg name '${t}' would overwrite an existing property on FunctionBody`);this[t]=t}}indentation=0;indent(){return this.indentation+=4,this}dedent(){return this.indentation-=4,this}prop(e,t=!1){return X(e,t)}index(e,t=!1){return Y(`${e}`,t)}line(e){return this.body+=`${" ".repeat(this.indentation)}${e}\n`,this}const(e,t){return this.line(`const ${e} = ${t}`),this}let(e,t){return this.line(`let ${e} = ${t}`)}set(e,t){return this.line(`${e} = ${t}`)}if(e,t){return this.block(`if (${e})`,t)}elseIf(e,t){return this.block(`else if (${e})`,t)}else(e){return this.block("else",e)}for(e,t,r=0){return this.block(`for (let i = ${r}; ${e}; i++)`,t)}forIn(e,t){return this.block(`for (const k in ${e})`,t)}block(e,t,r=""){return this.line(`${e} {`),this.indent(),t(this),this.dedent(),this.line(`}${r}`)}return(e=""){return this.line(`return ${e}`)}compile(){return new j(...this.argNames,this.body)}}const X=(e,t=!1)=>"string"==typeof e&&W(e)?`${t?"?":""}.${e}`:Y(Q(e),t),Q=e=>"symbol"==typeof e?J(e):JSON.stringify(e),Y=(e,t=!1)=>`${t?"?.":""}[${e}]`;var ee;!function(e){e.Kind=class{},e.Instantiable=class{},e.reify=e=>e.hkt,e.UnaryKind=class{},e.pipe=(...e)=>t=>e.reduce((e,t)=>t.hkt(e),t)}(ee||(ee={}));const te=/^(?!^-0$)-?(?:0|[1-9]\d*)(?:\.\d*[1-9])?$/,re=te.test.bind(te),ie=/^-?\d*\.?\d*$/,ne=/^(?:0|(?:-?[1-9]\d*))$/,se=ne.test.bind(ne),oe=/^-?\d+$/,ae=oe.test.bind(oe),le={number:"a number",bigint:"a bigint",integer:"an integer"},ce=(e,t)=>`'${e}' was parsed as ${le[t]} but could not be narrowed to a literal value. Avoid unnecessary leading or trailing zeros and other abnormal notation`,ue=(e,t)=>he(e,"number",t),he=(e,t,r)=>{const i=((e,t)=>"number"===t?Number(e):Number.parseInt(e))(e,t);return!Number.isNaN(i)&&((e,t)=>{return"number"===t?0!==(r=e).length&&ie.test(r):ae(e);var r})(e,t)?r?.strict?((e,t)=>"number"===t?re(e):se(e))(e,t)?i:c(ce(e,t)):i:r?.errorOnFail?c(!0===r?.errorOnFail?`Failed to parse ${le[t]} from '${e}'`:r?.errorOnFail):void 0},de=(e,t)=>{switch(S(e)){case"object":return e instanceof Date?e.toDateString():JSON.stringify(fe(e,pe,[]),null,t);case"symbol":return pe.onSymbol(e);default:return T(e)}},pe={onCycle:()=>"(cycle)",onSymbol:e=>`Symbol(${V(e)})`,onFunction:e=>`Function(${V(e)})`},fe=(e,t,r)=>{switch(S(e)){case"object":{if("function"==typeof e)return pe.onFunction(e);if(r.includes(e))return"(cycle)";const i=[...r,e];if(Array.isArray(e))return e.map(e=>fe(e,t,i));if(e instanceof Date)return e.toDateString();const n={};for(const r in e)n[r]=fe(e[r],t,i);return n}case"symbol":return pe.onSymbol(e);case"bigint":return`${e}n`;case"undefined":return t.onUndefined??"undefined";default:return e}},me=e=>u(e,(e,t)=>[e,I(t)?[...t]:t]),ge=Symbol("ArkTypeInternalKind"),ye=(e,t)=>e?.[ge]===t,be=e=>ye(e,"root")||ye(e,"constraint"),ve=["unit","proto","domain"],$e=["required","optional","index","sequence"],xe=["regex","divisor","exactLength","max","min","maxLength","minLength","before","after"],ke=[...xe,...$e,"structure","predicate"],we=["alias","union","morph","unit","intersection","proto","domain"],Ae=[...we,...ke],Oe=u(ke,(e,t)=>[t,1]),je=u([...$e,"undeclared"],(e,t)=>[t,1]),qe=u(Ae,(e,t)=>[t,e]),Ee=e=>"string"==typeof e&&e in qe,Ke=e=>qe[e],Se=e=>we.slice(Ke(e)+1),Re=e=>"string"==typeof e||"boolean"==typeof e||"number"==typeof e||null===e?e:Z(e),ze=e=>{let t="{ ";for(const[r,i]of Object.entries(e))t+=`${r}: ${Z(i)}, `;return t+" }"},Le=e=>{const t=e;return t.hasAssociatedError&&(t.defaults.expected??=e=>"description"in e?e.description:t.defaults.description(e),t.defaults.actual??=e=>de(e),t.defaults.problem??=e=>`must be ${e.expected}${e.actual?` (was ${e.actual})`:""}`,t.defaults.message??=e=>{if(0===e.path.length)return e.problem;const t=`${e.propString} ${e.problem}`;return"["===t[0]?`value at ${t}`:t}),t},Ce={};class Ie extends y{input;[ge]="error";path;data;nodeConfig;constructor(e,t){super(),this.input=e,Object.defineProperties(this,Object.getOwnPropertyDescriptors(e));const r=t.data;"union"===e.code&&(e.errors=e.errors.flatMap(e=>e.hasCode("union")?e.errors:e)),this.nodeConfig=t.config[this.code],this.path=e.path??[...t.path],e.relativePath&&this.path.push(...e.relativePath),this.data="data"in e?e.data:r}hasCode(e){return this.code===e}get propString(){return(e=>{const t=this.path.reduce((e,t)=>"string"==typeof t&&W(t)?`${e}.${t}`:`${e}[${de(t)}]`,"");return"."===t[0]?t.slice(1):t})()}get expected(){return this.input.expected??this.nodeConfig.expected?.(this.input)}get actual(){return void 0!==this.input.actual?this.input.actual:this.nodeConfig.actual?.(this.data)}get problem(){return this.input.problem??this.nodeConfig.problem(this)}get message(){return this.input.message??this.nodeConfig.message(this)}toString(){return this.message}throw(){throw this}}class Be extends t{ctx;constructor(e){super(),this.ctx=e}byPath={};count=0;mutable=this;add(e){const t=this.byPath[e.propString];if(t){const r=new Ie({code:"intersection",errors:t.hasCode("intersection")?[...t.errors,e]:[t,e]},this.ctx),i=this.indexOf(t);this.mutable[-1===i?this.length:i]=r,this.byPath[e.propString]=r}else this.byPath[e.propString]=e,this.mutable.push(e);this.count++}get summary(){return this.toString()}get message(){return this.toString()}toString(){return this.join("\n")}throw(){throw this}}class Ne{root;config;path=[];queuedMorphs=[];errors=new Be(this);branches=[];seen={};constructor(e,t){this.root=e,this.config=t}get currentBranch(){return this.branches.at(-1)}queueMorphs(e){const t={path:[...this.path],morphs:e};this.currentBranch?.queuedMorphs.push(t)??this.queuedMorphs.push(t)}finalize(){if(this.hasError())return this.errors;let e=this.root;if(this.queuedMorphs.length)for(let t=0;t<this.queuedMorphs.length;t++){const{path:r,morphs:i}=this.queuedMorphs[t],n=r.at(-1);let s;if(void 0!==n){s=e;for(let e=0;e<r.length-1;e++)s=s[r[e]]}this.path=r;for(const t of i){const r=t(void 0===s?e:s[n],this);if(r instanceof Be)return r;if(this.hasError())return this.errors;if(r instanceof Ie)return this.error(r),this.errors;void 0===s?e=r:s[n]=r}}return e}get currentErrorCount(){return this.currentBranch?this.currentBranch.error?1:0:this.errors.count}hasError(){return 0!==this.currentErrorCount}get failFast(){return 0!==this.branches.length}error(e){const t="object"==typeof e?e.code?e:{...e,code:"predicate"}:{code:"predicate",expected:e},r=new Ie(t,this);return this.currentBranch?this.currentBranch.error=r:this.errors.add(r),r}get data(){let e=this.root;for(const t of this.path)e=e?.[t];return e}invalid(e){return this.error(e),!1}pushBranch(){this.branches.push({error:void 0,queuedMorphs:[]})}popBranch(){return this.branches.pop()}}class Me extends q{attachments;constructor(e){super((e,t)=>{if(!this.includesMorph&&!this.allowsRequiresContext&&this.allows(e))return e;if(t)return this.traverseApply(e,t);const r=new Ne(e,this.$.resolvedConfig);return this.traverseApply(e,r),r.finalize()},{attach:e}),this.attachments=e}qualifiedId=`${this.$.id}${this.id}`;includesMorph="morph"===this.kind||this.hasKind("optional")&&this.hasDefault()||this.hasKind("structure")&&"delete"===this.undeclared||this.children.some(e=>e.includesMorph);allowsRequiresContext=this.hasKind("predicate")&&1!==this.inner.predicate.length||"alias"===this.kind||this.children.some(e=>e.allowsRequiresContext);referencesById=this.children.reduce((e,t)=>Object.assign(e,t.referencesById),{[this.id]:this});get references(){return Object.values(this.referencesById)}precedence=Ke(this.kind);jit=!1;allows=e=>this.allowsRequiresContext?this.traverseAllows(e,new Ne(e,this.$.resolvedConfig)):this.traverseAllows(e);traverse(e){return this(e)}_in;get in(){return this._in??=this.getIo("in"),this._in}_out;get out(){return this._out??=this.getIo("out"),this._out}_description;get description(){return this._description??=this.inner.description??this.$.resolvedConfig[this.kind].description?.(this),this._description}getIo(e){if(!this.includesMorph)return this;const t={};for(const[r,i]of this.entries){const n=this.impl.keys[r];if(!n.meta)if(n.child){const n=i;t[r]=I(n)?n.map(t=>t[e]):n[e]}else t[r]=i}return this.$.node(this.kind,t)}toJSON(){return this.json}toString(){return this.expression}equals(e){return this.typeHash===e.typeHash}hasKind(e){return this.kind===e}isBasis(){return r(ve,this.kind)}isConstraint(){return r(ke,this.kind)}isRefinement(){return r(xe,this.kind)}isRoot(){return r(we,this.kind)}hasUnit(e){return this.hasKind("unit")&&this.allows(e)}hasOpenIntersection(){return this.impl.intersectionIsOpen}get nestableExpression(){return this.expression}bindScope(e){return this.$===e?this:new this.constructor(Object.assign((t=this.attachments,Object.create(Object.getPrototypeOf(t),Object.getOwnPropertyDescriptors(t))),{$:e}));var t}firstReference(e){return this.references.find(t=>t!==this&&e(t))}firstReferenceOrThrow(e){return this.firstReference(e)??a(`${this.id} had no references matching predicate ${e}`)}firstReferenceOfKind(e){return this.firstReference(t=>t.kind===e)}firstReferenceOfKindOrThrow(e){return this.firstReference(t=>t.kind===e)??a(`${this.id} had no ${e} references`)}transform(e,t){return this._transform(e,{seen:{},path:[],shouldTransform:t?.shouldTransform??(()=>!0)})}_transform(e,t){if(t.seen[this.id])return this.$.lazilyResolve(t.seen[this.id]);if(!t.shouldTransform(this,t))return this;let r;t.seen[this.id]=()=>r;const i=u(this.inner,(r,i)=>{if(!this.impl.keys[r].child)return[r,i];const n=i;if(!I(n)){const i=n._transform(e,t);return i?[r,i]:[]}const s=n.flatMap(r=>r._transform(e,t)??[]);return s.length?[r,s]:[]});delete t.seen[this.id];const n=e(this.kind,i,t);return null===n||$(n)?null:"required"!==this.kind&&"optional"!==this.kind&&"index"!==this.kind||"value"in n?("morph"===this.kind&&(n.in??=this.$.keywords.unknown),r=this.$.node(this.kind,n)):null}configureShallowDescendants(e){const t="string"==typeof e?{description:e}:e;return this.transform((e,r)=>({...r,...t}),{shouldTransform:e=>"structure"!==e.kind})}}class Pe{sources;constructor(e){this.sources=e}clone(){return new Pe(this.sources)}static from(e,t,r){return new Pe({"[]":{[e]:{l:t,r:r}}})}static fromEntries(e){return e.length?new Pe({"[]":d(e)}):o("Unexpected attempt to create a disjoint from no entries")}get flat(){return h(this.sources).flatMap(([e,t])=>h(t).map(([t,r])=>({path:e,kind:t,disjoint:r})))}describeReasons(){const e=this.flat;if(1===e.length){const{path:t,disjoint:r}=e[0],i=JSON.parse(t).join(".");return`Intersection${i&&` at ${i}`} of ${Fe(r)} results in an unsatisfiable type`}return`The following intersections result in unsatisfiable types:\n• ${e.map(({path:e,disjoint:t})=>`${e}: ${Fe(t)}`).join("\n• ")}`}isEmpty(){return 0===this.flat.length}throw(){return c(this.describeReasons())}invert(){const e=h(this.sources).map(([e,t])=>[e,u(t,(e,t)=>[e,{l:t.r,r:t.l}])]);return new Pe(d(e))}add(e){h(e.sources).forEach(([e,t])=>Object.assign(this.sources[e]??{},t))}withPrefixKey(e){const t=h(this.sources).map(([t,r])=>{const i=JSON.parse(t);return i.unshift("symbol"==typeof e?V(e):e),[JSON.stringify(i),r]});return new Pe(d(t))}toString(){return de(this.sources)}}const Fe=e=>`${Te(e.l)} and ${Te(e.r)}`,Te=e=>ye(e,"root")?e.expression:I(e)?e.map(Te).join(" | "):String(e),Ue={},De=(e,t,r)=>_e(e,t,{$:r,invert:!1,pipe:!1}),_e=(e,t,r)=>{const i=r.pipe?"|>":"&",n=`${e.typeHash}${i}${t.typeHash}`;if(void 0!==Ue[n])return Ue[n];if(!r.pipe){const r=`${t.typeHash}${i}${e.typeHash}`;if(void 0!==Ue[r]){const e=Ue[r],t=e instanceof Pe?e.invert():e;return Ue[n]=t,t}}if(e.equals(t))return e;let s;if(r.pipe&&e.hasKind("morph"))s=r.invert?Je(t,e,r):Ve(e,t,r);else if(r.pipe&&t.hasKind("morph"))s=r.invert?Ve(t,e,r):Je(e,t,r);else{const i=e.impl.intersections[t.kind]??t.impl.intersections[e.kind];s=void 0===i?null:(e.precedence<t.precedence?e.kind:t.kind)===e.kind?i(e,t,r):i(t,e,{...r,invert:!r.invert})}return be(s)&&(e.equals(s)?s=e:t.equals(s)&&(s=t)),Ue[n]=s,s},Ve=(e,t,r)=>{const i=[...e.morphs];if(e.validatedOut){const n=_e(e.validatedOut,t,r);if(n instanceof Pe)return n;i[i.length-1]=n}else i.push(t);return r.$.node("morph",{morphs:i,in:e.in})},Je=(e,t,r)=>{const i=_e(e,t.in,r);return i instanceof Pe?i:r.$.node("morph",{morphs:t.morphs,in:i})};class We extends Me{[ge]="constraint";impliedSiblings;intersect(e){return De(this,e,this.$)}}class Ze extends We{traverseApply=(e,t)=>{this.traverseAllows(e,t)||t.error(this.errorContext)};compile(e){"Allows"===e.traversalKind?e.return(this.compiledCondition):e.if(this.compiledNegation,()=>e.line(`${e.ctx}.error(${this.compiledErrorContext})`))}get errorContext(){return{code:this.kind,description:this.description,...this.inner}}get compiledErrorContext(){return ze(this.errorContext)}}const He=e=>(t,r)=>{if(I(t)){if(0===t.length)return;return t.map(t=>r.$.node(e,t)).sort((e,t)=>e.innerHash<t.innerHash?-1:1)}const i=r.$.node(e,t);return i.hasOpenIntersection()?[i]:i},Ge=e=>{const t=e.r.shift();if(!t){let t=0===e.l.length&&"structure"===e.kind?e.ctx.$.keywords.unknown.raw:e.ctx.$.node(e.kind,Object.assign(e.baseInner,Qe(e.l)),{prereduced:!0});for(const r of e.roots){if(t instanceof Pe)return t;t=_e(r,t,e.ctx)}return t}let r=!1;for(let i=0;i<e.l.length;i++){const n=_e(e.l[i],t,e.ctx);if(null!==n){if(n instanceof Pe)return n;if(r){if(!e.l.includes(n))return o(`Unexpectedly encountered multiple distinct intersection results for refinement ${n}`)}else{if(n.isRoot())return e.roots.push(n),e.l.splice(i),Ge(e);e.l[i]=n,r=!0}}}return r||e.l.push(t),"intersection"===e.kind&&t.impliedSiblings?.forEach(t=>n(e.r,t)),Ge(e)},Xe=e=>Object.entries(e).flatMap(([e,t])=>e in Oe?t:[]).sort((e,t)=>e.precedence<t.precedence?-1:e.precedence>t.precedence?1:e.innerHash<t.innerHash?-1:1),Qe=e=>{const t={};for(const r of e)if(r.hasOpenIntersection())t[r.kind]=i(t[r.kind],r);else{if(t[r.kind])return o(`Unexpected intersection of closed refinements of kind ${r.kind}`);t[r.kind]=r}return t},Ye=Le({kind:"predicate",hasAssociatedError:!0,collapsibleKey:"predicate",keys:{predicate:{}},normalize:e=>"function"==typeof e?{predicate:e}:e,defaults:{description:e=>`valid according to ${e.predicate.name||"an anonymous predicate"}`},intersectionIsOpen:!0,intersections:{predicate:()=>null}}),et=Le({kind:"divisor",collapsibleKey:"rule",keys:{rule:{}},normalize:e=>"number"==typeof e?{rule:e}:e,hasAssociatedError:!0,defaults:{description:e=>1===e.rule?"an integer":`a multiple of ${e.rule}`},intersections:{divisor:(e,t,r)=>r.$.node("divisor",{rule:Math.abs(e.rule*t.rule/tt(e.rule,t.rule))})}}),tt=(e,t)=>{let r,i=e,n=t;for(;0!==n;)r=n,n=i%n,i=r;return i};class rt extends Ze{boundOperandKind=at[this.kind];compiledActual="value"===this.boundOperandKind?"data":"length"===this.boundOperandKind?"data.length":"data.valueOf()";comparator=lt(this.kind,this.exclusive);numericLimit=this.rule.valueOf();expression=`${this.comparator}${this.rule}`;compiledCondition=`${this.compiledActual} ${this.comparator} ${this.numericLimit}`;compiledNegation=`${this.compiledActual} ${it[this.comparator]} ${this.numericLimit}`;stringLimit="date"===this.boundOperandKind?ct(this.numericLimit):`${this.numericLimit}`;limitKind="<"===this.comparator[0]?"upper":"lower";isStricterThan(e){return("upper"===this.limitKind?this.numericLimit<e.numericLimit:this.numericLimit>e.numericLimit)||this.numericLimit===e.numericLimit&&!0===this.exclusive&&!e.exclusive}overlapsRange(e){return!this.isStricterThan(e)&&(this.numericLimit!==e.numericLimit||!this.exclusive&&!e.exclusive)}overlapIsUnit(e){return this.numericLimit===e.numericLimit&&!this.exclusive&&!e.exclusive}}const it={"<":">=","<=":">",">":"<=",">=":"<"},nt={min:"max",minLength:"maxLength",after:"before"},st={parse:e=>e||void 0},ot=e=>"string"==typeof e||"number"==typeof e?new Date(e):e,at={min:"value",max:"value",minLength:"length",maxLength:"length",after:"date",before:"date"},lt=(e,t)=>`${p(e,nt)?">":"<"}${t?"":"="}`,ct=e=>"string"==typeof e?e:new Date(e).toLocaleString(),ut=Le({kind:"after",collapsibleKey:"rule",hasAssociatedError:!0,keys:{rule:{parse:ot,serialize:e=>e.toISOString()},exclusive:st},normalize:e=>"number"==typeof e||"string"==typeof e||e instanceof Date?{rule:e}:e,defaults:{description:e=>e.exclusive?`after ${e.stringLimit}`:`${e.stringLimit} or later`,actual:e=>e.toLocaleString()},intersections:{after:(e,t)=>e.isStricterThan(t)?e:t}}),ht=Le({kind:"before",collapsibleKey:"rule",hasAssociatedError:!0,keys:{rule:{parse:ot,serialize:e=>e.toISOString()},exclusive:st},normalize:e=>"number"==typeof e||"string"==typeof e||e instanceof Date?{rule:e}:e,defaults:{description:e=>e.exclusive?`before ${e.stringLimit}`:`${e.stringLimit} or earlier`,actual:e=>e.toLocaleString()},intersections:{before:(e,t)=>e.isStricterThan(t)?e:t,after:(e,t,r)=>e.overlapsRange(t)?e.overlapIsUnit(t)?r.$.node("unit",{unit:e.rule}):null:Pe.from("range",e,t)}}),dt=Le({kind:"exactLength",collapsibleKey:"rule",keys:{rule:{}},normalize:e=>"number"==typeof e?{rule:e}:e,hasAssociatedError:!0,defaults:{description:e=>`exactly length ${e.rule}`},intersections:{exactLength:(e,t,r)=>new Pe({'["length"]':{unit:{l:r.$.node("unit",{unit:e.rule}),r:r.$.node("unit",{unit:t.rule})}}}),minLength:(e,t)=>(t.exclusive?e.rule>t.rule:e.rule>=t.rule)?e:Pe.from("range",e,t),maxLength:(e,t)=>(t.exclusive?e.rule<t.rule:e.rule<=t.rule)?e:Pe.from("range",e,t)}}),pt=Le({kind:"max",collapsibleKey:"rule",hasAssociatedError:!0,keys:{rule:{},exclusive:st},normalize:e=>"number"==typeof e?{rule:e}:e,defaults:{description:e=>`${e.exclusive?"less than":"at most"} ${e.rule}`},intersections:{max:(e,t)=>e.isStricterThan(t)?e:t,min:(e,t,r)=>e.overlapsRange(t)?e.overlapIsUnit(t)?r.$.node("unit",{unit:e.rule}):null:Pe.from("range",e,t)}}),ft=Le({kind:"maxLength",collapsibleKey:"rule",hasAssociatedError:!0,keys:{rule:{},exclusive:st},normalize:e=>"number"==typeof e?{rule:e}:e,defaults:{description:e=>e.exclusive?`less than length ${e.rule}`:`at most length ${e.rule}`,actual:e=>`${e.length}`},intersections:{maxLength:(e,t)=>e.isStricterThan(t)?e:t,minLength:(e,t,r)=>e.overlapsRange(t)?e.overlapIsUnit(t)?r.$.node("exactLength",{rule:e.rule}):null:Pe.from("range",e,t)}}),mt={min:Le({kind:"min",collapsibleKey:"rule",hasAssociatedError:!0,keys:{rule:{},exclusive:st},normalize:e=>"number"==typeof e?{rule:e}:e,defaults:{description:e=>`${e.exclusive?"more than":"at least"} ${e.rule}`},intersections:{min:(e,t)=>e.isStricterThan(t)?e:t}}),max:pt,minLength:Le({kind:"minLength",collapsibleKey:"rule",hasAssociatedError:!0,keys:{rule:{},exclusive:st},normalize:e=>"number"==typeof e?{rule:e}:e,defaults:{description:e=>e.exclusive?0===e.rule?"non-empty":`more than length ${e.rule}`:1===e.rule?"non-empty":`at least length ${e.rule}`,actual:e=>`${e.length}`},intersections:{minLength:(e,t)=>e.isStricterThan(t)?e:t}}),maxLength:ft,exactLength:dt,after:ut,before:ht},gt={min:class extends rt{impliedBasis=this.$.keywords.number.raw;traverseAllows=this.exclusive?e=>e>this.rule:e=>e>=this.rule},max:class extends rt{impliedBasis=this.$.keywords.number.raw;traverseAllows=this.exclusive?e=>e<this.rule:e=>e<=this.rule},minLength:class extends rt{impliedBasis=this.$.keywords.lengthBoundable.raw;traverseAllows=this.exclusive?e=>e.length>this.rule:e=>e.length>=this.rule},maxLength:class extends rt{impliedBasis=this.$.keywords.lengthBoundable.raw;traverseAllows=this.exclusive?e=>e.length<this.rule:e=>e.length<=this.rule},exactLength:class extends Ze{traverseAllows=e=>e.length===this.rule;compiledCondition=`data.length === ${this.rule}`;compiledNegation=`data.length !== ${this.rule}`;impliedBasis=this.$.keywords.lengthBoundable.raw;expression=`{ length: ${this.rule} }`},after:class extends rt{impliedBasis=this.$.keywords.Date.raw;traverseAllows=this.exclusive?e=>e>this.rule:e=>e>=this.rule},before:class extends rt{traverseAllows=this.exclusive?e=>e<this.rule:e=>e<=this.rule;impliedBasis=this.$.keywords.Date.raw}},yt=Le({kind:"regex",collapsibleKey:"rule",keys:{rule:{},flags:{}},normalize:e=>"string"==typeof e?{rule:e}:e instanceof RegExp?e.flags?{rule:e.source,flags:e.flags}:{rule:e.source}:e,hasAssociatedError:!0,intersectionIsOpen:!0,defaults:{description:e=>`matched by ${e.rule}`},intersections:{regex:()=>null}});class bt extends Me{branches=this.hasKind("union")?this.inner.branches:[this];[ge]="root";get raw(){return this}_keyof;keyof(){return this._keyof||(this._keyof=this.rawKeyOf(),0===this._keyof.branches.length&&c(`keyof ${this.expression} results in an unsatisfiable type`)),this._keyof}intersect(e){const t=this.$.parseRoot(e);return De(this,t,this.$)}and(e){const t=this.intersect(e);return t instanceof Pe?t.throw():t}or(e){const t=this.$.parseRoot(e),r=[...this.branches,...t.branches];return this.$.schema(r)}assert(e){const t=this.traverse(e);return t instanceof Be?t.throw():t}extract(e){const t=this.$.parseRoot(e);return this.$.schema(this.branches.filter(e=>e.extends(t)))}exclude(e){const t=this.$.parseRoot(e);return this.$.schema(this.branches.filter(e=>!e.extends(t)))}array(){return this.$.schema({proto:Array,sequence:this},{prereduced:!0})}extends(e){const t=this.intersect(e);return!(t instanceof Pe)&&this.equals(t)}subsumes(e){return e.extends(this)}configure(e){return this.configureShallowDescendants(e)}describe(e){return this.configure(e)}create(e){return this.assert(e)}pipe(...e){return e.reduce((e,t)=>e.pipeOnce(t),this)}pipeOnce(e){if(ye(e,"root"))return _e(this,e,{$:this.$,invert:!1,pipe:!0});if(this.hasKind("union")){const t=this.branches.map(t=>t.pipe(e));return this.$.node("union",{...this.inner,branches:t})}return this.hasKind("morph")?this.$.node("morph",{...this.inner,morphs:[...this.morphs,e]}):this.$.node("morph",{in:this,morphs:[e]})}narrow(e){return this.constrain("predicate",e)}constrain(e,t){const r=this.$.node(e,t);return r.impliedBasis&&!this.extends(r.impliedBasis)?((...e)=>c(((e,t,r)=>{return`${i=e,i[0].toUpperCase()+i.slice(1)} operand must be ${t.description} (was ${r.exclude(t).description})`;var i})(...e)))(e,r.impliedBasis,this):this.and(this.$.node("intersection",{[e]:r}))}onUndeclaredKey(e){return this.transform((t,r)=>"structure"===t?"ignore"===e?v(r,{undeclared:1}):{...r,undeclared:e}:r,{shouldTransform:e=>!r($e,e.kind)})}}const vt=(e,t)=>u(Se(e),(e,r)=>[r,t]);let $t=(()=>{let e,t=bt,r=[];return class extends t{static{const i="function"==typeof Symbol&&Symbol.metadata?Object.create(t[Symbol.metadata]??null):void 0;e=[A],function(e,t,r,i,n,s){function o(e){if(void 0!==e&&"function"!=typeof e)throw new TypeError("Function expected");return e}for(var a,l=i.kind,c="getter"===l?"get":"setter"===l?"set":"value",u=e?i.static?e:e.prototype:null,h=u?Object.getOwnPropertyDescriptor(u,i.name):{},d=!1,p=r.length-1;p>=0;p--){var f={};for(var m in i)f[m]="access"===m?{}:i[m];for(var m in i.access)f.access[m]=i.access[m];f.addInitializer=function(e){if(d)throw new TypeError("Cannot add initializers after decoration has completed");s.push(o(e||null))};var g=(0,r[p])("accessor"===l?{get:h.get,set:h.set}:h[c],f);if("accessor"===l){if(void 0===g)continue;if(null===g||"object"!=typeof g)throw new TypeError("Object expected");(a=o(g.get))&&(h.get=a),(a=o(g.set))&&(h.set=a),(a=o(g.init))&&null.unshift(a)}else(a=o(g))&&("field"===l?null.unshift(a):h[c]=a)}u&&Object.defineProperty(u,i.name,h),d=!0}(this,0,e,{kind:"getter",name:"resolution",static:!1,private:!1,access:{has:e=>"resolution"in e,get:e=>e.resolution},metadata:i},0,r),i&&Object.defineProperty(this,Symbol.metadata,{enumerable:!0,configurable:!0,writable:!0,value:i})}expression=(function(e,t,r){for(var i=arguments.length>2,n=0;n<t.length;n++)r=i?t[n].call(e,r):t[n].call(e)}(this,r),this.alias);get resolution(){return this.resolve?.()??this.$.resolveRoot(this.alias)}rawKeyOf(){return this.resolution.keyof()}traverseAllows=(e,t)=>{const r=t.seen[this.id];return!!r?.includes(e)||(t.seen[this.id]=i(r,e),this.resolution.traverseAllows(e,t))};traverseApply=(e,t)=>{const r=t.seen[this.id];r?.includes(e)||(t.seen[this.id]=i(r,e),this.resolution.traverseApply(e,t))};compile(e){e.if(`ctx.seen.${this.id}?.includes(data)`,()=>e.return(!0)),e.line(`ctx.seen.${this.id} ??= []`).line(`ctx.seen.${this.id}.push(data)`),e.return(e.invoke(this.resolution))}}})();const xt=e=>"string"==typeof e?{alias:e.slice(1)}:e,kt=Le({kind:"alias",hasAssociatedError:!1,collapsibleKey:"alias",keys:{alias:{serialize:e=>`$${e}`},resolve:{}},normalize:xt,defaults:{description:e=>e.alias},intersections:{alias:(e,t,r)=>r.$.lazilyResolve(()=>wt(_e(e.resolution,t.resolution,r),r.$),`${e.alias}${r.pipe?"|>":"&"}${t.alias}`),...vt("alias",(e,t,r)=>r.$.lazilyResolve(()=>wt(_e(e.resolution,t,r),r.$),`${e.alias}${r.pipe?"|>":"&"}${t.alias}`))}}),wt=(e,t)=>e instanceof Pe?t.keywords.never.raw:e;class At extends bt{rawKeyOf(){return this.$.units(this.literalKeys)}traverseApply=(e,t)=>{this.traverseAllows(e,t)||t.error(this.errorContext)};get errorContext(){return{code:this.kind,description:this.description,...this.inner}}get compiledErrorContext(){return ze(this.errorContext)}compile(e){"Allows"===e.traversalKind?e.return(this.compiledCondition):e.if(this.compiledNegation,()=>e.line(`${e.ctx}.error(${this.compiledErrorContext})`))}}const Ot=Le({kind:"domain",hasAssociatedError:!0,collapsibleKey:"domain",keys:{domain:{}},normalize:e=>"string"==typeof e?{domain:e}:e,defaults:{description:e=>R[e.domain],actual:e=>"boolean"==typeof e?`${e}`:S(e)},intersections:{domain:(e,t)=>Pe.from("domain",e,t)}}),jt={description:1},qt=(e,t,r)=>{if(ye(e,"root")&&e.hasKind("intersection"))return qt(e.inner,t,r);if(ye(t,"root")&&t.hasKind("intersection"))return qt(e,t.inner,r);const i=$(e)?b(t,jt)[0]:{},n=e.proto??e.domain,s=t.proto??t.domain,o=n?s?_e(n,s,r):n:s;return o instanceof Pe?o:(o&&(i[o.kind]=o),Ge({kind:"intersection",baseInner:i,l:Xe(e),r:Xe(t),roots:[],ctx:r}))},Et=Le({kind:"intersection",hasAssociatedError:!0,normalize:e=>{if(be(e))return e;const{structure:t,...r}=e,i=!!t,n=t??{},s=u(r,(e,t)=>p(e,je)?(i&&c(`Flattened structure key ${e} cannot be specified alongside a root 'structure' key.`),n[e]=t,[]):[e,t]);return $(n)||(s.structure=n),s},finalizeJson:({structure:e,...t})=>K(e,"object")?{...e,...t}:t,keys:{domain:{child:!0,parse:(e,t)=>t.$.node("domain",e)},proto:{child:!0,parse:(e,t)=>t.$.node("proto",e)},structure:{child:!0,parse:(e,t)=>t.$.node("structure",e),serialize:e=>{if(!e.sequence?.minLength)return e.collapsibleJson;const{sequence:t,...r}=e.collapsibleJson,{minVariadicLength:i,...n}=t;return{...r,sequence:n.variadic&&1===Object.keys(n).length?n.variadic:n}}},divisor:{child:!0,parse:He("divisor")},max:{child:!0,parse:He("max")},min:{child:!0,parse:He("min")},maxLength:{child:!0,parse:He("maxLength")},minLength:{child:!0,parse:He("minLength")},exactLength:{child:!0,parse:He("exactLength")},before:{child:!0,parse:He("before")},after:{child:!0,parse:He("after")},regex:{child:!0,parse:He("regex")},predicate:{child:!0,parse:He("predicate")}},reduce:(e,t)=>qt({},e,{$:t,invert:!1,pipe:!1}),defaults:{description:e=>0===e.children.length?"unknown":e.structure?.description??e.children.map(e=>e.description).join(" and "),expected:e=>`  • ${e.errors.map(e=>e.expected).join("\n  • ")}`,problem:e=>`must be...\n${e.expected}`},intersections:{intersection:(e,t,r)=>qt(e,t,r),...vt("intersection",(e,t,r)=>{if(0===e.children.length)return t;const i=e.basis?_e(e.basis,t,r):t;return i instanceof Pe?i:e?.basis?.equals(i)?e:e.$.node("intersection",Object.assign(v(e.inner,jt),{[i.kind]:i}),{prereduced:!0})})}}),Kt=["intersection","unit","domain","proto"],St=Le({kind:"morph",hasAssociatedError:!1,keys:{in:{child:!0,parse:(e,t)=>t.$.node(Kt,e)},morphs:{parse:e=>Array.isArray(e)?e:[e],serialize:e=>e.map(e=>ye(e,"root")?e.json:J(e))}},normalize:e=>e,defaults:{description:e=>`a morph from ${e.in.description} to ${e.out?.description??"unknown"}`},intersections:{morph:(e,t,r)=>{if(e.morphs.some((e,r)=>e!==t.morphs[r]))return c("Invalid intersection of morphs");const i=_e(e.in,t.in,r);return i instanceof Pe?i:r.$.schema(i.branches.map(t=>r.$.node("morph",{morphs:e.morphs,in:t})))},...vt("morph",(e,t,r)=>{const i=_e(e.in,t,r);return i instanceof Pe?i:"union"===i.kind?r.$.node("union",i.branches.map(t=>({...e.inner,in:t}))):r.$.node("morph",{...e.inner,in:i})})}}),Rt=Le({kind:"proto",hasAssociatedError:!0,collapsibleKey:"proto",keys:{proto:{serialize:e=>N(e)??Re(e)}},normalize:e=>"string"==typeof e?{proto:z[e]}:"function"==typeof e?{proto:e}:"string"==typeof e.proto?{...e,proto:z[e.proto]}:e,defaults:{description:e=>e.builtinName?B[e.builtinName]:`an instance of ${e.proto.name}`,actual:e=>C(e)},intersections:{proto:(e,t)=>F(e.proto,t.proto)?e:F(t.proto,e.proto)?t:Pe.from("proto",e,t),domain:(e,t,r)=>"object"===t.domain?e:Pe.from("domain",r.$.keywords.object.raw,t)}}),zt=[...Se("union"),"alias"],Lt=Le({kind:"union",hasAssociatedError:!0,collapsibleKey:"branches",keys:{ordered:{},branches:{child:!0,parse:(e,t)=>{const r=e.map(e=>t.$.node(zt,e));return t.schema.ordered||r.sort((e,t)=>e.innerHash<t.innerHash?-1:1),r}}},normalize:e=>I(e)?{branches:e}:e,reduce:(e,t)=>{const r=Mt(e);return 1===r.length?r[0]:r.length!==e.branches.length?t.node("union",{...e,branches:r},{prereduced:!0}):void 0},defaults:{description:e=>Bt(e.branches.map(e=>e.description)),expected:e=>{const t=e.errors.reduce((e,t)=>{const r=t.propString;return e[r]??=[],e[r].push(t),e},{}),r=Object.entries(t).map(([e,t])=>{const r=[];t.forEach(e=>n(r,e.expected));const i=Bt(r),s=t.every(e=>e.actual===t[0].actual)?t[0].actual:de(t[0].data);return`${e&&`${e} `}must be ${i}${s&&` (was ${s})`}`});return Bt(r)},problem:e=>e.expected,message:e=>e.problem},intersections:{union:(e,t,r)=>{if(e.isNever!==t.isNever)return Pe.from("presence",e,t);let i;if(e.ordered){if(t.ordered)return Pe.from("indiscriminableMorphs",e,t);i=Nt(t.branches,e.branches,r),i instanceof Pe&&i.invert()}else i=Nt(e.branches,t.branches,r);return i instanceof Pe?i:r.$.schema(e.ordered||t.ordered?{branches:i,ordered:!0}:{branches:i})},...vt("union",(e,t,r)=>{const i=Nt(e.branches,[t],r);return i instanceof Pe?i:1===i.length?i[0]:r.$.schema(e.ordered?{branches:i,ordered:!0}:{branches:i})})}});let Ct=(()=>{let e,t=bt,r=[];return class extends t{static{const i="function"==typeof Symbol&&Symbol.metadata?Object.create(t[Symbol.metadata]??null):void 0;e=[A],function(e,t,r,i,n,s){function o(e){if(void 0!==e&&"function"!=typeof e)throw new TypeError("Function expected");return e}for(var a,l=i.kind,c="getter"===l?"get":"setter"===l?"set":"value",u=e?i.static?e:e.prototype:null,h=u?Object.getOwnPropertyDescriptor(u,i.name):{},d=!1,p=r.length-1;p>=0;p--){var f={};for(var m in i)f[m]="access"===m?{}:i[m];for(var m in i.access)f.access[m]=i.access[m];f.addInitializer=function(e){if(d)throw new TypeError("Cannot add initializers after decoration has completed");s.push(o(e||null))};var g=(0,r[p])("accessor"===l?{get:h.get,set:h.set}:h[c],f);if("accessor"===l){if(void 0===g)continue;if(null===g||"object"!=typeof g)throw new TypeError("Object expected");(a=o(g.get))&&(h.get=a),(a=o(g.set))&&(h.set=a),(a=o(g.init))&&null.unshift(a)}else(a=o(g))&&("field"===l?null.unshift(a):h[c]=a)}u&&Object.defineProperty(u,i.name,h),d=!0}(this,0,e,{kind:"method",name:"discriminate",static:!1,private:!1,access:{has:e=>"discriminate"in e,get:e=>e.discriminate},metadata:i},0,r),i&&Object.defineProperty(this,Symbol.metadata,{enumerable:!0,configurable:!0,writable:!0,value:i})}isNever=(function(e,t,r){for(var i=arguments.length>2,n=0;n<t.length;n++)r=i?t[n].call(e,r):t[n].call(e)}(this,r),0===this.branches.length);isBoolean=2===this.branches.length&&this.branches[0].hasUnit(!1)&&this.branches[1].hasUnit(!0);unitBranches=this.branches.filter(e=>e.hasKind("unit"));discriminant=this.discriminate();discriminantJson=this.discriminant?It(this.discriminant):null;expression=this.isNever?"never":this.isBoolean?"boolean":this.branches.map(e=>e.nestableExpression).join(" | ");traverseAllows=(e,t)=>this.branches.some(r=>r.traverseAllows(e,t));traverseApply=(e,t)=>{const r=[];for(let i=0;i<this.branches.length;i++){if(t.pushBranch(),this.branches[i].traverseApply(e,t),!t.hasError())return t.queuedMorphs.push(...t.popBranch().queuedMorphs);r.push(t.popBranch().error)}t.error({code:"union",errors:r})};compile(e){if(!this.discriminant||this.unitBranches.length===this.branches.length&&2===this.branches.length)return this.compileIndiscriminable(e);const t=this.discriminant.path.reduce((e,t)=>e+X(t,!0),"domain"===this.discriminant.kind?"typeof data":"data"),r=this.discriminant.cases,i=Object.keys(r);if(e.block(`switch(${t})`,()=>{for(const t in r){const i=r[t];e.line(`${"default"===t?"default":`case ${t}`}: return ${!0===i?i:e.invoke(i)}`)}return e}),"Allows"===e.traversalKind)return void e.return(!1);const n=Bt("domain"===this.discriminant.kind?i.map(e=>R[e.slice(1,-1)]):i);e.line(`ctx.error({\n\texpected: ${JSON.stringify(n)},\n\tactual: ${t},\n\trelativePath: ${JSON.stringify(this.discriminant.path)}\n})`)}compileIndiscriminable(e){"Apply"===e.traversalKind?(e.const("errors","[]"),this.branches.forEach(t=>e.line("ctx.pushBranch()").line(e.invoke(t)).if("!ctx.hasError()",()=>e.return("ctx.queuedMorphs.push(...ctx.popBranch().queuedMorphs)")).line("errors.push(ctx.popBranch().error)")),e.line('ctx.error({ code: "union", errors })')):(this.branches.forEach(t=>e.if(`${e.invoke(t)}`,()=>e.return(!0))),e.return(!1))}rawKeyOf(){return this.branches.reduce((e,t)=>e.and(t.rawKeyOf()),this.$.keywords.unknown.raw)}get nestableExpression(){return this.isBoolean?"boolean":super.nestableExpression}discriminate(){if(this.branches.length<2)return null;if(this.unitBranches.length===this.branches.length)return{path:[],kind:"unit",cases:u(this.unitBranches,(e,t)=>[`${t.serializedValue}`,!0])};const e={};for(let t=0;t<this.branches.length-1;t++){const r=this.branches[t];for(let i=t+1;i<this.branches.length;i++){const t=this.branches[i],n=De(r,t,r.$);if(n instanceof Pe)for(const{path:i,kind:s,disjoint:a}of n.flat){if(!p(s,Pt))continue;const n=`${i}${s}`;let l,c;if("domain"===s)l=`"${a.l.domain}"`,c=`"${a.r.domain}"`;else{if("unit"!==s)return o(`Unexpected attempt to discriminate disjoint kind '${s}'`);l=a.l.serializedValue,c=a.r.serializedValue}if(!e[n]){e[n]={[l]:[r],[c]:[t]};continue}const u=e[n];p(l,u)?u[l].includes(r)||u[l].push(r):u[l]=[r],p(c,u)?u[c].includes(t)||u[c].push(t):u[c]=[t]}}}const t=h(e).sort((e,t)=>Object.keys(e[1]).length-Object.keys(t[1]).length).at(-1);if(!t)return null;const[r,i]=t,[n,s]=Ft(r);let a=[...this.branches];const l=u(i,(e,t)=>{const r=[];a=a.filter(e=>!t.includes(e));for(const i of t){const t=Tt(s,n,i);if(null===t)return[e,!0];r.push(t)}const i=1===r.length?r[0]:this.$.node("union",r);return Object.assign(this.referencesById,i.referencesById),[e,i]});return a.length&&(l.default=this.$.node("union",a,{prereduced:!0}),Object.assign(this.referencesById,l.default.referencesById)),{kind:s,path:n,cases:l}}}})();const It=e=>({kind:e.kind,path:e.path,cases:u(e.cases,(e,t)=>[e,!0===t?t:t.hasKind("union")&&t.discriminantJson?t.discriminantJson:t.json])}),Bt=e=>{if(0===e.length)return"never";if(1===e.length)return e[0];if(2===e.length&&"false"===e[0]&&"true"===e[1]||"true"===e[0]&&"false"===e[1])return"boolean";let t="";for(let r=0;r<e.length-1;r++)t+=e[r],r<e.length-2&&(t+=", ");return t+=` or ${e[e.length-1]}`,t},Nt=(e,t,r)=>{const i=t.map(()=>[]);for(let n=0;n<e.length;n++){let s={};for(let o=0;o<t.length;o++){if(null===i[o])continue;if(e[n].equals(t[o])){i[o]=null,s={};break}const a=_e(e[n],t[o],r);if(!(a instanceof Pe)){if(a.equals(e[n])){i[o].push(e[n]),s={};break}a.equals(t[o])?i[o]=null:s[o]=a}}for(const e in s)i[e][n]=s[e]}const n=i.flatMap((e,r)=>e?.flatMap(e=>e.branches)??t[r]);return 0===n.length?Pe.from("union",e,t):n},Mt=({branches:e,ordered:t})=>{if(e.length<2)return e;const r=e.map(()=>!0);for(let i=0;i<e.length;i++)for(let n=i+1;n<e.length&&r[i]&&r[n];n++){if(e[i].equals(e[n])){r[n]=!1;continue}const s=De(e[i],e[n],e[0].$);s instanceof Pe||(s.equals(e[i])?t||(r[i]=!1):s.equals(e[n])&&(r[n]=!1))}return e.filter((e,t)=>r[t])},Pt={domain:1,unit:1},Ft=e=>{const t=e.lastIndexOf("]");return[JSON.parse(e.slice(0,t+1)),e.slice(t+1)]},Tt=(e,t,r)=>r.transform((r,i,n)=>"domain"===r&&"object"===i.domain&&t.length>n.path.length||(e===r||"domain"===r&&n.path.length===t.length)&&n.path.length===t.length&&n.path.every((e,r)=>e===t[r])?null:i,{shouldTransform:e=>0!==e.children.length||"domain"===e.kind||"unit"===e.kind}),Ut=Le({kind:"unit",hasAssociatedError:!0,keys:{unit:{preserveUndefined:!0,serialize:e=>e instanceof Date?e.toISOString():Re(e)}},normalize:e=>e,defaults:{description:e=>de(e.unit),problem:({expected:e,actual:t})=>e===t?`must be reference equal to ${e} (serialized to the same value)`:`must be ${e} (was ${t})`},intersections:{unit:(e,t)=>Pe.from("unit",e,t),...vt("unit",(e,t)=>t.allows(e.unit)?e:Pe.from("assignability",e,t.hasKind("intersection")?t.children.find(t=>!t.allows(e.unit)):t))}}),Dt=(e,t,r)=>{if(e instanceof Date){const e=`data instanceof Date && data.toISOString() === ${t}`;return r?`!(${e})`:e}return`data ${r?"!":"="}== ${t}`},_t=Le({kind:"index",hasAssociatedError:!1,intersectionIsOpen:!0,keys:{signature:{child:!0,parse:(e,t)=>{const r=t.$.schema(e);if(!r.extends(t.$.keywords.propertyKey))return c(Jt(r.expression));const i=r.branches.filter(e=>e.hasKind("unit"));return i.length?c(Vt(i.map(e=>de(e.unit)))):r}},value:{child:!0,parse:(e,t)=>t.$.schema(e)}},normalize:e=>e,defaults:{description:e=>`[${e.signature.expression}]: ${e.value.description}`},intersections:{index:(e,t,r)=>{if(e.signature.equals(t.signature)){const i=_e(e.value,t.value,r);return r.$.node("index",{signature:e.signature,value:i instanceof Pe?r.$.keywords.never.raw:i})}return e.signature.extends(t.signature)&&e.value.subsumes(t.value)?t:t.signature.extends(e.signature)&&t.value.subsumes(e.value)?e:null}}}),Vt=e=>`Index keys ${e.join(", ")} should be specified as named props.`,Jt=e=>`Indexed key definition '${e}' must be a string, number or symbol`,Wt=(e,t,r)=>{if(e.key!==t.key)return null;const i=e.key;let n=_e(e.value,t.value,r);const s=e.required||t.required?"required":"optional";if(n instanceof Pe){if("optional"!==s)return n.withPrefixKey(e.compiledKey);n=r.$.keywords.never.raw}if("required"===s)return r.$.node("required",{key:i,value:n});const o=e.hasDefault()?t.hasDefault()?e.default===t.default?e.default:c(`Invalid intersection of default values ${de(e.default)} & ${de(t.default)}`):e.default:t.hasDefault()?t.default:k;return r.$.node("optional",{key:i,value:n,default:o})};class Zt extends We{required="required"===this.kind;impliedBasis=this.$.keywords.object.raw;serializedKey=Z(this.key);compiledKey="string"==typeof this.key?this.key:this.serializedKey;_transform(e,t){t.path.push(this.key);const r=super._transform(e,t);return t.path.pop(),r}defaultValueMorphs=[e=>(e[this.key]=this.default,e)];defaultValueMorphsReference=J(this.defaultValueMorphs);hasDefault(){return"default"in this}traverseAllows=(e,t)=>{if(this.key in e){t?.path.push(this.key);const r=this.value.traverseAllows(e[this.key],t);return t?.path.pop(),r}return!this.required};traverseApply=(e,t)=>{this.key in e?(t.path.push(this.key),this.value.traverseApply(e[this.key],t),t.path.pop()):this.hasKind("required")?t.error(this.errorContext):this.hasKind("optional")&&this.hasDefault()&&t.queueMorphs(this.defaultValueMorphs)};compile(e){e.if(`${this.serializedKey} in data`,()=>e.traverseKey(this.serializedKey,`data${e.prop(this.key)}`,this.value)),this.hasKind("required")?e.else(()=>"Apply"===e.traversalKind?e.line(`ctx.error(${this.compiledErrorContext})`):e.return(!1)):"Apply"===e.traversalKind&&"default"in this&&e.else(()=>e.line(`ctx.queueMorphs(${this.defaultValueMorphsReference})`)),"Allows"===e.traversalKind&&e.return(!0)}}const Ht=Le({kind:"optional",hasAssociatedError:!1,intersectionIsOpen:!0,keys:{key:{},value:{child:!0,parse:(e,t)=>t.$.schema(e)},default:{preserveUndefined:!0}},normalize:e=>e,defaults:{description:e=>`${e.compiledKey}?: ${e.value.description}`},intersections:{optional:Wt}}),Gt=Le({kind:"required",hasAssociatedError:!0,intersectionIsOpen:!0,keys:{key:{},value:{child:!0,parse:(e,t)=>t.$.schema(e)}},normalize:e=>e,defaults:{description:e=>`${e.compiledKey}: ${e.value.description}`,expected:e=>e.missingValueDescription,actual:()=>"missing"},intersections:{required:Wt,optional:Wt}}),Xt={child:!0,parse:(e,t)=>0===e.length?void 0:e.map(e=>t.$.schema(e))},Qt=Le({kind:"sequence",hasAssociatedError:!1,collapsibleKey:"variadic",keys:{prefix:Xt,optionals:Xt,variadic:{child:!0,parse:(e,t)=>t.$.schema(e,t)},minVariadicLength:{parse:e=>0===e?void 0:e},postfix:Xt},normalize:e=>{if("string"==typeof e)return{variadic:e};if("variadic"in e||"prefix"in e||"optionals"in e||"postfix"in e||"minVariadicLength"in e){if(e.postfix?.length){if(!e.variadic)return c(tr);if(e.optionals?.length)return c(er)}return e.minVariadicLength&&!e.variadic?c("minVariadicLength may not be specified without a variadic element"):e}return{variadic:e}},reduce:(e,t)=>{let r=e.minVariadicLength??0;const i=e.prefix?.slice()??[],n=e.optionals?.slice()??[],s=e.postfix?.slice()??[];if(e.variadic){for(;n.at(-1)?.equals(e.variadic);)n.pop();if(0===n.length)for(;i.at(-1)?.equals(e.variadic);)i.pop(),r++;for(;s[0]?.equals(e.variadic);)s.shift(),r++}else 0===n.length&&i.push(...s.splice(0));if(r!==e.minVariadicLength||e.prefix&&e.prefix.length!==i.length)return t.node("sequence",{...e,prefix:i,postfix:s,optionals:n,minVariadicLength:r},{prereduced:!0})},defaults:{description:e=>e.isVariadicOnly?`${e.variadic.nestableExpression}[]`:`[${e.tuple.map(e=>"optionals"===e.kind?`${e.node.nestableExpression}?`:"variadic"===e.kind?`...${e.node.nestableExpression}[]`:e.node.expression).join(", ")}]`},intersections:{sequence:(e,t,r)=>{const i=rr({l:e.tuple,r:t.tuple,disjoint:new Pe({}),result:[],fixedVariants:[],ctx:r}),n=i.disjoint.isEmpty()?[i,...i.fixedVariants]:i.fixedVariants;return 0===n.length?i.disjoint:1===n.length?r.$.node("sequence",Yt(n[0].result)):r.$.node("union",n.map(e=>({proto:Array,sequence:Yt(e.result)})))}}}),Yt=e=>e.reduce((e,t)=>("variadic"===t.kind?e.variadic=t.node:e[t.kind]=i(e[t.kind],t.node),e),{}),er="A postfix required element cannot follow an optional element",tr="A postfix element requires a variadic element",rr=e=>{const[t,...r]=e.l,[i,...n]=e.r;if(!t||!i)return e;const s="postfix"===r.at(-1)?.kind,o="postfix"===n.at(-1)?.kind,a="prefix"===t.kind||"prefix"===i.kind?"prefix":"optionals"===t.kind||"optionals"===i.kind?s||o?"prefix":"optionals":"postfix"===t.kind||"postfix"===i.kind?"postfix":"variadic";if("prefix"===t.kind&&"variadic"===i.kind&&o){const t=rr({...e,fixedVariants:[],r:n.map(e=>({...e,kind:"prefix"}))});t.disjoint.isEmpty()&&e.fixedVariants.push(t)}else if("prefix"===i.kind&&"variadic"===t.kind&&s){const t=rr({...e,fixedVariants:[],l:r.map(e=>({...e,kind:"prefix"}))});t.disjoint.isEmpty()&&e.fixedVariants.push(t)}const l=_e(t.node,i.node,e.ctx);if(l instanceof Pe){if("prefix"!==a&&"postfix"!==a)return"optionals"===a?e:rr({...e,fixedVariants:[],l:r.map(e=>({...e,kind:"prefix"})),r:r.map(e=>({...e,kind:"prefix"}))});e.disjoint.add(l.withPrefixKey("prefix"===a?`${e.result.length}`:`-${r.length+1}`)),e.result=[...e.result,{kind:a,node:e.ctx.$.keywords.never.raw}]}else e.result=[...e.result,{kind:a,node:l}];const c=e.l.length,u=e.r.length;return("variadic"!==t.kind||c>=u&&("variadic"===i.kind||1===u))&&(e.l=r),("variadic"!==i.kind||u>=c&&("variadic"===t.kind||1===c))&&(e.r=n),rr(e)},ir=/(?:0|(?:[1-9]\\d*))$/,nr=J(ir);let sr=(()=>{let e,t=We,r=[];return class extends t{static{const i="function"==typeof Symbol&&Symbol.metadata?Object.create(t[Symbol.metadata]??null):void 0;e=[A],function(e,t,r,i,n,s){function o(e){if(void 0!==e&&"function"!=typeof e)throw new TypeError("Function expected");return e}for(var a,l=i.kind,c="getter"===l?"get":"setter"===l?"set":"value",u=e?i.static?e:e.prototype:null,h=u?Object.getOwnPropertyDescriptor(u,i.name):{},d=!1,p=r.length-1;p>=0;p--){var f={};for(var m in i)f[m]="access"===m?{}:i[m];for(var m in i.access)f.access[m]=i.access[m];f.addInitializer=function(e){if(d)throw new TypeError("Cannot add initializers after decoration has completed");s.push(o(e||null))};var g=(0,r[p])("accessor"===l?{get:h.get,set:h.set}:h[c],f);if("accessor"===l){if(void 0===g)continue;if(null===g||"object"!=typeof g)throw new TypeError("Object expected");(a=o(g.get))&&(h.get=a),(a=o(g.set))&&(h.set=a),(a=o(g.init))&&null.unshift(a)}else(a=o(g))&&("field"===l?null.unshift(a):h[c]=a)}u&&Object.defineProperty(u,i.name,h),d=!0}(this,0,e,{kind:"method",name:"keyof",static:!1,private:!1,access:{has:e=>"keyof"in e,get:e=>e.keyof},metadata:i},0,r),i&&Object.defineProperty(this,Symbol.metadata,{enumerable:!0,configurable:!0,writable:!0,value:i})}impliedBasis=(function(e,t,r){for(var i=arguments.length>2,n=0;n<t.length;n++)r=i?t[n].call(e,r):t[n].call(e)}(this,r),this.$.keywords.object.raw);impliedSiblings=this.children.flatMap(e=>e.impliedSiblings??[]);props=this.required?this.optional?[...this.required,...this.optional]:this.required:this.optional??[];propsByKey=u(this.props,(e,t)=>[t.key,t]);propsByKeyReference=J(this.propsByKey);expression=cr(this);requiredLiteralKeys=this.required?.map(e=>e.key)??[];optionalLiteralKeys=this.optional?.map(e=>e.key)??[];literalKeys=[...this.requiredLiteralKeys,...this.optionalLiteralKeys];keyof(){let e=this.$.units(this.literalKeys).branches;return this.index?.forEach(({signature:t})=>{e=e.concat(t.branches)}),this.$.node("union",e)}exhaustive=void 0!==this.undeclared||void 0!==this.index;omit(...e){return this.$.node("structure",or(this.inner,e))}merge(e){const t=me(or(this.inner,[e.keyof()]));return e.required&&(t.required=i(t.required,e.required)),e.optional&&(t.optional=i(t.optional,e.optional)),e.index&&(t.index=i(t.index,e.index)),e.sequence&&(t.sequence=e.sequence),e.undeclared?t.undeclared=e.undeclared:delete t.undeclared,this.$.node("structure",t)}traverseAllows=(e,t)=>this._traverse("Allows",e,t);traverseApply=(e,t)=>this._traverse("Apply",e,t);_traverse=(e,t,r)=>{const i=r?.currentErrorCount??0;for(let n=0;n<this.props.length;n++)if("Allows"===e){if(!this.props[n].traverseAllows(t,r))return!1}else if(this.props[n].traverseApply(t,r),r.failFast&&r.currentErrorCount>i)return!1;if(this.sequence)if("Allows"===e){if(!this.sequence.traverseAllows(t,r))return!1}else if(this.sequence.traverseApply(t,r),r.failFast&&r.currentErrorCount>i)return!1;if(!this.exhaustive)return!0;const n=Object.keys(t);n.push(...Object.getOwnPropertySymbols(t));for(let s=0;s<n.length;s++){const o=n[s];let a=!1;if(this.index)for(const n of this.index)if(n.signature.traverseAllows(o,r)){if("Allows"===e){r?.path.push(o);const e=n.value.traverseAllows(t[o],r);if(r?.path.pop(),!e)return!1}else if(r.path.push(o),n.value.traverseApply(t[o],r),r.path.pop(),r.failFast&&r.currentErrorCount>i)return!1;a=!0}if(this.undeclared&&(a||=o in this.propsByKey,a||=void 0!==this.sequence&&"string"==typeof o&&ir.test(o),!a)){if("Allows"===e)return!1;if("reject"===this.undeclared?r.error({expected:"removed",actual:null,relativePath:[o]}):r.queueMorphs([e=>(delete e[o],e)]),r.failFast)return!1}r?.path.pop()}return!0};compile(e){"Apply"===e.traversalKind&&e.initializeErrorCount(),this.props.forEach(t=>{e.check(t),"Apply"===e.traversalKind&&e.returnIfFailFast()}),this.sequence&&(e.check(this.sequence),"Apply"===e.traversalKind&&e.returnIfFailFast()),this.exhaustive&&(e.const("keys","Object.keys(data)"),e.line("keys.push(...Object.getOwnPropertySymbols(data))"),e.for("i < keys.length",()=>this.compileExhaustiveEntry(e))),"Allows"===e.traversalKind&&e.return(!0)}compileExhaustiveEntry(e){return e.const("k","keys[i]"),this.undeclared&&e.let("matched",!1),this.index?.forEach(t=>{e.if(`${e.invoke(t.signature,{arg:"k",kind:"Allows"})}`,()=>(e.traverseKey("k","data[k]",t.value),this.undeclared&&e.set("matched",!0),e))}),this.undeclared&&(0!==this.props?.length&&e.line(`matched ||= k in ${this.propsByKeyReference}`),this.sequence&&e.line(`matched ||= typeof k === "string" && ${nr}.test(k)`),e.if("!matched",()=>"Allows"===e.traversalKind?e.return(!1):"reject"===this.undeclared?e.line('ctx.error({ expected: "removed", actual: null, relativePath: [k] })').if("ctx.failFast",()=>e.return()):e.line("ctx.queueMorphs([data => { delete data[k]; return data }])"))),e}}})();const or=(e,t)=>{const r={...e};return t.forEach(e=>{r.required&&(r.required=r.required.filter(t=>"function"==typeof e?!e.allows(t.key):e!==t.key)),r.optional&&(r.optional=r.optional.filter(t=>"function"==typeof e?!e.allows(t.key):e!==t.key)),r.index&&"function"==typeof e&&(r.index=r.index.filter(t=>!t.signature.extends(e)))}),r},ar=e=>t=>{if(t.props.length||t.index){const r=t.index?.map(String)??[];t.props.forEach(t=>r.push(t[e])),t.undeclared&&r.push(`+ (undeclared): ${t.undeclared}`);const i=`{ ${r.join(", ")} }`;return t.sequence?`${i} & ${t.sequence.description}`:i}return t.sequence?.description??"{}"},lr=ar("description"),cr=ar("expression"),ur=Le({kind:"structure",hasAssociatedError:!1,normalize:e=>e,keys:{required:{child:!0,parse:He("required")},optional:{child:!0,parse:He("optional")},index:{child:!0,parse:He("index")},sequence:{child:!0,parse:He("sequence")},undeclared:{parse:e=>"ignore"===e?void 0:e}},defaults:{description:lr},intersections:{structure:(e,t,r)=>{const i={...e.inner},n={...t.inner};if(e.undeclared){const i=e.keyof(),s=t.requiredLiteralKeys.filter(e=>!i.allows(e));if(s.length)return Pe.from("presence",r.$.keywords.never.raw,t.propsByKey[s[0]].value).withPrefixKey(s[0]);n.optional&&(n.optional=n.optional.filter(e=>i.allows(e.key))),n.index&&(n.index=n.index.flatMap(e=>{if(e.signature.extends(i))return e;const t=De(i,e.signature,r.$);if(t instanceof Pe)return[];const s=hr(t,e.value,r.$);return s.required&&(n.required=n.required?[...n.required,...s.required]:s.required),s.index??[]}))}if(t.undeclared){const n=t.keyof(),s=e.requiredLiteralKeys.filter(e=>!n.allows(e));if(s.length)return Pe.from("presence",e.propsByKey[s[0]].value,r.$.keywords.never.raw).withPrefixKey(s[0]);i.optional&&(i.optional=i.optional.filter(e=>n.allows(e.key))),i.index&&(i.index=i.index.flatMap(e=>{if(e.signature.extends(n))return e;const t=De(n,e.signature,r.$);if(t instanceof Pe)return[];const s=hr(t,e.value,r.$);return s.required&&(i.required=i.required?[...i.required,...s.required]:s.required),s.index??[]}))}const s={};return(e.undeclared||t.undeclared)&&(s.undeclared="reject"===e.undeclared||"reject"===t.undeclared?"reject":"delete"),Ge({kind:"structure",baseInner:s,l:Xe(i),r:Xe(n),roots:[],ctx:r})}}}),hr=(e,t,r)=>{const[i,n]=((e,t)=>{const r=[[],[]];for(const t of e)t.hasKind("unit")?r[0].push(t):r[1].push(t);return r})(e.branches);if(!i.length)return{index:r.node("index",{signature:e,value:t})};const s={};return s.required=i.map(e=>r.node("required",{key:e.unit,value:t})),n.length&&(s.index=r.node("index",{signature:n,value:t})),s},dr={...mt,alias:kt,domain:Ot,unit:Ut,proto:Rt,union:Lt,morph:St,intersection:Et,divisor:et,regex:yt,predicate:Ye,required:Gt,optional:Ht,index:_t,sequence:Qt,structure:ur},pr={...gt,alias:$t,domain:class extends At{traverseAllows=e=>S(e)===this.domain;compiledCondition="object"===this.domain?'((typeof data === "object" && data !== null) || typeof data === "function")':`typeof data === "${this.domain}"`;compiledNegation="object"===this.domain?'((typeof data !== "object" || data === null) && typeof data !== "function")':`typeof data !== "${this.domain}"`;expression=this.domain;literalKeys=(e=>[...P[this.domain]])()},unit:class extends At{compiledValue=this.json.unit;serializedValue="string"==typeof this.unit||this.unit instanceof Date?JSON.stringify(this.compiledValue):this.compiledValue;literalKeys=M(this.unit);compiledCondition=Dt(this.unit,this.serializedValue);compiledNegation=Dt(this.unit,this.serializedValue,"negated");expression=de(this.unit);domain=S(this.unit);traverseAllows=this.unit instanceof Date?e=>e instanceof Date&&e.toISOString()===this.compiledValue:e=>e===this.unit},proto:class extends At{builtinName=N(this.proto);serializedConstructor=this.json.proto;compiledCondition=`data instanceof ${this.serializedConstructor}`;compiledNegation=`!(${this.compiledCondition})`;literalKeys=M(this.proto.prototype);traverseAllows=e=>e instanceof this.proto;expression=this.proto.name;domain="object"},union:Ct,morph:class extends bt{serializedMorphs=this.morphs.map(J);compiledMorphs=`[${this.serializedMorphs}]`;traverseAllows=(e,t)=>this.in.traverseAllows(e,t);traverseApply=(e,t)=>{t.queueMorphs(this.morphs),this.in.traverseApply(e,t)};expression=`(In: ${this.in.expression}) => Out<${this.out?.expression??"unknown"}>`;compile(e){"Allows"!==e.traversalKind?(e.line(`ctx.queueMorphs(${this.compiledMorphs})`),e.line(e.invoke(this.in))):e.return(e.invoke(this.in))}get in(){return this.inner.in}get validatedOut(){const e=this.inner.morphs.at(-1);return ye(e,"root")?e?.out:void 0}get out(){return this.validatedOut??this.$.keywords.unknown.raw}rawKeyOf(){return this.in.rawKeyOf()}},intersection:class extends bt{basis=this.domain??this.proto??null;refinements=this.children.filter(e=>e.isRefinement());expression=this.structure?.expression||this.children.map(e=>e.nestableExpression).join(" & ")||"unknown";traverseAllows=(e,t)=>this.children.every(r=>r.traverseAllows(e,t));traverseApply=(e,t)=>{const r=t.currentErrorCount;if(!(this.basis&&(this.basis.traverseApply(e,t),t.currentErrorCount>r))){if(this.refinements.length){for(let i=0;i<this.refinements.length-1;i++)if(this.refinements[i].traverseApply(e,t),t.failFast&&t.currentErrorCount>r)return;if(this.refinements.at(-1).traverseApply(e,t),t.currentErrorCount>r)return}if(!(this.structure&&(this.structure.traverseApply(e,t),t.currentErrorCount>r))&&this.predicate){for(let i=0;i<this.predicate.length-1;i++)if(this.predicate[i].traverseApply(e,t),t.failFast&&t.currentErrorCount>r)return;this.predicate.at(-1).traverseApply(e,t)}}};compile(e){if("Allows"===e.traversalKind)return this.children.forEach(t=>e.check(t)),void e.return(!0);if(e.initializeErrorCount(),this.basis&&(e.check(this.basis),this.children.length>1&&e.returnIfFail()),this.refinements.length){for(let t=0;t<this.refinements.length-1;t++)e.check(this.refinements[t]),e.returnIfFailFast();e.check(this.refinements.at(-1)),(this.structure||this.predicate)&&e.returnIfFail()}if(this.structure&&(e.check(this.structure),this.predicate&&e.returnIfFail()),this.predicate){for(let t=0;t<this.predicate.length-1;t++)e.check(this.predicate[t]),e.returnIfFail();e.check(this.predicate.at(-1))}}rawKeyOf(){return this.basis?this.structure?this.basis.rawKeyOf().or(this.structure.keyof()):this.basis.rawKeyOf():this.structure?.keyof()??this.$.keywords.never.raw}},divisor:class extends Ze{traverseAllows=e=>e%this.rule==0;compiledCondition=`data % ${this.rule} === 0`;compiledNegation=`data % ${this.rule} !== 0`;impliedBasis=this.$.keywords.number.raw;expression=`% ${this.rule}`},regex:class extends Ze{instance=new RegExp(this.rule,this.flags);expression=`${this.instance}`;traverseAllows=this.instance.test.bind(this.instance);compiledCondition=`${this.expression}.test(data)`;compiledNegation=`!${this.compiledCondition}`;impliedBasis=this.$.keywords.string.raw},predicate:class extends We{serializedPredicate=J(this.predicate);compiledCondition=`${this.serializedPredicate}(data, ctx)`;compiledNegation=`!${this.compiledCondition}`;impliedBasis=null;expression=this.serializedPredicate;traverseAllows=this.predicate;errorContext={code:"predicate",description:this.description};compiledErrorContext=`{ code: "predicate", description: "${this.description}" }`;traverseApply=(e,t)=>{this.predicate(e,t)||t.hasError()||t.error(this.errorContext)};compile(e){"Allows"!==e.traversalKind?e.if(`${this.compiledNegation} && !ctx.hasError()`,()=>e.line(`ctx.error(${this.compiledErrorContext})`)):e.return(this.compiledCondition)}},required:class extends Zt{expression=`${this.compiledKey}: ${this.value.expression}`;errorContext=Object.freeze({code:"required",missingValueDescription:this.value.description,relativePath:[this.key]});compiledErrorContext=ze(this.errorContext)},optional:class extends Zt{expression=`${this.compiledKey}?: ${this.value.expression}`},index:class extends We{impliedBasis=this.$.keywords.object.raw;expression=`[${this.signature.expression}]: ${this.value.expression}`;traverseAllows=(e,t)=>x(e).every(e=>{if(this.signature.traverseAllows(e[0],t)){t?.path.push(e[0]);const r=this.value.traverseAllows(e[1],t);return t?.path.pop(),r}return!0});traverseApply=(e,t)=>x(e).forEach(e=>{this.signature.traverseAllows(e[0],t)&&(t.path.push(e[0]),this.value.traverseApply(e[1],t),t.path.pop())});_transform(e,t){t.path.push(this.signature);const r=super._transform(e,t);return t.path.pop(),r}compile(){}},sequence:class extends We{impliedBasis=this.$.keywords.Array.raw;prefix=this.inner.prefix??[];optionals=this.inner.optionals??[];prevariadic=[...this.prefix,...this.optionals];postfix=this.inner.postfix??[];isVariadicOnly=this.prevariadic.length+this.postfix.length===0;minVariadicLength=this.inner.minVariadicLength??0;minLength=this.prefix.length+this.minVariadicLength+this.postfix.length;minLengthNode=0===this.minLength?null:this.$.node("minLength",this.minLength);maxLength=this.variadic?null:this.minLength+this.optionals.length;maxLengthNode=null===this.maxLength?null:this.$.node("maxLength",this.maxLength);impliedSiblings=this.minLengthNode?this.maxLengthNode?[this.minLengthNode,this.maxLengthNode]:[this.minLengthNode]:this.maxLengthNode?[this.maxLengthNode]:[];childAtIndex(e,t){if(t<this.prevariadic.length)return this.prevariadic[t];const r=e.length-this.postfix.length;return t>=r?this.postfix[t-r]:this.variadic??o(`Unexpected attempt to access index ${t} on ${this}`)}traverseAllows=(e,t)=>{for(let r=0;r<e.length;r++)if(!this.childAtIndex(e,r).traverseAllows(e[r],t))return!1;return!0};traverseApply=(e,t)=>{for(let r=0;r<e.length;r++)t.path.push(r),this.childAtIndex(e,r).traverseApply(e[r],t),t.path.pop()};compile(e){this.prefix.forEach((t,r)=>e.traverseKey(`${r}`,`data[${r}]`,t)),this.optionals.forEach((t,r)=>{const i=`${r+this.prefix.length}`;e.if(`${i} >= ${e.data}.length`,()=>"Allows"===e.traversalKind?e.return(!0):e.return()),e.traverseKey(i,`data[${i}]`,t)}),this.variadic&&(this.postfix.length&&e.const("firstPostfixIndex",`${e.data}.length${this.postfix.length?`- ${this.postfix.length}`:""}`),e.for("i < "+(this.postfix.length?"firstPostfixIndex":"data.length"),()=>e.traverseKey("i","data[i]",this.variadic),this.prevariadic.length),this.postfix.forEach((t,r)=>{const i=`firstPostfixIndex + ${r}`;e.traverseKey(i,`data[${i}]`,t)})),"Allows"===e.traversalKind&&e.return(!0)}_transform(e,t){t.path.push(this.$.keywords.nonNegativeIntegerString.raw);const r=super._transform(e,t);return t.path.pop(),r}tuple=(e=>{const t=[];return e.prefix?.forEach(e=>t.push({kind:"prefix",node:e})),e.optionals?.forEach(e=>t.push({kind:"optionals",node:e})),e.variadic&&t.push({kind:"variadic",node:e.variadic}),e.postfix?.forEach(e=>t.push({kind:"postfix",node:e})),t})(this.inner);expression=this.description},structure:sr};class fr extends m{get[ge](){return"module"}}const mr={description:{meta:!0}},gr=(e,t)=>{const r=yr(e);return t&&!t.includes(r)?c(`Root of kind ${r} should be one of ${t}`):r},yr=e=>{switch(typeof e){case"string":return"$"===e[0]?"alias":"domain";case"function":return ye(e,"root")?e.kind:"proto";case"object":{if(null===e)break;if("morphs"in e)return"morph";if("branches"in e||I(e))return"union";if("unit"in e)return"unit";if("alias"in e)return"alias";const t=Object.keys(e);if(0===t.length||t.some(e=>e in Oe))return"intersection";if("proto"in e)return"proto";if("domain"in e)return"domain"}}return c(`${de(e)} is not a valid type schema`)},br={},vr=e=>I(e)?e.map(e=>e.collapsibleJson):e.collapsibleJson;class $r extends G{traversalKind;path=[];discriminants=[];constructor(e){super("data","ctx"),this.traversalKind=e}invoke(e,t){const r=t?.arg??this.data;return this.requiresContextFor(e)?`${this.reference(e,t)}(${r}, ${this.ctx})`:`${this.reference(e,t)}(${r})`}reference(e,t){const r=`this.${e.id}${t?.kind??this.traversalKind}`;return t?.bind?`${r}.bind(${t?.bind})`:r}requiresContextFor(e){return"Apply"===this.traversalKind||e.allowsRequiresContext}initializeErrorCount(){return this.const("errorCount","ctx.currentErrorCount")}returnIfFail(){return this.if("ctx.currentErrorCount > errorCount",()=>this.return())}returnIfFailFast(){return this.if("ctx.failFast && ctx.currentErrorCount > errorCount",()=>this.return())}traverseKey(e,t,r){const i=this.requiresContextFor(r);return i&&this.line(`${this.ctx}.path.push(${e})`),this.check(r,{arg:t}),i&&this.line(`${this.ctx}.path.pop()`),this}check(e,t){return"Allows"===this.traversalKind?this.if(`!${this.invoke(e,t)}`,()=>this.return(!1)):this.line(this.invoke(e,t))}writeMethod(e){return`${e}(${this.argNames.join(", ")}){\n${this.body}    }\n`}}var xr=function(e,t,r,i,n,s){function o(e){if(void 0!==e&&"function"!=typeof e)throw new TypeError("Function expected");return e}for(var a,l=i.kind,c="getter"===l?"get":"setter"===l?"set":"value",u=!t&&e?i.static?e:e.prototype:null,h=t||(u?Object.getOwnPropertyDescriptor(u,i.name):{}),d=!1,p=r.length-1;p>=0;p--){var f={};for(var m in i)f[m]="access"===m?{}:i[m];for(var m in i.access)f.access[m]=i.access[m];f.addInitializer=function(e){if(d)throw new TypeError("Cannot add initializers after decoration has completed");s.push(o(e||null))};var g=(0,r[p])("accessor"===l?{get:h.get,set:h.set}:h[c],f);if("accessor"===l){if(void 0===g)continue;if(null===g||"object"!=typeof g)throw new TypeError("Object expected");(a=o(g.get))&&(h.get=a),(a=o(g.set))&&(h.set=a),(a=o(g.init))&&n.unshift(a)}else(a=o(g))&&("field"===l?n.unshift(a):h[c]=a)}u&&Object.defineProperty(u,i.name,h),d=!0};const kr=Object.assign(u(dr,(e,t)=>[e,t.defaults]),{jitless:E(),registerKeywords:!1,prereducedAliases:!1}),wr=["registerKeywords","prereducedAliases"],Ar=(e,t)=>{if(!t)return e;const r=((e,t)=>{const r={...e};let i;for(i in t)r[i]=Ee(i)?{...e[i],...t[i]}:t[i];return r})(e,t);return wr.forEach(e=>{e in t||delete r[e]}),r},Or=e=>`#${e} duplicates public alias ${e}`,jr={};let qr=0,Er=(()=>{let e,t,r,i=[];return class n{static{const n="function"==typeof Symbol&&Symbol.metadata?Object.create(null):void 0;e=[w],t=[w],r=[w],xr(this,null,e,{kind:"method",name:"schema",static:!1,private:!1,access:{has:e=>"schema"in e,get:e=>e.schema},metadata:n},null,i),xr(this,null,t,{kind:"method",name:"defineRoot",static:!1,private:!1,access:{has:e=>"defineRoot"in e,get:e=>e.defineRoot},metadata:n},null,i),xr(this,null,r,{kind:"method",name:"units",static:!1,private:!1,access:{has:e=>"units"in e,get:e=>e.units},metadata:n},null,i),n&&Object.defineProperty(this,Symbol.metadata,{enumerable:!0,configurable:!0,writable:!0,value:n})}config=function(e,t,r){for(var i=arguments.length>2,n=0;n<t.length;n++)r=i?t[n].call(e,r):t[n].call(e);return i?r:void 0}(this,i);resolvedConfig;id="$"+ ++qr;[ge]="scope";referencesById={};references=[];resolutions={};json={};exportedNames;aliases={};resolved=!1;static keywords={};get keywords(){return n.keywords}static ambient;get ambient(){return this.constructor.ambient}constructor(e,t){this.config=t??{},this.resolvedConfig=(e=>Ar(Ar(kr,Ce),e))(t),this.exportedNames=Object.keys(e).filter(t=>{if("#"===t[0]){const r=t.slice(1);return r in this.aliases&&c(Or(r)),this.aliases[r]=e[t],!1}return t in this.aliases&&c(Or(t)),this.aliases[t]=e[t],!0}),this.ambient&&(this.ambient.export(),this.resolutions=u(this.ambient.resolutions,(e,t)=>[e,ye(t,"root")?t.bindScope(this):t]))}get raw(){return this}schema(e,t){return this.node(gr(e),e,t)}defineRoot(e){return e}units(e,t){const r=[];for(const t of e)r.includes(t)||r.push(t);const i=r.map(e=>this.node("unit",{unit:e},t));return this.node("union",i,{...t,prereduced:!0})}lazyResolutions=[];lazilyResolve(e,t){t||(jr.synthetic??=0,t="synthetic"+ ++jr.synthetic);const r=this.node("alias",{alias:t,resolve:e},{prereduced:!0});return this.lazyResolutions.push(r),r}node=((e,t,r)=>{let i="string"==typeof e?e:gr(t,e),n=t;if(be(n)&&n.kind===i)return n.bindScope(this);if("alias"!==i||r?.prereduced){if("union"===i&&K(n,"object")){const e=(e=>I(e)?e:"branches"in e&&I(e.branches)?e.branches:void 0)(n);1===e?.length&&(n=e[0],i=gr(n))}}else{const e=this.resolveRoot(xt(n).alias);n=e,i=e.kind}const s=dr[i],o=s.normalize?.(n)??n;if(be(o))return o.kind===i?o.bindScope(this):c(`Node of kind ${o.kind} is not valid as a ${i} definition`);const a=r?.alias??i;jr[a]??=0;const l=`${a}${++jr[a]}`,u=((e,t)=>{const r=dr[e],i={},n=h(t.schema).sort(([e],[t])=>Ee(e)?Ee(t)?Ke(e)-Ke(t):1:Ee(t)||e<t?-1:1),s=[];for(const s of n){const n=s[0],o=r.keys[n]??mr[n];if(!o)return c(`Key ${n} is not valid on ${e} schema`);const a=o.parse?o.parse(s[1],t):s[1];a===k||void 0===a&&!o.preserveUndefined||(i[n]=a)}const o=h(i);let a={},l={};o.forEach(([e,t])=>{const i=t,n=r.keys[e]??mr[e];a[e]=(n.serialize??(n.child?vr:Re))(i),n.child&&(I(i)?s.push(...i):s.push(i)),n.meta||(l[e]=a[e])}),r.finalizeJson&&(a=r.finalizeJson(a),l=r.finalizeJson(l));let u=a;const d=Object.keys(u);1===d.length&&d[0]===r.collapsibleKey&&(u=u[r.collapsibleKey],K(u,"object")&&1===Object.keys(a).length&&(a=u,l=u));const p=JSON.stringify({kind:e,...a});if(t.reduceTo)return br[p]=t.reduceTo,t.reduceTo;const f=JSON.stringify({kind:e,...l});if(r.reduce&&!t.prereduced){const e=r.reduce(i,t.$);if(e)return e instanceof Pe?e.throw():(t.alias&&(e.alias??=t.alias),e)}if(br[p])return br[p];const m={id:t.id,kind:e,impl:r,inner:i,entries:o,json:a,typeJson:l,collapsibleJson:u,children:s,innerHash:p,typeHash:f,$:t.$};t.alias&&(m.alias=t.alias);for(const e in i)"description"!==e&&"in"!==e&&"out"!==e&&(m[e]=i[e]);const g=new pr[e](m);return br[p]=g,g})(i,{...r,id:l,$:this,schema:o}).bindScope(this);return this.resolved?this.resolvedConfig.jitless||Nr(u.references):Object.assign(this.referencesById,u.referencesById),u}).bind(this);parseRoot(e,t){return this.schema(e,t)}resolveRoot(e){return this.maybeResolveRoot(e)??c(Cr(e))}maybeResolveRoot(e){const t=this.maybeResolveGenericOrRoot(e);if(!ye(t,"generic"))return t}maybeResolveGenericOrRoot(e){const t=this.maybeResolve(e);return ye(t,"module")?c(Br(e)):t}preparseRoot(e){return e}maybeResolve(e){const t=this.maybeShallowResolve(e);return"string"==typeof t?this.node("alias",{alias:t},{prereduced:!0}):t}maybeShallowResolve(e){const t=this.resolutions[e];if(t)return t;let r=this.aliases[e];return r?(r=this.preparseRoot(r),ye(r,"generic")?this.resolutions[e]=((i=r).$.schema(i.def,{}),i):ye(r,"module")?this.resolutions[e]=r:(this.resolutions[e]=e,this.resolutions[e]=this.parseRoot(r))):this.maybeResolveSubalias(e);var i}maybeResolveSubalias(e){return Kr(this.aliases,e)}import(...e){return new fr(u(this.export(...e),(e,t)=>[`#${e}`,t]))}_exportedResolutions;_exports;export(...e){if(!this._exports){this._exports={};for(const e of this.exportedNames)this._exports[e]=this.maybeResolve(e);this.lazyResolutions.forEach(e=>e.resolution),this._exportedResolutions=Lr(this,this._exports),Object.assign(this.json,u(this._exportedResolutions,(e,t)=>ye(t,"root")?[e,t.json]:[])),Object.assign(this.resolutions,this._exportedResolutions),this.config.registerKeywords&&Object.assign(n.keywords,this._exportedResolutions),this.references=Object.values(this.referencesById),this.resolvedConfig.jitless||Nr(this.references),this.resolved=!0}return new fr(u(e.length?e:this.exportedNames,(e,t)=>[t,this._exports[t]]))}resolve(e){return this.export()[e]}}})();const Kr=(e,t)=>{const r=t.indexOf(".");if(-1===r)return;const i=t.slice(0,r),n=e[i];if(void 0===n)return;if(!ye(n,"module"))return c(Ir(i));const s=t.slice(r+1),a=n[s];return void 0===a?ye(a,"module")?Kr(a,s):c(Cr(t)):ye(a,"root")||ye(a,"generic")?a:void o(`Unexpected resolution for alias '${t}': ${de(a)}`)},Sr=(e,t)=>new Rr(e,t),Rr=Er,zr=new Rr({}),Lr=(e,t)=>{const r={};for(const i in t){const n=t[i];if(ye(n,"module")){const t=u(Lr(e,n),(e,t)=>[`${i}.${e}`,t]);Object.assign(r,t)}else ye(n,"generic")||ye(n,"root")?r[i]=n:o(`Unexpected scope resolution ${de(n)}`)}return r},Cr=e=>`'${e}' is unresolvable`,Ir=e=>`'${e}' must reference a module to be accessed using dot syntax`,Br=e=>`Reference to submodule '${e}' must specify an alias`,Nr=e=>{const t=Mr(e);for(const r of e)r.jit||(r.jit=!0,r.traverseAllows=t[`${r.id}Allows`].bind(t),r.isRoot()&&!r.allowsRequiresContext&&(r.allows=r.traverseAllows),r.traverseApply=t[`${r.id}Apply`].bind(t))},Mr=e=>(new G).block("return",t=>(e.forEach(e=>{const r=new $r("Allows").indent();e.compile(r);const i=new $r("Apply").indent();e.compile(i),t.line(`${r.writeMethod(`${e.id}Allows`)},`).line(`${i.writeMethod(`${e.id}Apply`)},`)}),t)).compile()(),Pr=Sr({any:{},bigint:"bigint",boolean:[{unit:!1},{unit:!0}],false:{unit:!1},never:[],null:{unit:null},number:"number",object:"object",string:"string",symbol:"symbol",true:{unit:!0},unknown:{},void:{unit:void 0},undefined:{unit:void 0}},{prereducedAliases:!0,registerKeywords:!0}).export(),Fr=Sr({lengthBoundable:["string",Array],propertyKey:["string","symbol"],nonNegativeIntegerString:{domain:"string",regex:ir}},{prereducedAliases:!0,registerKeywords:!0}).export();zr.node("union",{branches:["string","number","object","bigint","symbol",{unit:!0},{unit:!1},{unit:null},{unit:void 0}]},{reduceTo:zr.node("intersection",{},{prereduced:!0})});const Tr=Sr({Array:Array,Function:Function,Date:Date,Error:Error,Map:Map,RegExp:RegExp,Set:Set,WeakMap:WeakMap,WeakSet:WeakSet,Promise:Promise},{prereducedAliases:!0,registerKeywords:!0}).export(),Ur=(e,t)=>zr.defineRoot({domain:"string",regex:{rule:e.source,flags:e.flags,description:t}}),Dr=zr.defineRoot({in:Ur(te,"a well-formed numeric string"),morphs:e=>Number.parseFloat(e)}),_r=zr.defineRoot({in:Ur(ne,"a well-formed integer string"),morphs:(e,t)=>{if(!se(e))return t.error("a well-formed integer string");const r=Number.parseInt(e);return Number.isSafeInteger(r)?r:t.error("an integer in the range Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER")}}),Vr=zr.defineRoot({in:"string",morphs:(e,t)=>{try{return new URL(e)}catch{return t.error("a valid URL")}}}),Jr=zr.defineRoot({in:"string",morphs:(e,t)=>{try{return JSON.parse(e)}catch{return t.error("a valid JSON string")}}}),Wr=Sr({url:Vr,number:Dr,integer:_r,date:zr.defineRoot({in:"string",morphs:(e,t)=>{const r=((e,t)=>{{const t=new Date(e);return Number.isNaN(+t)?"a valid date":t}})(e);return"string"==typeof r?t.error(r):r}}),json:Jr}).export(),Zr="(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])",Hr=`(${Zr}[.]){3}${Zr}`,Gr=Ur(new RegExp(`^${Hr}$`),"a valid IPv4 address"),Xr="(?:[0-9a-fA-F]{1,4})",Qr=Ur(new RegExp(`^((?:${Xr}:){7}(?:${Xr}|:)|(?:${Xr}:){6}(?:${Hr}|:${Xr}|:)|(?:${Xr}:){5}(?::${Hr}|(:${Xr}){1,2}|:)|(?:${Xr}:){4}(?:(:${Xr}){0,1}:${Hr}|(:${Xr}){1,3}|:)|(?:${Xr}:){3}(?:(:${Xr}){0,2}:${Hr}|(:${Xr}){1,4}|:)|(?:${Xr}:){2}(?:(:${Xr}){0,3}:${Hr}|(:${Xr}){1,5}|:)|(?:${Xr}:){1}(?:(:${Xr}){0,4}:${Hr}|(:${Xr}){1,6}|:)|(?::((?::${Xr}){0,5}:${Hr}|(?::${Xr}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?$`),"a valid IPv6 address"),Yr=zr.defineRoot([Gr,Qr]),ei=zr.defineRoot({domain:"string",predicate:{predicate:e=>{try{new URL(e)}catch{return!1}return!0},description:"a valid URL"}}),ti=Ur(/^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$/,"a valid email"),ri=Ur(/^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$/,"a valid UUID"),ii=Ur(/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/,"a valid semantic version (see https://semver.org/)"),ni=zr.defineRoot({domain:"string",regex:{rule:/^(?:4[0-9]{12}(?:[0-9]{3,6})?|5[1-5][0-9]{14}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|6(?:011|5[0-9][0-9])[0-9]{12,15}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11}|6[27][0-9]{14}|^(81[0-9]{14,17}))$/.source,description:"a valid credit card number"},predicate:{predicate:e=>{const t=e.replace(/[- ]+/g,"");let r,i,n=0,s=!1;for(let e=t.length-1;e>=0;e--)r=t.substring(e,e+1),i=Number.parseInt(r,10),s?(i*=2,n+=i>=10?i%10+1:i):n+=i,s=!s;return!(n%10!=0||!t)},description:"a valid credit card number"}}),si=Sr({alpha:Ur(/^[A-Za-z]*$/,"only letters"),alphanumeric:Ur(/^[A-Za-z\d]*$/,"only letters and digits"),lowercase:Ur(/^[a-z]*$/,"only lowercase letters"),uppercase:Ur(/^[A-Z]*$/,"only uppercase letters"),creditCard:ni,email:ti,uuid:ri,url:ei,semver:ii,ip:Yr,integer:{domain:"number",divisor:1}},{prereducedAliases:!0}).export(),oi=Sr({...Pr,...Tr,...si,parse:Wr});Er.ambient=oi.raw;const ai=oi.export();class li extends q{params;def;$;[ge]="generic";constructor(e,t,r){super((...e)=>r.parseRoot(t)),this.params=e,this.def=t,this.$=r}}class ci{chars;i;constructor(e){this.chars=[...e],this.i=0}shift(){return this.chars[this.i++]??""}get lookahead(){return this.chars[this.i]??""}get nextLookahead(){return this.chars[this.i+1]??""}get length(){return this.chars.length}shiftUntil(e){let t="";for(;this.lookahead;){if(e(this,t)){if(t[t.length-1]!==ci.escapeToken)break;t=t.slice(0,-1)}t+=this.shift()}return t}shiftUntilNextTerminator(){return this.shiftUntilNonWhitespace(),this.shiftUntil(ci.lookaheadIsTerminator)}shiftUntilNonWhitespace(){return this.shiftUntil(ci.lookaheadIsNotWhitespace)}jumpToIndex(e){this.i=e<0?this.length+e:e}get location(){return this.i}get unscanned(){return this.chars.slice(this.i,this.length).join("")}get scanned(){return this.chars.slice(0,this.i).join("")}sliceChars(e,t){return this.chars.slice(e,t).join("")}lookaheadIs(e){return this.lookahead===e}lookaheadIsIn(e){return this.lookahead in e}}!function(e){e.lookaheadIsTerminator=t=>t.lookahead in e.terminatingChars,e.lookaheadIsNotWhitespace=t=>!(t.lookahead in e.whiteSpaceTokens),e.terminatingChars={"<":!0,">":!0,"=":!0,"|":!0,"&":!0,")":!0,"[":!0,"%":!0," ":!0,",":!0},e.finalizingLookaheads={">":!0,",":!0,"":!0},e.escapeToken="\\",e.whiteSpaceTokens={" ":!0,"\n":!0,"\t":!0},e.lookaheadIsFinalizing=(t,r)=>">"===t?"="===r[0]?"="===r[1]:""===r.trimStart()||p(r.trimStart()[0],e.terminatingChars):","===t}(ci||(ci={}));const ui=([e,t])=>{const r=di(e);return I(t)&&"="===t[1]?("required"!==r.kind&&c(hi),{kind:"optional",key:r.key,value:t[0],default:t[2]}):{kind:r.kind,key:r.key,value:t,default:k}},hi="Only required keys may specify default values, e.g. { ark: ['string', '=', '⛵'] }",di=e=>"symbol"==typeof e?{kind:"required",key:e}:"?"===e.at(-1)?e.at(-2)===ci.escapeToken?{kind:"required",key:`${e.slice(0,-2)}?`}:{kind:"optional",key:e.slice(0,-1)}:"["===e[0]&&"]"===e.at(-1)?{kind:"index",key:e.slice(1,-1)}:e[0]===ci.escapeToken&&"["===e[1]&&"]"===e.at(-1)?{kind:"required",key:e.slice(1)}:"..."===e||"+"===e?{kind:e,key:e}:{kind:"required",key:"\\..."===e?"...":"\\+"===e?"+":e},pi={">":!0,">=":!0},fi={"<":!0,"<=":!0},mi={"<":">",">":"<","<=":">=",">=":"<=","==":"=="},gi=e=>`Missing ${e}`,yi=e=>`Left-bounded expressions must specify their limits using < or <= (was ${e})`,bi=(e,t,r,i,n)=>{const s=r.parseUntilFinalizer();return i.push(s.scanner.scanned.slice(0,-1)),n.push(s.root),">"===s.finalizer?n.length===t.length?{result:n,unscanned:s.scanner.unscanned}:s.error(vi(e,t,i)):","===s.finalizer?bi(e,t,r,i,n):s.error(gi(">"))},vi=(e,t,r)=>`${e}<${t.join(", ")}> requires exactly ${t.length} args (got ${r.length}${0===r.length?"":`: ${r.join(", ")}`})`,$i=e=>{const t=e.previousOperator();return t?xi(t,e.scanner.unscanned):ki(e.scanner.unscanned)},xi=(e,t="")=>`Token '${e}' requires a right operand${t?` before '${t}'`:""}`,ki=e=>"Expected an expression"+(e?` before '${e}'`:""),wi=(e,t,r)=>{switch(t){case"required":return e.optionals?c(ji):(e.variadic?e.postfix=i(e.postfix,r):e.prefix=i(e.prefix,r),e);case"optional":return e.variadic?c(qi):(e.optionals=i(e.optionals,r),e);case"variadic":return e.postfix&&c(Oi),e.variadic?e.variadic.equals(r)||c(Oi):e.variadic=r.raw,e}},Ai=(e,t)=>{const r=t.firstReferenceOfKind("sequence");return r?(r.prefix.forEach(t=>wi(e,"required",t)),r.optionals.forEach(t=>wi(e,"optional",t)),r.variadic&&wi(e,"variadic",r.variadic),r.postfix.forEach(t=>wi(e,"required",t)),e):wi(e,"variadic",Pr.unknown)},Oi="A tuple may have at most one variadic element",ji="A required element may not follow an optional element",qi="An optional element may not follow a variadic element",Ei=(e,t)=>{if(void 0===e[2])return c(xi(e[1],""));const r=t.$.parse(e[0],t),i=t.$.parse(e[2],t);return"&"===e[1]?r.and(i):r.or(i)},Ki=(e,t)=>`${":"===e?"Narrow":"Morph"} expression requires a function following '${e}' (was ${typeof t})`,Si={"|":Ei,"&":Ei,"[]":(e,t)=>t.$.parse(e[0],t).array(),":":(e,t)=>"function"!=typeof e[2]?c(Ki(":",e[2])):t.$.parse(e[0],t).constrain("predicate",e[2]),"=>":(e,t)=>"function"!=typeof e[2]?c(Ki("=>",e[2])):t.$.parse(e[0],t).pipe(e[2]),"@":(e,t)=>t.$.parse(e[0],t).configureShallowDescendants(e[2])},Ri={keyof:(e,t)=>t.$.parse(e[1],t).keyof(),instanceof:(e,t)=>{if("function"!=typeof e[1])return c(zi(C(e[1])));const r=e.slice(1).map(e=>"function"==typeof e?t.$.node("proto",{proto:e}):c(zi(C(e))));return 1===r.length?r[0]:t.$.node("union",{branches:r})},"===":(e,t)=>t.$.units(e.slice(1))},zi=e=>`Expected a constructor following 'instanceof' operator (was ${e})`,Li=e=>`Type definitions must be strings or objects (was ${e})`,Ci=e=>"Invalid Date"!==e.toString(),Ii=e=>`'${e}' could not be parsed by the Date constructor`,Bi={"<":!0,">":!0},Ni={"<":1,">":1,"=":1},Mi=(e,t,r,i)=>r.extends(Pr.number)?"number"!=typeof t?c(Pi(e,t,i)):"=="===e?["min","max"]:">"===e[0]?["min"]:["max"]:r.extends(Fr.lengthBoundable)?"number"!=typeof t?c(Pi(e,t,i)):"=="===e?["minLength","maxLength"]:">"===e[0]?["minLength"]:["maxLength"]:r.extends(Tr.Date)?"=="===e?["after","before"]:">"===e[0]?["after"]:["before"]:c((e=>`Bounded expression ${e} must be a number, string, Array, or Date`)(r.expression)),Pi=(e,t,r)=>`Comparator ${"left"===r?mi[e]:e} must be ${"left"===r?"preceded":"followed"} by a corresponding literal (was ${t})`,Fi=e=>`% operator must be followed by a non-zero integer literal (was ${e})`,Ti=e=>{const t=e.scanner.shift();return""===t?e.finalize(""):"["===t?"]"===e.scanner.shift()?e.setRoot(e.root.array()):e.error(Di):"|"===t||"&"===t?e.pushRootToBranch(t):")"===t?e.finalizeGroup():ci.lookaheadIsFinalizing(t,e.scanner.unscanned)?e.finalize(t):p(t,Ni)?((e,t)=>{const r=((e,t)=>e.scanner.lookaheadIs("=")?`${t}${e.scanner.shift()}`:p(t,Bi)?t:e.error("= is not a valid comparator. Use == to check for equality"))(e,t);if(e.root.hasKind("unit")){if("number"==typeof e.root.unit)return e.reduceLeftBound(e.root.unit,r),void e.unsetRoot();if(e.root.unit instanceof Date){const t=`d'${e.root.description??e.root.unit.toISOString()}'`;return e.unsetRoot(),void e.reduceLeftBound(t,r)}}return((e,t)=>{const r=e.unsetRoot(),i=e.scanner.location;e.parseOperand();const n=e.unsetRoot(),s=e.scanner.sliceChars(i,e.scanner.location);if(e.root=r,!n.hasKind("unit")||"number"!=typeof n.unit&&!(n.unit instanceof Date))return e.error(Pi(t,s,"right"));const o=n.unit,a=1===t.length;for(const i of Mi(t,"number"==typeof o?o:s,r,"right"))e.constrainRoot(i,{rule:o,exclusive:a});if(!e.branches.leftBound)return;if(!p(t,fi))return e.error(yi(t));const l=Mi(e.branches.leftBound.comparator,e.branches.leftBound.limit,r,"left");var c,u,h;e.constrainRoot(l[0],{rule:(h=(c=e.branches.leftBound).limit,"string"!=typeof h||"d"!==h[0]||"'"!==h[1]&&'"'!==h[1]||h.at(-1)!==h[1]?c.limit:(u=c.limit,u.slice(2,-1))),exclusive:1===c.comparator.length}),e.branches.leftBound=null})(e,r)})(e,t):"%"===t?(e=>{const t=e.scanner.shiftUntilNextTerminator(),r=(i=t,n={errorOnFail:Fi(t)},he(i,"integer",n));var i,n;0===r&&e.error(Fi(0)),e.root=e.root.constrain("divisor",r)})(e):" "===t?Ti(e):e.error(Ui(t))},Ui=(e,t="")=>`'${e}' is not allowed here${t&&` (should be ${t})`}`,Di="Missing expected ']'",_i=e=>Vi(new ci(e)),Vi=e=>{const t=e.shiftUntilNextTerminator();""===t&&c("An empty string is not a valid generic parameter name"),e.shiftUntilNonWhitespace();const r=e.shift();return""===r?[t]:","===r?[t,...Vi(e)]:c(Ui(r,","))},Ji=(e,t)=>{const r=e.scanner.shiftUntil(Gi[Hi[t]]);if(""===e.scanner.lookahead)return e.error(Qi(r,t));if(e.scanner.shift(),"/"===t)e.root=e.ctx.$.node("intersection",{domain:"string",regex:r},{prereduced:!0});else if(p(t,Wi))e.root=e.ctx.$.node("unit",{unit:r});else{const t=((e,t)=>{const r=new Date(e);if(Ci(r))return r;const i=ue(e);if(void 0!==i){const e=new Date(i);if(Ci(e))return e}return t?c(!0===t?Ii(e):t):void 0})(r,Ii(r));e.root=e.ctx.$.node("unit",{unit:t,description:r})}},Wi={"'":1,'"':1},Zi={"/":1,"'":1,'"':1},Hi={"d'":"'",'d"':'"',"'":"'",'"':'"',"/":"/"},Gi={"'":e=>"'"===e.lookahead,'"':e=>'"'===e.lookahead,"/":e=>"/"===e.lookahead},Xi={'"':"double-quote","'":"single-quote","/":"forward slash"},Qi=(e,t)=>`${t}${e} requires a closing ${Xi[Hi[t]]}`,Yi=e=>""===e.scanner.lookahead?e.error($i(e)):"("===e.scanner.lookahead?e.shiftedByOne().reduceGroupOpen():e.scanner.lookaheadIsIn(Zi)?Ji(e,e.scanner.shift()):e.scanner.lookaheadIsIn(ci.whiteSpaceTokens)?Yi(e.shiftedByOne()):"d"===e.scanner.lookahead&&e.scanner.nextLookahead in Wi?Ji(e,`${e.scanner.shift()}${e.scanner.shift()}`):(e=>{const t=e.scanner.shiftUntilNextTerminator();"keyof"===t?e.addPrefix("keyof"):e.root=((e,t)=>((e,t)=>{if(e.ctx.args?.[t])return e.ctx.args[t].raw;const r=e.ctx.$.maybeResolve(t);return r instanceof bt?r:void 0!==r?ye(r,"generic")?((e,t,r)=>{if(r.scanner.shiftUntilNonWhitespace(),"<"!==r.scanner.shift())return r.error(vi(e,t.params,[]));const i=((e,t,r)=>bi(e,t,r,[],[]))(e,t.params,r),n=i.unscanned.length;return r.scanner.jumpToIndex(0===n?r.scanner.length:-n),t(...i.result)})(t,r,e):c(`Unexpected resolution ${de(r)}`):void 0})(e,t)??((e,t)=>{const r=ue(t,{strict:!0});if(void 0!==r)return e.ctx.$.node("unit",{unit:r});const i=(e=>{if("n"!==e[e.length-1])return;const t=e.slice(0,-1);let r;try{r=BigInt(t)}catch{return}return ne.test(t)?r:oe.test(t)?c(ce(e,"bigint")):void 0})(t);return void 0!==i?e.ctx.$.node("unit",{unit:i}):void 0})(e,t)??e.error(""===t?$i(e):"#"===t[0]?`Private type references should not include '#'. Use '${t.slice(1)}' instead.`:Cr(t)))(e,t)})(e),en=e=>{for(;void 0===e.finalizer;)tn(e);return e},tn=e=>e.hasRoot()?e.parseOperator():e.parseOperand();class rn{ctx;scanner;root;branches={prefixes:[],leftBound:null,intersection:null,union:null};finalizer;groups=[];constructor(e,t){this.ctx=t,this.scanner=new ci(e)}error(e){return c(e)}hasRoot(){return void 0!==this.root}setRoot(e){this.root=e}unsetRoot(){const e=this.root;return this.root=void 0,e}constrainRoot(...e){this.root=this.root.constrain(e[0],e[1])}finalize(e){if(this.groups.length)return this.error(gi(")"));this.finalizeBranches(),this.finalizer=e}reduceLeftBound(e,t){const r=mi[t];return p(r,pi)?this.branches.leftBound?this.error(((e,t,r,i)=>`An expression may have at most one left bound (parsed ${this.branches.leftBound.limit}${mi[this.branches.leftBound.comparator]}, ${r}${mi[i]})`)(0,0,e,r)):void(this.branches.leftBound={comparator:r,limit:e}):this.error(yi(t))}finalizeBranches(){this.assertRangeUnset(),this.branches.union?(this.pushRootToBranch("|"),this.root=this.branches.union):this.branches.intersection?(this.pushRootToBranch("&"),this.root=this.branches.intersection):this.applyPrefixes()}finalizeGroup(){this.finalizeBranches();const e=this.groups.pop();if(!e)return this.error("Unmatched )"+(""===(t=this.scanner.unscanned)?"":` before ${t}`));var t;this.branches=e}addPrefix(e){this.branches.prefixes.push(e)}applyPrefixes(){for(;this.branches.prefixes.length;){const e=this.branches.prefixes.pop();this.root="keyof"===e?this.root.keyof():o(`Unexpected prefix '${e}'`)}}pushRootToBranch(e){this.assertRangeUnset(),this.applyPrefixes();const t=this.root;this.branches.intersection=this.branches.intersection?.and(t)??t,"|"===e&&(this.branches.union=this.branches.union?.or(this.branches.intersection)??this.branches.intersection,this.branches.intersection=null),this.root=void 0}parseUntilFinalizer(){return en(new rn(this.scanner.unscanned,this.ctx))}parseOperator(){return Ti(this)}parseOperand(){return Yi(this)}assertRangeUnset(){if(this.branches.leftBound)return this.error(`Left bounds are only valid when paired with right bounds (try ...${this.branches.leftBound.comparator}${this.branches.leftBound.limit})`)}reduceGroupOpen(){this.groups.push(this.branches),this.branches={prefixes:[],leftBound:null,union:null,intersection:null}}previousOperator(){return this.branches.leftBound?.comparator??this.branches.prefixes.at(-1)??(this.branches.intersection?"&":this.branches.union?"|":void 0)}shiftedByOne(){return this.scanner.shift(),this}}const nn=Object.freeze({errors:Be});class sn extends q{constructor(e){super((...t)=>{if(1===t.length)return e.parseRoot(t[0]);if(2===t.length&&"string"==typeof t[0]&&"<"===t[0][0]&&">"===t[0].at(-1)){const r=_i(t[0].slice(1,-1));return new li(r,t[1],e)}return e.parseRoot(t)},{bind:e,attach:nn})}}class on extends Er{parseCache={};constructor(e,t){const r={};for(const t in e){const i=an(t);r[i.name]=i.params.length?new li(i.params,e[t],{}):e[t]}super(r,t)}type=new sn(this);match=(e=>(()=>{}).bind(this))();declare=(()=>({type:this.type})).bind(this);define=(e=>e).bind(this);preparseRoot(e){return O(e)&&!ye(e,"generic")?e():e}parseRoot(e){return this.parse(e,{$:this,args:{}}).bindScope(this)}parse(e,t){return"string"==typeof e?t.args&&Object.keys(t.args).every(t=>!e.includes(t))?this.parseString(e,t):(this.parseCache[e]||(this.parseCache[e]=this.parseString(e,t)),this.parseCache[e]):K(e,"object")?((e,t)=>{const r=L(e);switch(r){case void 0:return ye(e,"root")?e:((e,t)=>{let r;const n={},s=x(e).map(ui);if("..."===s[0]?.kind){const e=s.shift(),i=t.$.parse(e.value,t);if(!i.hasKind("intersection")||!i.structure)return c((e=>`Spread operand must resolve to an object literal type (was ${e})`)("string"==typeof e.value?e.value:de(e.value)));r=i.structure}for(const e of s){if("..."===e.kind)return c("Spread operator may only be used as the first key in an object");if("+"!==e.kind)if("index"===e.kind){const r=t.$.parse(e.key,t),s=t.$.parse(e.value,t),o=hr(r,s,t.$);o.required&&(n.required=i(n.required,o.required)),o.index&&(n.index=i(n.index,o.index))}else{const r=t.$.parse(e.value,t),s={key:e.key,value:r};if(e.default!==k){const t=r(e.default);t instanceof Be&&c(`Default value at ${de(e.key)} ${t}`),r.assert(e.default),s.default=e.default}n[e.kind]=i(n[e.kind],s)}else"reject"!==e.value&&"delete"!==e.value&&"ignore"!==e.value&&c(`Value of '+' key must be 'reject', 'delete', or 'ignore' (was ${de(e.value)})`),n.undeclared=e.value}const o=t.$.node("structure",n);return t.$.schema({domain:"object",structure:r?.merge(o)??o})})(e,t);case"Array":return((e,t)=>((e,t)=>(e=>void 0!==Ri[e[0]])(e)?Ri[e[0]](e,t):(e=>void 0!==Si[e[1]])(e)?Si[e[1]](e,t):void 0)(e,t)??((e,t)=>{let r=[{}],i=0;for(;i<e.length;){let n=!1,s=!1;"..."===e[i]&&i<e.length-1&&(n=!0,i++);const o=t.$.parse(e[i],t);if(i++,"?"===e[i]){if(n)return c("A spread element cannot be optional");s=!0,i++}if(n){if(!o.extends(Tr.Array))return c(`Spread element must be an array (was ${o.expression})`);r=r.flatMap(e=>o.branches.map(t=>Ai(me(e),t)))}else r=r.map(e=>wi(e,s?"optional":"required",o))}return t.$.raw.schema(r.map(e=>({proto:Array,sequence:e})))})(e,t))(e,t);case"RegExp":return t.$.node("intersection",{domain:"string",regex:e},{prereduced:!0});case"Function":{const t=O(e)?e():e;return ye(t,"root")?t:c(Li("Function"))}default:return c(Li(r??de(e)))}})(e,t):c(Li(S(e)))}parseString(e,t){return this.maybeResolveRoot(e)??(e.endsWith("[]")&&this.maybeResolveRoot(e.slice(0,-2))?.array()||(e=>{e.parseOperand();const t=en(e).root;return t?(e.scanner.shiftUntilNonWhitespace(),e.scanner.lookahead&&c(Ui(e.scanner.lookahead)),t):o(`Root was unexpectedly unset after parsing string '${e.scanner.scanned}'`)})(new rn(e,t)))}}const an=e=>{const t=e.indexOf("<");return-1===t?{name:e,params:[]}:(">"!==e.at(-1)&&c("'>' must be the last character of a generic declaration in a scope"),{name:e.slice(0,t),params:_i(e.slice(t+1,-1))})},ln=((e,t={})=>new on(ai,t))();on.ambient=ln.raw,ln.export(),exports.arktypeResolver=function(t,r,i){return void 0===i&&(i={}),function(r,n,s){var o,a=t(r);return a instanceof Be?{values:{},errors:e.toNestErrors((o=a,o.forEach(function(e){return Object.assign(e,{type:e.code})}),o.byPath),s)}:(s.shouldUseNativeValidation&&e.validateFieldsNatively({},s),{errors:{},values:i.raw?r:a})}};
//# sourceMappingURL=arktype.js.map
